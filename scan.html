<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Inventario General 2026</title>
    <style>
        :root {
            --primary: #6f73e2;
            --success: #4CAF50;
            --warning: #FF9800;
            --error: #F44336;
            --blocked: #f97316;
            --bg: #f7f7f7;
            --text: #333;
            --card: #ffffff;
            --border: #e2e8f0;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Segoe UI', Tahoma, sans-serif;
            background: var(--bg);
            color: var(--text);
            height: 100vh;
            overflow: hidden;
        }

        /* Connection Banner */
        .connection-banner {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            padding: 10px;
            text-align: center;
            font-weight: 700;
            z-index: 10000;
            display: none;
            animation: slideDown 0.3s;
        }
        .connection-banner.offline {
            background: var(--error);
            color: white;
            display: block;
        }
        .connection-banner.online {
            background: var(--success);
            color: white;
            display: block;
        }
        .connection-banner.syncing {
            background: var(--warning);
            color: white;
            display: block;
        }
        @keyframes slideDown {
            from { transform: translateY(-100%); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        /* LOGIN */
        .login-screen {
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, #2563eb 0%, #1d4ed8 100%);
        }

        .login-card {
            background: white;
            padding: 3rem;
            border-radius: 16px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            text-align: center;
            max-width: 400px;
            width: 90%;
        }

        .login-icon {
            font-size: 4rem;
            margin-bottom: 1.5rem;
            animation: float 3s ease-in-out infinite;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        .login-title {
            font-size: 1.8rem;
            font-weight: 700;
            color: var(--text);
            margin-bottom: 0.5rem;
        }

        .login-subtitle {
            color: #666;
            margin-bottom: 2rem;
        }

        /* MAIN LAYOUT */
        .main-container {
            display: flex;
            height: 100vh;
        }

        /* SIDEBAR */
        .sidebar {
            width: 220px;
            background: #7c69fd; /* Morado pastel basado en el primario #6f73e2 */
            color: #333; /* Texto mÃ¡s oscuro para mejor contraste */
            padding: 15px;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }

        .sidebar-header {
            text-align: center;
            margin-bottom: 15px;
            padding: 15px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            border-bottom: 2px solid #e0e0e0;
        }

        .sidebar-header h2 {
            color: var(--primary);
            font-size: 1.3em;
            margin-bottom: 5px;
        }

        .sidebar-header p {
            font-size: 0.8em;
            color: #aaa;
        }

        .sidebar-section {
            margin-bottom: 15px;
        }

        .sidebar-section-title {
            font-size: 0.75em;
            color: #888;
            text-transform: uppercase;
            margin-bottom: 8px;
            letter-spacing: 0.5px;
        }

        .sidebar-btn {
            width: 100%;
            padding: 10px;
            margin-bottom: 8px;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.85em;
        }

        .sidebar-btn:hover {
            transform: translateX(3px);
        }

        .sidebar-btn-primary {
            background: var(--primary);
            color: white;
        }

        .sidebar-btn-secondary {
            background: #555;
            color: white;
        }

        /* Sync Status */
        .sync-status {
            padding: 10px 12px;
            border-radius: 6px;
            margin-bottom: 10px;
            font-size: 0.85em;
            text-align: center;
            cursor: pointer;
        }
        .sync-ok {
            background: rgba(76, 175, 80, 0.2);
            color: var(--success);
            border: 1px solid var(--success);
        }
        .sync-pending {
            background: rgba(255, 152, 0, 0.2);
            color: var(--warning);
            border: 1px solid var(--warning);
        }
        .sync-syncing {
            background: rgba(33, 150, 243, 0.2);
            color: #2196F3;
            border: 1px solid #2196F3;
            animation: pulse 1s infinite;
        }
        .sync-error {
            background: rgba(244, 67, 54, 0.2);
            color: var(--error);
            border: 1px solid var(--error);
        }
        .sync-warning {
            background: rgba(255, 152, 0, 0.2);
            color: var(--warning);
            border: 1px solid var(--warning);
        }

        /* Pallets por estatus */
        .pallet-status-list {
            flex: 1;
            overflow-y: auto;
        }

        .pallet-status-item {
            background: #444;
            border-radius: 6px;
            padding: 10px;
            margin-bottom: 8px;
        }

        .pallet-status-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
        }

        .pallet-status-name {
            font-weight: 600;
            font-size: 0.9em;
        }

        .pallet-status-count {
            background: rgba(255,255,255,0.2);
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 0.75em;
        }

        .pallet-code {
            font-family: monospace;
            font-size: 0.7em;
            color: #aaa;
            word-break: break-all;
        }

        .pallet-send-btn {
            margin-top: 6px;
            padding: 5px 10px;
            font-size: 0.7em;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            width: 100%;
            font-weight: 600;
        }

        .pallet-send-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .pallet-send-btn.ok { background: var(--success); color: white; }
        .pallet-send-btn.blocked { background: var(--blocked); color: white; }
        .pallet-send-btn.nowms { background: var(--error); color: white; }

        /* User Footer */
        .user-footer {
            margin-top: auto;
            padding-top: 15px;
            border-top: 1px solid #555;
        }

        .user-info {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }

        .user-avatar {
            width: 42px;
            height: 42px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--primary), #4f46e5);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 1.1em;
            color: white;
            flex-shrink: 0;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            text-transform: uppercase;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            transition: all 0.2s ease;
        }

        .user-avatar:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }

        .user-details {
            flex: 1;
            overflow: hidden;
        }

        .user-name {
            font-weight: 700;
            font-size: 0.95em;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            cursor: pointer;
            color: #f0f0f0;
            letter-spacing: 0.3px;
        }

        .user-email {
            font-size: 0.75em;
            color: #aaa;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            margin-top: 2px;
        }


        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .user-footer-actions {
            display: flex;
            gap: 5px;
            margin-bottom: 8px;
        }

        .user-footer-actions button {
            flex: 1;
            padding: 6px;
            font-size: 0.75em;
        }

        .bd-info {
            font-size: 0.7em;
            color: #aaa;
            text-align: center;
            line-height: 1.4;
        }

        /* MAIN CONTENT */
        .main-content {
            flex: 1;
            padding: 15px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* Header */
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .header h1 {
            color: var(--primary);
            font-size: 1.4em;
        }

        .header-actions {
            display: flex;
            gap: 8px;
        }

        /* Scan Section */
        .scan-section {
            background: white;
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 15px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .scan-row {
            display: flex;
            gap: 10px;
            align-items: flex-end;
        }

        .scan-input-group {
            flex: 1;
        }

        .scan-input-group label {
            display: block;
            font-size: 0.85em;
            font-weight: 600;
            margin-bottom: 5px;
        }

        .scan-input {
            width: 100%;
            padding: 12px 15px;
            font-size: 1.3em;
            border: 2px solid var(--border);
            border-radius: 8px;
            font-weight: 600;
            text-transform: uppercase;
            text-align: center;
            background: #fff5ed;
            transition: all 0.2s;
        }

        .scan-input:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
        }

        .scan-input.error {
            border-color: var(--error);
            background: #ffebee;
        }

        .scan-input.success {
            border-color: var(--success);
            background: #e8f5e9;
        }

        /* Result Box */
        .result-box {
            padding: 12px;
            border-radius: 8px;
            margin-top: 10px;
            display: none;
            animation: fadeIn 0.3s;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-5px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .result-box.show { display: block; }
        .result-box.success { background: #e8f5e9; border: 2px solid var(--success); }
        .result-box.warning { background: #fff3e0; border: 2px solid var(--warning); }
        .result-box.blocked { background: #fff3e0; border: 2px solid var(--blocked); }
        .result-box.error { background: #ffebee; border: 2px solid var(--error); }

        .result-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 8px;
        }

        .result-icon { font-size: 1.5rem; }
        .result-title { font-weight: 700; font-size: 1.1em; }
        .result-code { font-family: monospace; font-weight: 600; }

        .result-details {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 8px;
            font-size: 0.85em;
        }

        .result-detail-label { color: #666; font-size: 0.8em; }
        .result-detail-value { font-weight: 600; }

        /* Code2 Input */
        .code2-container {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 2px dashed var(--error);
            display: none;
        }

        .code2-container.show { display: block; }

        .code2-row {
            display: flex;
            gap: 10px;
            align-items: flex-end;
        }

        .btn-insertado {
            padding: 12px 20px;
            background: var(--error);
            color: white;
            border: none;
            border-radius: 8px;
            font-weight: 700;
            cursor: pointer;
            white-space: nowrap;
        }

        .btn-insertado:hover {
            background: #d32f2f;
        }

        /* Columns Container */
        .columns-container {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
            flex: 1;
            min-height: 0;
        }

        .column {
            background: white;
            border-radius: 12px;
            padding: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .column-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 2px solid var(--border);
        }

        .column-title {
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .column-count {
            padding: 3px 10px;
            border-radius: 15px;
            font-weight: 700;
            font-size: 0.85em;
        }

        .column.ok .column-title { color: var(--success); }
        .column.ok .column-count { background: rgba(76, 175, 80, 0.15); color: var(--success); }

        .column.blocked .column-title { color: var(--blocked); }
        .column.blocked .column-count { background: rgba(249, 115, 22, 0.15); color: var(--blocked); }

        .column.nowms .column-title { color: var(--error); }
        .column.nowms .column-count { background: rgba(244, 67, 54, 0.15); color: var(--error); }

        .column-pallet-info {
            background: #f5f5f5;
            padding: 8px;
            border-radius: 6px;
            margin-bottom: 10px;
            font-size: 0.8em;
        }

        .column-pallet-code {
            font-family: monospace;
            font-weight: 600;
            color: var(--primary);
        }

        .column-location-input {
            width: 100%;
            padding: 6px 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 0.85em;
            margin-top: 6px;
        }

        .column-send-btn {
            margin-top: 8px;
            padding: 8px;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            width: 100%;
            font-size: 0.85em;
        }

        .column-send-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .column.ok .column-send-btn { background: var(--success); color: white; }
        .column.blocked .column-send-btn { background: var(--blocked); color: white; }
        .column.nowms .column-send-btn { background: var(--error); color: white; }

        .column-list {
            flex: 1;
            overflow-y: auto;
            counter-reset: item-counter;
        }

        .box-item {
            padding: 8px 10px;
            background: #f9f9f9;
            border-radius: 6px;
            margin-bottom: 6px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-left: 3px solid;
            counter-increment: item-counter;
        }

        .box-item::before {
            content: counter(item-counter) ".";
            font-weight: 700;
            min-width: 25px;
            margin-right: 8px;
        }

        .column.ok .box-item { border-color: var(--success); }
        .column.ok .box-item::before { color: var(--success); }

        .column.blocked .box-item { border-color: var(--blocked); }
        .column.blocked .box-item::before { color: var(--blocked); }

        .column.nowms .box-item { border-color: var(--error); }
        .column.nowms .box-item::before { color: var(--error); }

        .box-info { flex: 1; }
        .box-code { font-weight: 600; font-family: monospace; font-size: 0.9em; }
        .box-meta { font-size: 0.75em; color: #666; }

        .box-delete {
            background: none;
            border: none;
            color: var(--error);
            cursor: pointer;
            font-size: 1.1em;
            padding: 4px;
            opacity: 0.6;
        }

        .box-delete:hover { opacity: 1; }

        .empty-state {
            text-align: center;
            padding: 30px 15px;
            color: #999;
        }

        .empty-icon { font-size: 2.5em; margin-bottom: 8px; opacity: 0.5; }

        /* Buttons */
        .btn {
            padding: 10px 18px;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }

        .btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-primary { background: var(--primary); color: white; }
        .btn-success { background: var(--success); color: white; }
        .btn-warning { background: var(--warning); color: white; }
        .btn-danger { background: var(--error); color: white; }
        .btn-secondary { background: #6c757d; color: white; }
        .btn-google { background: #4285F4; color: white; }

        .btn-small { padding: 6px 12px; font-size: 0.85em; }
        .btn-full { width: 100%; }

        /* Notifications */
        .notification-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 9999;
            max-width: 350px;
        }

        .notification {
            background: white;
            padding: 12px 15px;
            margin-bottom: 8px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            border-left: 4px solid;
            animation: slideIn 0.3s;
        }

        .notification.success { border-color: var(--success); }
        .notification.error { border-color: var(--error); }
        .notification.warning { border-color: var(--warning); }
        .notification.info { border-color: var(--primary); }

        @keyframes slideIn {
            from { transform: translateX(400px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        /* Popups */
        .popup-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.6);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .popup-overlay.show { display: flex; }

        .popup-content {
            background: white;
            padding: 25px;
            border-radius: 12px;
            max-width: 1000px;
            width: 95%;
            max-height: 85vh;
            overflow-y: auto;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
        }

        .popup-header {
            font-size: 1.3em;
            font-weight: 700;
            margin-bottom: 15px;
            color: var(--primary);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .popup-close {
            background: none;
            border: none;
            font-size: 1.5em;
            cursor: pointer;
            color: #999;
        }

        .popup-close:hover { color: #333; }

        .popup-buttons {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 15px;
        }

        /* Resumen Module */
        .resumen-stats {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 12px;
            margin-bottom: 20px;
        }

        .resumen-stat {
            text-align: center;
            padding: 15px;
            border-radius: 8px;
            background: #f5f5f5;
        }

        .resumen-stat-number {
            font-size: 2em;
            font-weight: 700;
        }

        .resumen-stat-label {
            font-size: 0.8em;
            color: #666;
        }

        .resumen-stat.ok { border: 2px solid var(--success); }
        .resumen-stat.ok .resumen-stat-number { color: var(--success); }

        .resumen-stat.blocked { border: 2px solid var(--blocked); }
        .resumen-stat.blocked .resumen-stat-number { color: var(--blocked); }

        .resumen-stat.nowms { border: 2px solid var(--error); }
        .resumen-stat.nowms .resumen-stat-number { color: var(--error); }

        .resumen-stat.pending { border: 2px solid var(--warning); }
        .resumen-stat.pending .resumen-stat-number { color: var(--warning); }

        .resumen-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.85em;
        }

        .resumen-table th, .resumen-table td {
            padding: 10px;
            text-align: left;
            border-bottom: 1px solid #eee;
        }

        .resumen-table th {
            background: #f5f5f5;
            font-weight: 700;
            position: sticky;
            top: 0;
        }

        .resumen-table-container {
            max-height: 300px;
            overflow-y: auto;
        }

        .resumen-actions {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        /* Ajuste Module Styles */
        .ajuste-search-container {
            margin-bottom: 20px;
            padding: 15px;
            background: #f5f5f5;
            border-radius: 8px;
        }

        .ajuste-search-input {
            width: 100%;
            padding: 12px;
            font-size: 1em;
            border: 2px solid #ddd;
            border-radius: 6px;
            margin-bottom: 10px;
        }

        .ajuste-search-input:focus {
            outline: none;
            border-color: var(--primary);
        }

        .ajuste-pallets-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .ajuste-pallet-card {
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .ajuste-pallet-card:hover {
            border-color: var(--primary);
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            transform: translateY(-2px);
        }

        .ajuste-pallet-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid #eee;
        }

        .ajuste-pallet-code {
            font-size: 1.1em;
            font-weight: 700;
            color: var(--primary);
            font-family: monospace;
        }

        .ajuste-pallet-count {
            background: var(--primary);
            color: white;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 0.85em;
            font-weight: 600;
        }

        .ajuste-pallet-info {
            font-size: 0.85em;
            color: #666;
            line-height: 1.6;
        }

        .ajuste-pallet-info-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
        }

        .ajuste-pallet-label {
            font-weight: 600;
        }

        .ajuste-empty-state {
            text-align: center;
            padding: 40px;
            color: #999;
        }

        .hidden { display: none !important; }

        /* Loading Overlay */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 10001;
            flex-direction: column;
        }

        .loading-overlay.show {
            display: flex;
        }

        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 5px solid rgba(255, 255, 255, 0.2);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading-text {
            color: white;
            font-size: 1.2em;
            font-weight: 600;
            text-align: center;
            max-width: 300px;
        }

        .loading-subtext {
            color: rgba(255, 255, 255, 0.7);
            font-size: 0.9em;
            margin-top: 8px;
            text-align: center;
        }

        /* Cabecera Principal de Escaneo */
        .scan-header-bar {
            background: linear-gradient(135deg, #764acd 0%, #3347dc 100%);
            padding: 10px 15px;
            border-radius: 10px;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 12px;
            box-shadow: 0 2px 8px rgba(22, 64, 249, 0.3);
            flex-wrap: wrap;
        }

        .origin-location-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .origin-location-group label {
            color: white;
            font-weight: 600;
            font-size: 0.8em;
            white-space: nowrap;
        }

        .origin-location-input {
            width: 140px;
            padding: 8px 10px;
            border: 2px solid rgba(255, 255, 255, 0.4);
            border-radius: 6px;
            font-size: 0.9em;
            font-weight: 600;
            text-transform: uppercase;
            background: rgba(255, 255, 255, 0.95);
            transition: all 0.2s;
        }

        .origin-location-input:focus {
            outline: none;
            border-color: white;
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.4);
        }

        .origin-location-input::placeholder {
            color: #a0aec0;
            font-weight: 400;
            font-size: 0.85em;
        }

        /* Contador Global de Cajas */
        .global-counter {
            background: rgba(0, 0, 0, 0.25);
            padding: 6px 12px;
            border-radius: 6px;
            display: flex;
            align-items: center;
            gap: 8px;
            margin-left: auto;
        }

        .global-counter-label {
            color: rgba(255, 255, 255, 0.9);
            font-size: 0.8em;
            font-weight: 500;
        }

        .global-counter-value {
            background: white;
            color: #f97316;
            padding: 3px 10px;
            border-radius: 12px;
            font-weight: 700;
            font-size: 1em;
            min-width: 32px;
            text-align: center;
        }

        /* Box Item mejorado con acciones hover */
        .box-item {
            padding: 6px 8px;
            background: #f9f9f9;
            border-radius: 6px;
            margin-bottom: 4px;
            display: flex;
            align-items: center;
            border-left: 3px solid;
            counter-increment: item-counter;
            position: relative;
            transition: all 0.15s;
        }

        .box-item:hover {
            background: #f0f0f0;
        }

        .box-item::before {
            content: counter(item-counter) ".";
            font-weight: 700;
            min-width: 20px;
            margin-right: 6px;
            font-size: 0.8em;
        }

        .box-info { flex: 1; min-width: 0; }
        .box-code { font-weight: 600; font-family: monospace; font-size: 0.8em; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .box-meta { font-size: 0.7em; color: #666; }

        .box-actions {
            display: flex;
            gap: 2px;
            opacity: 0;
            transition: opacity 0.15s;
        }

        .box-item:hover .box-actions {
            opacity: 1;
        }

        .box-action-btn {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 0.85em;
            padding: 3px 5px;
            border-radius: 4px;
            opacity: 0.6;
            transition: all 0.15s;
        }

        .box-action-btn:hover {
            opacity: 1;
            background: rgba(0,0,0,0.08);
        }

        .box-action-btn.copy { color: var(--primary); border: 1px solid var(--primary); background: rgba(249, 115, 22, 0.08); }
        .box-action-btn.move { color: var(--warning); border: 1px solid var(--warning); background: rgba(255, 193, 7, 0.08); }
        .box-action-btn.check { color: #228B22; border: 1px solid #228B22; background: rgba(34, 139, 34, 0.1); }
        .box-action-btn.check.verified { color: white; background: #228B22; border-color: #228B22; }
        .box-action-btn.delete { color: var(--error); border: 1px solid var(--error); background: rgba(244, 67, 54, 0.08); }
        .box-action-btn:hover { transform: scale(1.1); filter: brightness(1.1); }

        .box-item.verified {
            background: rgba(34, 139, 34, 0.15);
            border-left-color: #228B22 !important;
        }

        /* Source badges for two-level inventory search */
        .inventory-badge {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 0.7em;
            font-weight: 700;
            margin-left: 8px;
        }
        .inventory-badge.badge-WMS {
            background: #4CAF50;
            color: white;
        }
        .inventory-badge.badge-FILE2 {
            background: #2196F3;
            color: white;
        }
        .inventory-badge.badge-UNKNOWN {
            background: #FF6B6B;
            color: white;
        }

        /* Priority badge - Purple/Morado */
        .priority-badge {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 0.7em;
            font-weight: 700;
            margin-left: 8px;
            background: linear-gradient(135deg, #9C27B0, #7B1FA2);
            color: white;
            animation: priorityPulse 2s ease-in-out infinite;
            box-shadow: 0 2px 8px rgba(156, 39, 176, 0.4);
        }

        @keyframes priorityPulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.85; transform: scale(1.05); }
        }

        .box-item.verified .box-check-icon {
            color: #228B22;
        }
        
        .box-item.verified::before {
            color: #228B22 !important;
        }

        /* Scan Section Compacta */
        .scan-section {
            background: white;
            border-radius: 10px;
            padding: 10px 12px;
            margin-bottom: 10px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.08);
        }

        .scan-input {
            width: 100%;
            padding: 10px 12px;
            font-size: 1.1em;
            border: 2px solid var(--border);
            border-radius: 6px;
            font-weight: 600;
            text-transform: uppercase;
            text-align: center;
            background: #fff5ed;
            transition: all 0.2s;
        }

        /* Result Box Compacto Horizontal */
        .result-box {
            padding: 8px 12px;
            border-radius: 6px;
            margin-top: 8px;
            display: none;
            animation: fadeIn 0.2s;
        }

        .result-box.show { display: block; }

        .result-compact {
            display: flex;
            align-items: center;
            gap: 12px;
            flex-wrap: wrap;
        }

        .result-status {
            display: flex;
            align-items: center;
            gap: 6px;
            font-weight: 700;
            font-size: 0.95em;
        }

        .result-status .icon { font-size: 1.1em; }

        .result-info {
            display: flex;
            gap: 15px;
            flex: 1;
            flex-wrap: wrap;
            font-size: 0.8em;
        }

        .result-info-item {
            display: flex;
            gap: 4px;
        }

        .result-info-label { color: #666; }
        .result-info-value { font-weight: 600; font-family: monospace; }

        /* Modal de Detalle de Pallet */
        .pallet-detail-modal {
            max-width: 1200px;
            width: 95vw;
        }

        .pallet-detail-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid var(--border);
        }

        .pallet-detail-counters {
            display: flex;
            gap: 10px;
        }

        .counter-badge {
            padding: 4px 12px;
            border-radius: 15px;
            font-weight: 700;
            font-size: 0.85em;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .counter-badge.ok { background: rgba(34, 139, 34, 0.2); color: #228B22; border: 1px solid #228B22; }
        .counter-badge.pending { background: rgba(220, 38, 38, 0.2); color: #DC2626; border: 1px solid #DC2626; }

        .pallet-detail-filters {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
            flex-wrap: wrap;
        }

        .pallet-detail-filters input,
        .pallet-detail-filters select {
            padding: 6px 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 0.85em;
        }

        .pallet-detail-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.85em;
        }

        .pallet-detail-table th {
            background: #f5f5f5;
            padding: 8px;
            text-align: left;
            font-weight: 600;
            cursor: pointer;
            user-select: none;
            position: sticky;
            top: 0;
        }

        .pallet-detail-table th:hover {
            background: #eee;
        }

        .pallet-detail-table th .sort-icon {
            margin-left: 4px;
            opacity: 0.5;
        }

        .pallet-detail-table td {
            padding: 6px 8px;
            border-bottom: 1px solid #eee;
        }

        .pallet-detail-table tr:hover {
            background: #f9f9f9;
        }

        .pallet-detail-table-container {
            max-height: 400px;
            overflow-y: auto;
        }

        /* Popup Duplicado */
        .duplicate-popup {
            max-width: 420px;
        }

        .duplicate-info {
            background: #fff3e0;
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 15px;
            border: 2px solid var(--warning);
        }

        .duplicate-info-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 6px;
            font-size: 0.9em;
        }

        .duplicate-info-label { color: #666; }
        .duplicate-info-value { font-weight: 600; }

        /* Pre-validaciÃ³n EnvÃ­o */
        .send-validation-popup {
            max-width: 380px;
        }

        .validation-input-group {
            margin-bottom: 15px;
        }

        .validation-input-group label {
            display: block;
            margin-bottom: 6px;
            font-weight: 600;
        }

        .validation-input-group input {
            width: 100%;
            padding: 12px;
            font-size: 1.5em;
            text-align: center;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-weight: 700;
        }

        .validation-mismatch {
            background: #ffebee;
            border: 2px solid var(--error);
            padding: 10px;
            border-radius: 6px;
            text-align: center;
            color: var(--error);
            font-weight: 600;
            margin-bottom: 15px;
        }

        .validation-match {
            background: #e8f5e9;
            border: 2px solid var(--success);
            padding: 10px;
            border-radius: 6px;
            text-align: center;
            color: var(--success);
            font-weight: 600;
            margin-bottom: 15px;
        }

        /* Responsive */
        @media (max-width: 1024px) {
            .sidebar { width: 180px; }
            .columns-container { grid-template-columns: 1fr; }
            .resumen-stats { grid-template-columns: repeat(2, 1fr); }
        }

        @media (max-width: 768px) {
            .main-container { flex-direction: column; }
            .sidebar { width: 100%; max-height: 200px; }
        }

        /* ==================== UNIFIED CAPTURE MODULE STYLES ==================== */

        /* Tab System */
        .unified-tabs-container {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: #f0f0f0;
            border-radius: 10px 10px 0 0;
            overflow-x: auto;
            min-height: 48px;
        }

        .unified-tab {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 8px 14px;
            background: white;
            border: 2px solid #ddd;
            border-radius: 8px 8px 0 0;
            border-bottom: none;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.85em;
            transition: all 0.2s;
            white-space: nowrap;
            position: relative;
            margin-bottom: -2px;
        }

        .unified-tab:hover {
            background: #f9f9f9;
        }

        .unified-tab.active {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }

        .unified-tab .tab-count {
            background: rgba(0,0,0,0.15);
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 0.8em;
        }

        .unified-tab.active .tab-count {
            background: rgba(255,255,255,0.3);
        }

        .unified-tab .tab-close {
            background: none;
            border: none;
            color: currentColor;
            cursor: pointer;
            font-size: 1.1em;
            padding: 0 2px;
            opacity: 0.6;
            transition: opacity 0.2s;
        }

        .unified-tab .tab-close:hover {
            opacity: 1;
        }

        .unified-tab-new {
            padding: 8px 14px;
            background: #76747f;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.85em;
            display: flex;
            align-items: center;
            gap: 4px;
            transition: all 0.2s;
        }

        .unified-tab-new:hover {
            background: #7783ec;
            transform: translateY(-1px);
        }

        .unified-tab-new:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        /* Empty State for Tabs */
        .unified-empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 60px 20px;
            text-align: center;
            background: white;
            border-radius: 0 0 12px 12px;
            min-height: 400px;
        }

        .unified-empty-icon {
            font-size: 5em;
            margin-bottom: 20px;
            opacity: 0.4;
        }

        .unified-empty-text {
            font-size: 1.2em;
            color: #666;
            margin-bottom: 20px;
        }

        .unified-empty-btn {
            padding: 15px 30px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 1.1em;
            font-weight: 700;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.2s;
        }

        .unified-empty-btn:hover {
            background: #43a047;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(76, 175, 80, 0.3);
        }

        /* Unified Main Content */
        .unified-content {
            background: white;
            border-radius: 0 0 12px 12px;
            padding: 15px;
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* Unified Pallet View */
        .unified-pallet {
            background: #f9f9f9;
            border-radius: 10px;
            padding: 15px;
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .unified-pallet-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .unified-pallet-info {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .unified-pallet-id {
            font-family: monospace;
            font-weight: 700;
            font-size: 1.1em;
            color: var(--primary);
        }

        .unified-status-badges {
            display: flex;
            gap: 8px;
        }

        .unified-status-badge {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 4px 10px;
            border-radius: 15px;
            font-weight: 700;
            font-size: 0.85em;
        }

        .unified-status-badge.ok {
            background: rgba(76, 175, 80, 0.15);
            color: var(--success);
        }

        .unified-status-badge.blocked {
            background: rgba(249, 115, 22, 0.15);
            color: var(--blocked);
        }

        .unified-status-badge.nowms {
            background: rgba(244, 67, 54, 0.15);
            color: var(--error);
        }

        .unified-pallet-actions {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .unified-location-input {
            width: 208px;
            padding: 8px 12px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 0.9em;
            font-weight: 600;
            text-transform: uppercase;
        }

        .unified-location-input:focus {
            border-color: var(--primary);
            outline: none;
        }

        .unified-send-btn {
            padding: 10px 20px;
            background: linear-gradient(135deg, var(--primary), #1e40af);
            color: white;
            border: none;
            border-radius: 8px;
            font-weight: 700;
            font-size: 0.95em;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 6px;
            transition: all 0.2s;
        }

        .unified-send-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(76, 175, 80, 0.3);
        }

        .unified-send-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        /* Cancelados Toggle Switch */
        .cancelados-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            padding: 6px 12px;
            background: #f5f5f5;
            border-radius: 8px;
            border: 2px solid #e0e0e0;
            transition: all 0.3s ease;
            user-select: none;
        }

        .cancelados-toggle:hover {
            border-color: #ff5722;
            background: #fff3e0;
        }

        .cancelados-toggle input[type="checkbox"] {
            display: none;
        }

        .cancelados-slider {
            width: 40px;
            height: 22px;
            background: #ccc;
            border-radius: 11px;
            position: relative;
            transition: all 0.3s ease;
        }

        .cancelados-slider::before {
            content: '';
            position: absolute;
            width: 18px;
            height: 18px;
            background: white;
            border-radius: 50%;
            top: 2px;
            left: 2px;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .cancelados-toggle input:checked + .cancelados-slider {
            background: linear-gradient(135deg, #ff5722, #e64a19);
        }

        .cancelados-toggle input:checked + .cancelados-slider::before {
            left: 20px;
        }

        .cancelados-text {
            font-weight: 600;
            font-size: 0.85em;
            color: #666;
            transition: color 0.3s ease;
        }

        .cancelados-toggle input:checked ~ .cancelados-text {
            color: #ff5722;
        }

        .cancelados-toggle.active {
            background: linear-gradient(135deg, #fff3e0, #ffe0b2);
            border-color: #ff5722;
        }

        /* Cancelados Mode Indicator Badge */
        .cancelados-mode-badge {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 2px 8px;
            background: linear-gradient(135deg, #ff5722, #e64a19);
            color: white;
            font-size: 0.7em;
            font-weight: 700;
            border-radius: 4px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            animation: pulse-cancel 2s infinite;
        }

        @keyframes pulse-cancel {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.8; }
        }

        /* Badge on each box entry when in cancelados mode */
        .unified-log-entry.cancelado-mode {
            border-left: 4px solid #ff5722 !important;
            background: linear-gradient(90deg, rgba(255, 87, 34, 0.08) 0%, transparent 30%);
        }

        .unified-log-entry .cancelado-badge {
            display: inline-flex;
            align-items: center;
            gap: 3px;
            padding: 2px 6px;
            background: linear-gradient(135deg, #ff5722, #e64a19);
            color: white;
            font-size: 0.65em;
            font-weight: 700;
            border-radius: 3px;
            text-transform: uppercase;
            margin-left: 8px;
        }

        /* Header indicator when cancelados mode is active */
        .cancelados-active-indicator {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            background: linear-gradient(135deg, #ff5722, #e64a19);
            color: white;
            border-radius: 6px;
            font-size: 0.8em;
            font-weight: 700;
            animation: pulse-cancel 2s infinite;
        }

        .cancelados-active-indicator::before {
            content: 'ðŸš«';
        }

        /* Unified List */
        .unified-list-container {
            flex: 1;
            overflow-y: auto;
            margin-top: 10px;
        }

        .unified-list {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .unified-box-item {
            padding: 10px 12px;
            background: white;
            border-radius: 8px;
            display: flex;
            align-items: center;
            border-left: 4px solid;
            transition: all 0.15s;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }

        .unified-box-item:hover {
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .unified-box-item.ok { border-left-color: var(--success); }
        .unified-box-item.blocked { border-left-color: var(--blocked); }
        .unified-box-item.nowms { border-left-color: var(--error); }

        /* Cancelado mode styling for unified box items */
        .unified-box-item.cancelado-mode {
            border-left: 4px solid #ff5722 !important;
            background: linear-gradient(90deg, rgba(255, 87, 34, 0.1) 0%, rgba(255, 87, 34, 0.02) 30%, transparent 50%);
        }

        .unified-box-item .cancelado-badge {
            display: inline-flex;
            align-items: center;
            gap: 3px;
            padding: 2px 8px;
            background: linear-gradient(135deg, #ff5722, #e64a19);
            color: white;
            font-size: 0.7em;
            font-weight: 700;
            border-radius: 4px;
            text-transform: uppercase;
            margin-left: 10px;
            letter-spacing: 0.5px;
            box-shadow: 0 1px 3px rgba(255, 87, 34, 0.3);
        }

        .unified-box-num {
            font-weight: 700;
            min-width: 30px;
            color: inherit;
        }

        .unified-box-item.ok .unified-box-num { color: var(--success); }
        .unified-box-item.blocked .unified-box-num { color: var(--blocked); }
        .unified-box-item.nowms .unified-box-num { color: var(--error); }

        .unified-box-status-icon {
            font-size: 1.1em;
            margin-right: 10px;
        }

        .unified-box-info {
            flex: 1;
            min-width: 0;
        }

        .unified-box-code {
            font-weight: 600;
            font-family: monospace;
            font-size: 0.95em;
        }

        .unified-box-meta {
            font-size: 0.75em;
            color: #666;
        }

        .unified-box-actions {
            display: flex;
            gap: 4px;
            opacity: 0;
            transition: opacity 0.15s;
        }

        .unified-box-item:hover .unified-box-actions {
            opacity: 1;
        }

        /* Scan Log */
        .unified-scan-log {
            background: #1a1a2e;
            border-radius: 8px;
            padding: 10px;
            margin-top: 12px;
            max-height: 150px;
            overflow-y: auto;
        }

        .unified-scan-log-title {
            color: #888;
            font-size: 0.75em;
            text-transform: uppercase;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .unified-log-entry {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 6px 8px;
            border-radius: 4px;
            font-size: 0.85em;
            font-family: monospace;
            margin-bottom: 4px;
            animation: logSlideIn 0.2s ease-out;
        }

        @keyframes logSlideIn {
            from { opacity: 0; transform: translateX(-10px); }
            to { opacity: 1; transform: translateX(0); }
        }

        .unified-log-entry.ok { background: rgba(76, 175, 80, 0.15); color: #a5d6a7; }
        .unified-log-entry.blocked { background: rgba(249, 115, 22, 0.15); color: #ffcc80; }
        .unified-log-entry.nowms { background: rgba(244, 67, 54, 0.15); color: #ef9a9a; }

        .unified-log-time {
            color: #888;
            font-size: 0.9em;
        }

        .unified-log-code {
            flex: 1;
            font-weight: 600;
        }

        .unified-log-status {
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 0.8em;
            font-weight: 600;
        }

        .unified-log-entry.ok .unified-log-status { background: var(--success); color: white; }
        .unified-log-entry.blocked .unified-log-status { background: var(--blocked); color: white; }
        .unified-log-entry.nowms .unified-log-status { background: var(--error); color: white; }


        /* Module Visibility Control */
        .module-hidden {
            display: none !important;
        }

        .module-visible {
            display: flex !important;
        }

        /* Unified Module Container */
        .unified-module-container {
            flex-direction: column;
            flex: 1;
            overflow: hidden;
        }

        .unified-module-container.module-visible {
            display: flex !important;
        }

        /* Classic Module when visible */
        #classic-module {
            display: flex;
            flex-direction: column;
            flex: 1;
            overflow: hidden;
        }

        #classic-module.module-visible {
            display: flex !important;
        }

        /* Welcome State - No active sessions */
        .welcome-state {
            flex: 1;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 16px;
            margin: 10px 0;
        }

        .welcome-state.module-visible {
            display: flex !important;
        }

        .welcome-content {
            text-align: center;
            padding: 40px;
            max-width: 400px;
        }

        .welcome-icon {
            font-size: 4rem;
            margin-bottom: 20px;
            animation: float 3s ease-in-out infinite;
        }

        .welcome-title {
            font-size: 1.5em;
            font-weight: 700;
            color: #333;
            margin-bottom: 8px;
        }

        .welcome-subtitle {
            font-size: 1.1em;
            color: #666;
            margin-bottom: 16px;
        }

        .welcome-text {
            font-size: 0.95em;
            color: #888;
            line-height: 1.5;
            margin-bottom: 24px;
        }

        .welcome-btn {
            padding: 14px 28px;
            background: linear-gradient(135deg, #0077ffb9 0%, #0d5383 100%);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 1em;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(255, 152, 0, 0.4);
        }

        .welcome-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(255, 152, 0, 0.5);
        }

        /* Work Type Selection Popup - Professional Design */
        .work-type-popup {
            max-width: 550px;
            background: linear-gradient(180deg, #ffffff 0%, #f8f9fa 100%);
        }

        .work-type-toggle-container {
            display: flex;
            background: #f1f3f5;
            border-radius: 12px;
            padding: 6px;
            margin-bottom: 20px;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.06);
        }

        .work-type-toggle-btn {
            flex: 1;
            padding: 14px 16px;
            border: none;
            border-radius: 10px;
            font-size: 0.95em;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            background: transparent;
            color: #666;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .work-type-toggle-btn:hover:not(.active) {
            background: rgba(255, 152, 0, 0.1);
            color: #f57c00;
        }

        .work-type-toggle-btn.active {
            background: linear-gradient(135deg, #2943a1 0%, #002df5 100%);
            color: white;
            box-shadow: 0 4px 12px rgba(255, 152, 0, 0.4);
            transform: scale(1.02);
        }

        .work-type-toggle-btn .toggle-icon {
            font-size: 1.2em;
        }

        .work-type-description {
            background: #fff;
            border: 1px solid #e9ecef;
            border-radius: 10px;
            padding: 16px;
            margin-bottom: 16px;
            min-height: 80px;
            transition: all 0.3s ease;
        }

        .work-type-description-title {
            font-weight: 700;
            font-size: 1em;
            color: #333;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .work-type-description-text {
            font-size: 0.85em;
            color: #666;
            line-height: 1.5;
        }

        .work-type-locked {
            background: linear-gradient(135deg, rgba(255, 152, 0, 0.08) 0%, rgba(255, 152, 0, 0.15) 100%);
            border: 1px solid rgba(255, 152, 0, 0.3);
            border-radius: 8px;
            padding: 10px 14px;
            font-size: 0.8em;
            color: #007be6;
            margin-top: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .work-type-confirm-btn {
            width: 100%;
            padding: 14px 20px;
            background: linear-gradient(135deg, #62dee2 0%, #0b2c80 100%);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 1em;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            box-shadow: 0 4px 12px rgba(255, 152, 0, 0.3);
        }

        .work-type-confirm-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 152, 0, 0.4);
        }

        .work-type-confirm-btn:disabled {
            background: #ccc;
            box-shadow: none;
            cursor: not-allowed;
        }

        /* Blind Count - blur counters when validation popup opens */
        .blind-mode .global-counter-value,
        .blind-mode .column-count,
        .blind-mode .unified-status-badge,
        .blind-mode .tab-count,
        .blind-mode #ok-count,
        .blind-mode #blocked-count,
        .blind-mode #nowms-count,
        .blind-mode #unified-global-box-count,
        .blind-mode #unified-ok-count,
        .blind-mode #unified-blocked-count,
        .blind-mode #unified-nowms-count,
        .blind-mode .sidebar-pallet-count,
        .blind-mode #sidebar-ok-count,
        .blind-mode #sidebar-blocked-count,
        .blind-mode #sidebar-nowms-count {
            filter: blur(8px);
            user-select: none;
        }

        /* Global Summary in Sidebar - Vertical Professional Design */
        .global-summary-section {
            background: linear-gradient(180deg, #3a3a3a 0%, #2d2d2d 100%);
            border-radius: 10px;
            padding: 14px;
            margin-bottom: 12px;
        }

        .global-summary-title {
            font-size: 0.7em;
            color: #888;
            text-transform: uppercase;
            margin-bottom: 12px;
            text-align: center;
            letter-spacing: 1px;
            font-weight: 600;
        }

        .global-summary-grid {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .global-summary-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 14px;
            background: linear-gradient(135deg, #444 0%, #3a3a3a 100%);
            border-radius: 8px;
            border-left: 4px solid;
            transition: all 0.2s ease;
        }

        .global-summary-item:hover {
            transform: translateX(3px);
        }

        .global-summary-item.ok { border-left-color: var(--success); }
        .global-summary-item.blocked { border-left-color: var(--blocked); }
        .global-summary-item.nowms { border-left-color: var(--error); }

        .global-summary-label {
            font-size: 0.85em;
            color: #ccc;
            font-weight: 500;
        }

        .global-summary-count {
            font-size: 1.4em;
            font-weight: 700;
            line-height: 1;
            min-width: 40px;
            text-align: right;
        }

        .global-summary-count.ok { color: var(--success); }
        .global-summary-count.blocked { color: var(--blocked); }
        .global-summary-count.nowms { color: var(--error); }

        .global-summary-total {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-top: 12px;
            padding: 14px;
            background: linear-gradient(135deg, #2563eb 0%, #1d4ed8 100%);
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(37, 99, 235, 0.3);
        }

        .global-summary-total-label {
            font-size: 0.85em;
            color: rgba(255,255,255,0.9);
            font-weight: 600;
        }

        .global-summary-total-count {
            font-size: 1.6em;
            font-weight: 700;
            color: white;
        }
    </style>
</head>
<body>
    <div class="connection-banner" id="connection-banner"></div>
    <div class="notification-container" id="notifications"></div>

    <!-- LOADING OVERLAY -->
    <div class="loading-overlay" id="loading-overlay">
        <div class="loading-spinner"></div>
        <div class="loading-text" id="loading-text">ðŸ“¦ Inicializando Sistema...</div>
        <div class="loading-subtext" id="loading-subtext">Preparando aplicaciÃ³n</div>
    </div>

    <!-- LOGIN SCREEN -->
    <div class="login-screen" id="login-screen">
        <div class="login-card">
            <div class="login-icon">ðŸ“¦</div>
            <h1 class="login-title">Inventario General </h1>
            <p class="login-subtitle">Enero 2026</p>
            <button class="btn btn-google btn-full" id="login-button" style="padding: 15px; font-size: 1.1em;">
                ðŸ” Iniciar sesiÃ³n con Google
            </button>
        </div>
    </div>

    <!-- MAIN APP -->
    <div id="main-app" class="hidden">
        <div class="main-container">
            <!-- SIDEBAR -->
            <div class="sidebar">
                <div class="sidebar-header">
                    <h2>ðŸ“¦ Inventario General</h2>
                    <p>Sistema de Captura</p>
                </div>

                <!-- Sync Status - Contador Ãšnico -->
                <div id="sync-status" class="sync-status sync-ok" onclick="SyncQueue.showPanel()" title="Click para ver detalles">
                    <span id="sync-status-text">âœ… Sincronizado</span>
                </div>

                <!-- Menu -->
                <div class="sidebar-section">
                    <button class="sidebar-btn sidebar-btn-primary" onclick="showResumen()">
                        ðŸ“Š Resumen
                    </button>
                    <button class="sidebar-btn sidebar-btn-secondary" onclick="showWorkTypePopup()" id="new-session-btn">
                        âž• Nuevo
                    </button>
                    <button class="sidebar-btn sidebar-btn-secondary" onclick="exportData()">
                        ðŸ“¥ Exportar
                    </button>
                </div>

                <!-- Global Summary by Status -->
                <div class="global-summary-section" id="global-summary-section">
                    <div class="global-summary-title">Resumen Global</div>
                    <div class="global-summary-grid">
                        <div class="global-summary-item ok">
                            <div class="global-summary-label">âœ… OK</div>
                            <div class="global-summary-count ok" id="global-summary-ok">0</div>
                        </div>
                        <div class="global-summary-item blocked">
                            <div class="global-summary-label">âš ï¸ Bloqueado</div>
                            <div class="global-summary-count blocked" id="global-summary-blocked">0</div>
                        </div>
                        <div class="global-summary-item nowms">
                            <div class="global-summary-label">âŒ No WMS</div>
                            <div class="global-summary-count nowms" id="global-summary-nowms">0</div>
                        </div>
                    </div>
                    <div class="global-summary-total">
                        <div class="global-summary-total-label">ðŸ“¦ Total Cajas</div>
                        <div class="global-summary-total-count" id="global-summary-total">0</div>
                    </div>
                </div>

                <!-- User Footer -->
                <div class="user-footer">
                    <div class="user-info">
                        <div class="user-avatar" id="user-avatar" onclick="changeUserAlias()" title="Cambiar nombre">
                            <span id="user-avatar-text">?</span>
                        </div>
                        <div class="user-details" onclick="changeUserAlias()" style="cursor: pointer;">
                            <div class="user-name" id="user-name-display">No conectado</div>
                            <div class="user-email" id="user-email-display">Inicia sesiÃ³n</div>
                        </div>
                    </div>
                    <div class="user-footer-actions">
                        <button class="btn btn-secondary btn-small" onclick="refreshInventory()">ðŸ”„ BD</button>
                        <button class="btn btn-secondary btn-small" onclick="toggleConnection()" id="sidebar-auth-btn">ðŸ”—</button>
                        <button class="btn btn-danger btn-small" onclick="handleLogout()">ðŸšª</button>
                    </div>
                    <div class="bd-info">
                        <div><span id="bd-count">0</span> cÃ³digos cargados</div>
                        <div id="bd-update-time">Sin actualizar</div>
                    </div>
                </div>
            </div>

            <!-- MAIN CONTENT -->
            <div class="main-content">
                <!-- GLOBAL TABS SYSTEM -->
                <div class="unified-tabs-container" id="global-tabs-container">
                    <button class="unified-tab-new" id="global-new-tab-btn" onclick="showWorkTypePopup()">
                        âž• Nuevo
                    </button>
                </div>

                <!-- WELCOME STATE - No active sessions -->
                <div id="welcome-state" class="welcome-state module-visible">
                    <div class="welcome-content">
                        <div class="welcome-icon">ðŸ“¦</div>
                        <h2 class="welcome-title">Â¡Bienvenido al Sistema de Captura de Inventario General 2026!</h2>
                        <p class="welcome-subtitle">No tienes sesiones activas</p>
                        <p class="welcome-text">Crea una nueva sesiÃ³n para comenzar a escanear y clasificar tu inventario.</p>
                        <button class="welcome-btn" onclick="showWorkTypePopup()">
                            âž• Crear Nueva SesiÃ³n
                        </button>
                    </div>
                </div>

                <!-- CLASSIC MODULE -->
                <div id="classic-module" class="module-hidden">
                    <!-- Cabecera Principal con UbicaciÃ³n y Contador -->
                    <div class="scan-header-bar">
                    <div class="origin-location-group">
                        <label>ðŸ“ Origen:</label>
                        <input type="text" class="origin-location-input" id="origin-location"
                               placeholder="A21-06-05-01" autocomplete="off"
                               title="UbicaciÃ³n fÃ­sica de origen"
                               onkeydown="if(event.key==='Enter'){event.preventDefault();document.getElementById('scan-input').focus();}">
                    </div>
                    <div class="global-counter">
                        <span class="global-counter-label">Total Cajas:</span>
                        <span class="global-counter-value" id="global-box-count">0</span>
                    </div>
                </div>

                <!-- Scan Section Compacta -->
                <div class="scan-section">
                    <input type="text" class="scan-input" id="scan-input" placeholder="ðŸ” Escanea o ingresa cÃ³digo..." autocomplete="off">

                    <!-- Result Box Compacto -->
                    <div class="result-box" id="result-box">
                        <div class="result-compact">
                            <div class="result-status">
                                <span class="icon" id="result-icon">ðŸ“¦</span>
                                <span id="result-title">Estado</span>
                            </div>
                            <div class="result-info" id="result-details"></div>
                        </div>
                    </div>

                    <!-- Code2 Container Compacto -->
                    <div class="code2-container" id="code2-container">
                        <div style="display: flex; gap: 8px; align-items: center;">
                            <span style="color: var(--error); font-weight: 600; font-size: 0.85em;">âš ï¸ No encontrado:</span>
                            <input type="text" class="scan-input" id="code2-input" placeholder="CÃ³digo 2..." autocomplete="off" style="flex: 1; font-size: 1em; padding: 8px;">
                            <button class="btn-insertado" onclick="forceInsert()" style="padding: 8px 14px; font-size: 0.85em;">
                                âš¡ INSERTADO
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Columns -->
                <div class="columns-container">
                    <!-- OK Column -->
                    <div class="column ok">
                        <div class="column-header">
                            <span class="column-title">âœ… OK</span>
                            <div style="display: flex; align-items: center; gap: 6px;">
                                <span class="counter-badge ok" id="ok-verified-badge" style="display: none;">âœ“ <span id="ok-verified-count">0</span></span>
                                <span class="counter-badge pending" id="ok-pending-badge" style="display: none;">â—‹ <span id="ok-pending-count">0</span></span>
                                <span class="column-count" id="ok-count">0</span>
                                <button class="box-action-btn" onclick="showPalletDetailModal('ok')" title="Ver detalle" style="opacity: 0.8; font-size: 1em; border: 1px solid rgba(0,0,0,0.2); background: rgba(0,0,0,0.03);">[ ]</button>
                            </div>
                        </div>
                        <div class="column-pallet-info">
                            <div>Pallet: <span class="column-pallet-code" id="ok-pallet">-</span></div>
                            <input type="text" class="column-location-input" id="location-ok" placeholder="ðŸ“ UbicaciÃ³n destino...">
                            <button class="column-send-btn" onclick="sendPallet('ok')" id="send-ok-btn" disabled>
                                ðŸ“¤ Enviar Tarima OK
                            </button>
                        </div>
                        <div class="column-list" id="ok-list">
                            <div class="empty-state">
                                <div class="empty-icon">ðŸ“­</div>
                                <div>Sin cajas</div>
                            </div>
                        </div>
                    </div>

                    <!-- Blocked Column -->
                    <div class="column blocked">
                        <div class="column-header">
                            <span class="column-title">âš ï¸ Bloqueado</span>
                            <div style="display: flex; align-items: center; gap: 6px;">
                                <span class="column-count" id="blocked-count">0</span>
                                <button class="box-action-btn" onclick="showPalletDetailModal('blocked')" title="Ver detalle" style="opacity: 0.8; font-size: 1em; border: 1px solid rgba(0,0,0,0.2); background: rgba(0,0,0,0.03);">[ ]</button>
                            </div>
                        </div>
                        <div class="column-pallet-info">
                            <div>Pallet: <span class="column-pallet-code" id="blocked-pallet">-</span></div>
                            <input type="text" class="column-location-input" id="location-blocked" placeholder="ðŸ“ UbicaciÃ³n destino...">
                            <button class="column-send-btn" onclick="sendPallet('blocked')" id="send-blocked-btn" disabled>
                                ðŸ“¤ Enviar Tarima Bloqueado
                            </button>
                        </div>
                        <div class="column-list" id="blocked-list">
                            <div class="empty-state">
                                <div class="empty-icon">ðŸ“­</div>
                                <div>Sin cajas</div>
                            </div>
                        </div>
                    </div>

                    <!-- No WMS Column -->
                    <div class="column nowms">
                        <div class="column-header">
                            <span class="column-title">âŒ No WMS</span>
                            <div style="display: flex; align-items: center; gap: 6px;">
                                <span class="column-count" id="nowms-count">0</span>
                                <button class="box-action-btn" onclick="showPalletDetailModal('nowms')" title="Ver detalle" style="opacity: 0.8; font-size: 1em; border: 1px solid rgba(0,0,0,0.2); background: rgba(0,0,0,0.03);">[ ]</button>
                            </div>
                        </div>
                        <div class="column-pallet-info">
                            <div>Pallet: <span class="column-pallet-code" id="nowms-pallet">-</span></div>
                            <input type="text" class="column-location-input" id="location-nowms" placeholder="ðŸ“ UbicaciÃ³n destino...">
                            <button class="column-send-btn" onclick="sendPallet('nowms')" id="send-nowms-btn" disabled>
                                ðŸ“¤ Enviar Tarima No WMS
                            </button>
                        </div>
                        <div class="column-list" id="nowms-list">
                            <div class="empty-state">
                                <div class="empty-icon">ðŸ“­</div>
                                <div>Sin cajas</div>
                            </div>
                        </div>
                    </div>
                </div>
                </div><!-- End Classic Module -->

                <!-- UNIFIED MODULE -->
                <div id="unified-module" class="unified-module-container module-hidden">
                    <!-- Cabecera Principal con UbicaciÃ³n -->
                    <div class="scan-header-bar">
                        <div class="origin-location-group">
                            <label>ðŸ“ Origen:</label>
                            <input type="text" class="origin-location-input" id="unified-origin-location"
                                   placeholder="A21-06-05-01" autocomplete="off"
                                   title="UbicaciÃ³n fÃ­sica de origen"
                                   onkeydown="if(event.key==='Enter'){event.preventDefault();document.getElementById('unified-scan-input').focus();}">
                        </div>
                        <div class="global-counter">
                            <span class="global-counter-label">Total Cajas:</span>
                            <span class="global-counter-value" id="unified-global-box-count">0</span>
                        </div>
                    </div>

                    <!-- Scan Section -->
                    <div class="scan-section">
                        <input type="text" class="scan-input" id="unified-scan-input" placeholder="ðŸ” Escanea o ingresa cÃ³digo..." autocomplete="off">

                        <!-- Result Box -->
                        <div class="result-box" id="unified-result-box">
                            <div class="result-compact">
                                <div class="result-status">
                                    <span class="icon" id="unified-result-icon">ðŸ“¦</span>
                                    <span id="unified-result-title">Estado</span>
                                </div>
                                <div class="result-info" id="unified-result-details"></div>
                            </div>
                        </div>

                        <!-- Code2 Container -->
                        <div class="code2-container" id="unified-code2-container">
                            <div style="display: flex; gap: 8px; align-items: center;">
                                <span style="color: var(--error); font-weight: 600; font-size: 0.85em;">âš ï¸ No encontrado:</span>
                                <input type="text" class="scan-input" id="unified-code2-input" placeholder="CÃ³digo 2..." autocomplete="off" style="flex: 1; font-size: 1em; padding: 8px;">
                                <button class="btn-insertado" onclick="unifiedForceInsert()" style="padding: 8px 14px; font-size: 0.85em;">
                                    âš¡ INSERTADO
                                </button>
                            </div>
                        </div>
                    </div>

                    <!-- Unified Pallet Content -->
                    <div class="unified-content" id="unified-active-content">
                            <div class="unified-pallet">
                                <div class="unified-pallet-header">
                                    <div class="unified-pallet-info">
                                        <span class="unified-pallet-id" id="unified-pallet-id">-</span>
                                        <div class="unified-status-badges">
                                            <span class="unified-status-badge ok">âœ… <span id="unified-ok-count">0</span></span>
                                            <span class="unified-status-badge blocked">âš ï¸ <span id="unified-blocked-count">0</span></span>
                                            <span class="unified-status-badge nowms">âŒ <span id="unified-nowms-count">0</span></span>
                                        </div>
                                    </div>
                                    <div class="unified-pallet-actions">
                                        <input type="text" class="unified-location-input" id="unified-location"
                                               placeholder="ðŸ“ UbicaciÃ³n destino...">
                                        <label class="cancelados-toggle" id="cancelados-toggle-label">
                                            <input type="checkbox" id="unified-cancelados-check" onchange="UnifiedModule.toggleCancelados(this.checked)">
                                            <span class="cancelados-slider"></span>
                                            <span class="cancelados-text">Cancelados</span>
                                        </label>
                                        <button class="unified-send-btn" id="unified-send-btn" onclick="UnifiedModule.sendPallet()" disabled>
                                            ðŸ“¤ Enviar Datos
                                        </button>
                                    </div>
                                </div>

                        <div class="unified-list-container">
                            <div class="unified-list" id="unified-box-list">
                                <div class="empty-state">
                                    <div class="empty-icon">ðŸ“­</div>
                                    <div>Sin cajas escaneadas</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                </div><!-- End Unified Module -->
            </div>
        </div>
    </div>

    <!-- RESUMEN POPUP -->
    <div class="popup-overlay" id="resumen-popup">
        <div class="popup-content">
            <div class="popup-header">
                <span>ðŸ“Š Resumen de SesiÃ³n</span>
                <button class="popup-close" onclick="closeResumen()">Ã—</button>
            </div>

            <div class="resumen-stats">
                <div class="resumen-stat ok">
                    <div class="resumen-stat-number" id="resumen-ok">0</div>
                    <div class="resumen-stat-label">OK</div>
                </div>
                <div class="resumen-stat blocked">
                    <div class="resumen-stat-number" id="resumen-blocked">0</div>
                    <div class="resumen-stat-label">Bloqueado</div>
                </div>
                <div class="resumen-stat nowms">
                    <div class="resumen-stat-number" id="resumen-nowms">0</div>
                    <div class="resumen-stat-label">No WMS</div>
                </div>
                <div class="resumen-stat pending">
                    <div class="resumen-stat-number" id="resumen-pending">0</div>
                    <div class="resumen-stat-label">Pendientes Sync</div>
                </div>
            </div>

            <div class="resumen-actions">
                <button class="btn btn-primary btn-small" onclick="refreshInventory(); closeResumen();">ðŸ”„ Recargar BD</button>
                <button class="btn btn-success btn-small" onclick="SyncManager.sync(); updateResumen();">ðŸ”„ Sincronizar</button>
                <button class="btn btn-secondary btn-small" onclick="exportData();">ðŸ“¥ Exportar</button>
                <button class="btn btn-warning btn-small" onclick="openAjusteModule();">ðŸ”§ Ajuste</button>
            </div>

            <h3 style="margin-bottom: 10px; font-size: 1em;">ðŸ“‹ Historial Reciente</h3>
            <div class="resumen-table-container">
                <table class="resumen-table">
                    <thead>
                        <tr>
                            <th>Fecha</th>
                            <th>CÃ³digo</th>
                            <th>CÃ³digo 2</th>
                            <th>Estatus</th>
                            <th>Destino</th>
                            <th>Origen</th>
                            <th>Pallet</th>
                        </tr>
                    </thead>
                    <tbody id="resumen-table-body">
                    </tbody>
                </table>
            </div>
        </div>
    </div>

    <!-- AJUSTE MODULE POPUP -->
    <div class="popup-overlay" id="ajuste-popup">
        <div class="popup-content" style="max-width: 900px; width: 90vw;">
            <div class="popup-header">
                <span>ðŸ”§ Ajuste de Pallets</span>
                <button class="popup-close" onclick="closeAjusteModule()">Ã—</button>
            </div>

            <div class="ajuste-search-container">
                <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #333;">
                    ðŸ” Buscar por UbicaciÃ³n:
                </label>
                <input 
                    type="text" 
                    id="ajuste-location-search" 
                    class="ajuste-search-input" 
                    placeholder="Ingresa la ubicaciÃ³n (ej: A1-12-03-02)"
                    onkeyup="if(event.key === 'Enter') searchPalletsByLocation()"
                />
                <button class="btn btn-primary btn-full" onclick="searchPalletsByLocation()">
                    ðŸ” Buscar Pallets
                </button>
            </div>

            <div id="ajuste-results-container">
                <div class="ajuste-empty-state">
                    ðŸ“¦ Ingresa una ubicaciÃ³n para buscar pallets
                </div>
            </div>
        </div>
    </div>

    <script src="shared/js/wms-utils.js"></script>
    <script>
        // Verify that wms-utils.js loaded correctly
        if (typeof validateLocation === 'undefined') {
            console.error('CRITICAL: validateLocation not found after loading wms-utils.js');
            console.error('Available on window:', Object.keys(window).filter(k => k.includes('validate')));
        } else {
            console.log('âœ… wms-utils.js loaded successfully');
        }
    </script>
    <script src="https://apis.google.com/js/api.js"></script>
    <script src="https://accounts.google.com/gsi/client"></script>
    <script>
        // ==================== CONFIGURATION ====================
        const CONFIG = {
            CLIENT_ID: '1013623813866-70ovrtt690fbka3a97h4fenpp54hm7j8.apps.googleusercontent.com',
            SCOPES: 'https://www.googleapis.com/auth/spreadsheets https://www.googleapis.com/auth/userinfo.profile',
            SPREADSHEET_WRITE: '1CIeBFP59ri6LUEbYg-530Nurd5iKcu1YedtUfeTBWQ8',
            SHEET_NAME: 'BD',  // Nombre de la hoja donde se escriben los datos
            // WMS Inventory - Lectura de cÃ³digos, stock, ubicaciones (17 columnas)
            INVENTORY_CSV_URL: 'https://docs.google.com/spreadsheets/d/e/2PACX-1vS-HG8HPf-94Ki5Leo5iEF5pyqsiD9CVk-mcl-F8BAw34kT0s3nzNn532YTYDCtkG76NbauiVx0Ffmd/pub?output=csv',
            // FILE2 - Segundo nivel de bÃºsqueda (columna I)
            FILE2_CSV_URL: 'https://docs.google.com/spreadsheets/d/e/2PACX-1vSdSDQ8ktYA3YAsWMUokYd_S6_rANUz8XdfEAjsV-v0eAlfiYZctHuj3hP4m3wOghf4rnT_YvuA4BPA/pub?output=csv',
            // PRIORIDAD - ValidaciÃ³n de cÃ³digos prioritarios
            PRIORITY_CSV_URL: 'https://docs.google.com/spreadsheets/d/e/2PACX-1vQiV79-kXoNlWqzL5LlDQfD2frq1EZ7mnRtwfpACEpA3nQymdLHth0e1XdidhYfavy3YuamZkv2tX-W/pub?gid=956570526&single=true&output=csv'
        };

        // ==================== STATE ====================
        let STATE = {
            inventory: new Map(),
            inventoryLastUpdate: null,
            pallets: {
                ok: { id: generatePalletId('OK'), boxes: [], location: '' },
                blocked: { id: generatePalletId('BLK'), boxes: [], location: '' },
                nowms: { id: generatePalletId('NW'), boxes: [], location: '' }
            },
            pendingCode1: null,
            history: []
        };

        // Adjustment mode flag
        window.ADJUSTMENT_MODE = { active: false };

        // Helper function to get local date and time
        function getLocalDateTime() {
            const now = new Date();
            const year = now.getFullYear();
            const month = String(now.getMonth() + 1).padStart(2, '0');
            const day = String(now.getDate()).padStart(2, '0');
            const dateStr = `${year}-${month}-${day}`;
            const hours = String(now.getHours()).padStart(2, '0');
            const minutes = String(now.getMinutes()).padStart(2, '0');
            const seconds = String(now.getSeconds()).padStart(2, '0');
            const timeStr = `${hours}:${minutes}:${seconds}`;
            return { dateStr, timeStr };
        }

        // Helper function to get full datetime string (YYYY-MM-DD HH:mm:ss)
        function getFullDateTime() {
            const { dateStr, timeStr } = getLocalDateTime();
            return `${dateStr} ${timeStr}`;
        }

        // FILE2 - Segundo nivel de bÃºsqueda
        let BD_CODES_FILE2 = new Set();
        let FILE2_LAST_UPDATE = null;

        // PRIORIDAD - ValidaciÃ³n de cÃ³digos prioritarios
        let PRIORITY_CODES = new Set();
        let PRIORITY_LAST_UPDATE = null;

        // IndexedDB para FILE2 (cache grande)
        let FILE2_DB = null;
        const DB_NAME = 'ScanAppDB';
        const DB_VERSION = 2;  // Incrementado para agregar store de prioridad
        const STORE_NAME_FILE2 = 'file2_codes';
        const STORE_NAME_PRIORITY = 'priority_codes';

        // Inicializar IndexedDB
        async function initIndexedDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);

                request.onerror = () => {
                    console.error('âŒ Error abriendo IndexedDB:', request.error);
                    reject(request.error);
                };

                request.onsuccess = () => {
                    FILE2_DB = request.result;
                    console.log('âœ… IndexedDB inicializado correctamente');
                    resolve(FILE2_DB);
                };

                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    // Crear store para FILE2
                    if (!db.objectStoreNames.contains(STORE_NAME_FILE2)) {
                        db.createObjectStore(STORE_NAME_FILE2);
                        console.log('ðŸ“¦ Object store creado:', STORE_NAME_FILE2);
                    }
                    // Crear store para PRIORIDAD
                    if (!db.objectStoreNames.contains(STORE_NAME_PRIORITY)) {
                        db.createObjectStore(STORE_NAME_PRIORITY);
                        console.log('ðŸ”´ Object store creado:', STORE_NAME_PRIORITY);
                    }
                };
            });
        }

        // Guardar FILE2 en IndexedDB
        async function saveFile2ToIndexedDB(codesArray, timestamp) {
            try {
                if (!FILE2_DB) {
                    await initIndexedDB();
                }

                return new Promise((resolve, reject) => {
                    const transaction = FILE2_DB.transaction([STORE_NAME_FILE2], 'readwrite');
                    const store = transaction.objectStore(STORE_NAME_FILE2);

                    // Guardar los cÃ³digos
                    const codesRequest = store.put(codesArray, 'codes');
                    const timestampRequest = store.put(timestamp, 'timestamp');

                    transaction.oncomplete = () => {
                        console.log(`âœ… FILE2 guardado en IndexedDB: ${codesArray.length} cÃ³digos`);
                        resolve();
                    };

                    transaction.onerror = () => {
                        console.error('âŒ Error guardando en IndexedDB:', transaction.error);
                        reject(transaction.error);
                    };
                });
            } catch (error) {
                console.error('âŒ Error en saveFile2ToIndexedDB:', error);
                throw error;
            }
        }

        // Cargar FILE2 desde IndexedDB
        async function loadFile2FromIndexedDB() {
            try {
                if (!FILE2_DB) {
                    await initIndexedDB();
                }

                return new Promise((resolve, reject) => {
                    const transaction = FILE2_DB.transaction([STORE_NAME_FILE2], 'readonly');
                    const store = transaction.objectStore(STORE_NAME_FILE2);

                    const codesRequest = store.get('codes');
                    const timestampRequest = store.get('timestamp');

                    let codes = null;
                    let timestamp = null;

                    codesRequest.onsuccess = () => {
                        codes = codesRequest.result;
                    };

                    timestampRequest.onsuccess = () => {
                        timestamp = timestampRequest.result;
                    };

                    transaction.oncomplete = () => {
                        if (codes && timestamp) {
                            console.log(`âœ… FILE2 cargado desde IndexedDB: ${codes.length} cÃ³digos`);
                            resolve({ codes, timestamp });
                        } else {
                            console.log('â„¹ï¸ No hay datos de FILE2 en IndexedDB');
                            resolve(null);
                        }
                    };

                    transaction.onerror = () => {
                        console.error('âŒ Error leyendo IndexedDB:', transaction.error);
                        reject(transaction.error);
                    };
                });
            } catch (error) {
                console.error('âŒ Error en loadFile2FromIndexedDB:', error);
                return null;
            }
        }

        // Guardar PRIORIDAD en IndexedDB
        async function savePriorityToIndexedDB(codesArray, timestamp) {
            try {
                if (!FILE2_DB) {
                    await initIndexedDB();
                }

                return new Promise((resolve, reject) => {
                    const transaction = FILE2_DB.transaction([STORE_NAME_PRIORITY], 'readwrite');
                    const store = transaction.objectStore(STORE_NAME_PRIORITY);

                    store.put(codesArray, 'codes');
                    store.put(timestamp, 'timestamp');

                    transaction.oncomplete = () => {
                        console.log(`ðŸ”´ PRIORIDAD guardada en IndexedDB: ${codesArray.length} cÃ³digos`);
                        resolve();
                    };

                    transaction.onerror = () => {
                        console.error('âŒ Error guardando PRIORIDAD en IndexedDB:', transaction.error);
                        reject(transaction.error);
                    };
                });
            } catch (error) {
                console.error('âŒ Error en savePriorityToIndexedDB:', error);
                throw error;
            }
        }

        // Cargar PRIORIDAD desde IndexedDB
        async function loadPriorityFromIndexedDB() {
            try {
                if (!FILE2_DB) {
                    await initIndexedDB();
                }

                return new Promise((resolve, reject) => {
                    const transaction = FILE2_DB.transaction([STORE_NAME_PRIORITY], 'readonly');
                    const store = transaction.objectStore(STORE_NAME_PRIORITY);

                    const codesRequest = store.get('codes');
                    const timestampRequest = store.get('timestamp');

                    let codes = null;
                    let timestamp = null;

                    codesRequest.onsuccess = () => {
                        codes = codesRequest.result;
                    };

                    timestampRequest.onsuccess = () => {
                        timestamp = timestampRequest.result;
                    };

                    transaction.oncomplete = () => {
                        if (codes && timestamp) {
                            console.log(`ðŸ”´ PRIORIDAD cargada desde IndexedDB: ${codes.length} cÃ³digos`);
                            resolve({ codes, timestamp });
                        } else {
                            console.log('â„¹ï¸ No hay datos de PRIORIDAD en IndexedDB');
                            resolve(null);
                        }
                    };

                    transaction.onerror = () => {
                        console.error('âŒ Error leyendo PRIORIDAD desde IndexedDB:', transaction.error);
                        reject(transaction.error);
                    };
                });
            } catch (error) {
                console.error('âŒ Error en loadPriorityFromIndexedDB:', error);
                return null;
            }
        }

        let CURRENT_USER = '';
        let USER_EMAIL = '';
        let USER_GOOGLE_NAME = '';
        let IS_ONLINE = navigator.onLine;
        let PENDING_SYNC = [];
        let SYNCED_PALLETS = new Set(); // Registro de pallets ya sincronizados para evitar duplicados
        let TOKEN_CLIENT = null;
        let CURRENT_SESSION_ID = null; // ID de sesiÃ³n actual para persistencia
        let audioCtx = null;
        let isSubmitting = false; // Flag para bloqueo hard del botÃ³n de envÃ­o

        // ==================== UUID GENERATOR ====================
        function generateUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                const r = Math.random() * 16 | 0;
                const v = c === 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }

        function generateTimestamp() {
            return Date.now(); // Unix timestamp en milisegundos
        }

        // ==================== CONCURRENCY CONTROL MODULE ====================
        /**
         * MÃ“DULO DE CONTROL DE CONCURRENCIA
         *
         * PROBLEMA RESUELTO:
         * - Antes: Uso de append() causaba que mÃºltiples usuarios escribieran en la misma fila
         * - Datos se insertaban desde la primera fila o se sobrescribÃ­an entre sÃ­
         * - Sin validaciÃ³n de integridad post-escritura
         *
         * SOLUCIÃ“N IMPLEMENTADA:
         * 1. Read-Verify-Write Pattern:
         *    - Lee Ãºltima fila ANTES de escribir
         *    - Escribe en rango especÃ­fico usando update() (no append)
         *    - Verifica datos escritos POST-escritura
         *
         * 2. Control de Concurrencia:
         *    - Lock local por cliente (isWriting flag)
         *    - Reintentos automÃ¡ticos (3 intentos con backoff exponencial)
         *    - ValidaciÃ³n de integridad de datos crÃ­ticos
         *
         * 3. Manejo de Errores:
         *    - Errores de concurrencia mantienen datos en cola
         *    - Reintentos automÃ¡ticos en prÃ³xima sincronizaciÃ³n
         *    - Logs detallados para debugging
         *
         * GARANTÃAS:
         * âœ… Los datos SIEMPRE se escriben en la Ãºltima fila vacÃ­a
         * âœ… No hay sobrescritura entre usuarios concurrentes
         * âœ… VerificaciÃ³n de integridad post-escritura
         * âœ… Sin pÃ©rdida de datos (sistema de cola robusto)
         */
        const ConcurrencyControl = {
            maxRetries: 3,
            retryDelay: 1000,
            isWriting: false, // Flag para prevenir escrituras simultÃ¡neas desde el mismo cliente

            /**
             * Obtiene la Ãºltima fila ocupada en la hoja
             * @returns {number} NÃºmero de la Ãºltima fila con datos
             */
            async getLastRow(spreadsheetId, sheetName) {
                try {
                    const response = await gapi.client.sheets.spreadsheets.values.get({
                        spreadsheetId: spreadsheetId,
                        range: `${sheetName}!A:A`,
                        majorDimension: 'ROWS'
                    });

                    const rows = response.result.values || [];
                    const lastRow = rows.length;
                    console.log(`ðŸ“Š [CONCURRENCY] Ãšltima fila detectada: ${lastRow}`);
                    return lastRow;
                } catch (error) {
                    console.error('âŒ [CONCURRENCY] Error obteniendo Ãºltima fila:', error);
                    throw error;
                }
            },

            /**
             * Escribe datos con verificaciÃ³n de concurrencia usando Read-Verify-Write
             * Usa batchUpdate con rango explÃ­cito en lugar de append
             * @param {string} spreadsheetId - ID de la hoja de cÃ¡lculo
             * @param {string} sheetName - Nombre de la hoja
             * @param {Array} values - Array de filas a escribir
             * @returns {Object} Resultado de la escritura con verificaciÃ³n
             */
            async writeWithConcurrencyControl(spreadsheetId, sheetName, values) {
                // BLOQUEO LOCAL: Prevenir escrituras simultÃ¡neas desde el mismo cliente
                if (this.isWriting) {
                    throw new Error('Ya hay una operaciÃ³n de escritura en progreso en este cliente');
                }

                this.isWriting = true;
                let attempt = 0;
                let currentRetryDelay = this.retryDelay;

                try {
                    while (attempt < this.maxRetries) {
                        try {
                            attempt++;
                            console.log(`ðŸ”„ [CONCURRENCY] Intento ${attempt}/${this.maxRetries}`);

                            // PASO 1: Leer Ãºltima fila ANTES de escribir (CRITICAL)
                            const lastRow = await this.getLastRow(spreadsheetId, sheetName);
                            const targetRow = lastRow + 1; // Nueva fila inicial para escritura

                            console.log(`ðŸ“ [CONCURRENCY] Target fila inicial: ${targetRow} (${values.length} registros)`);

                            // PASO 2: Escribir en rango especÃ­fico (NO usar append para control exacto)
                            const endRow = targetRow + values.length - 1;
                            const range = `${sheetName}!A${targetRow}:J${endRow}`;

                            console.log(`âœï¸ [CONCURRENCY] Escribiendo en rango: ${range}`);

                            const writeResponse = await gapi.client.sheets.spreadsheets.values.update({
                                spreadsheetId: spreadsheetId,
                                range: range,
                                valueInputOption: 'USER_ENTERED',
                                resource: { values: values }
                            });

                            // PASO 3: Verificar que la escritura fue exitosa
                            if (writeResponse.status !== 200) {
                                throw new Error(`Status ${writeResponse.status} en escritura`);
                            }

                            console.log(`ðŸ“ [CONCURRENCY] Escritura completada, iniciando verificaciÃ³n...`);

                            // PASO 4: VERIFICACIÃ“N POST-ESCRITURA (CRITICAL!)
                            // Leer las filas que acabamos de escribir para confirmar integridad
                            const verifyResponse = await gapi.client.sheets.spreadsheets.values.get({
                                spreadsheetId: spreadsheetId,
                                range: range
                            });

                            const writtenRows = verifyResponse.result.values || [];

                            // Verificar cantidad de registros
                            if (writtenRows.length !== values.length) {
                                console.error(`âŒ [CONCURRENCY] VerificaciÃ³n fallida: esperados ${values.length}, encontrados ${writtenRows.length}`);
                                throw new Error(`VerificaciÃ³n fallida: esperados ${values.length} registros, encontrados ${writtenRows.length}`);
                            }

                            // Verificar integridad de datos crÃ­ticos (scan1, pallet, location)
                            let integrityOk = true;
                            for (let i = 0; i < values.length; i++) {
                                const original = values[i];
                                const written = writtenRows[i];

                                // Columnas crÃ­ticas: D(scan1)[3], I(pallet)[8], F(location)[5]
                                if (original[3] !== written[3] || // scan1
                                    original[8] !== written[8] || // pallet
                                    original[5] !== written[5]) { // location
                                    console.error(`âŒ [CONCURRENCY] Integridad comprometida en fila ${targetRow + i}:`, {
                                        original: { scan1: original[3], pallet: original[8], location: original[5] },
                                        written: { scan1: written[3], pallet: written[8], location: written[5] }
                                    });
                                    integrityOk = false;
                                    break;
                                }
                            }

                            if (!integrityOk) {
                                throw new Error('Integridad de datos comprometida despuÃ©s de escritura');
                            }

                            // PASO 5: ValidaciÃ³n adicional - Verificar que no hay duplicados inesperados
                            const palletId = values[0][8]; // Pallet ID del primer registro
                            const validationOk = await this.validateNoConflicts(
                                spreadsheetId,
                                sheetName,
                                targetRow,
                                values.length,
                                palletId
                            );

                            if (!validationOk) {
                                console.warn('âš ï¸ [CONCURRENCY] Advertencia: Posible duplicaciÃ³n detectada');
                                // No lanzar error, solo advertir (puede ser falso positivo)
                            }

                            console.log(`âœ… [CONCURRENCY] Escritura verificada exitosamente:`);
                            console.log(`   - Registros: ${values.length}`);
                            console.log(`   - Filas: ${targetRow}-${endRow}`);
                            console.log(`   - Rango: ${writeResponse.result.updatedRange}`);

                            return {
                                success: true,
                                startRow: targetRow,
                                endRow: endRow,
                                updatedRows: values.length,
                                range: writeResponse.result.updatedRange,
                                status: 200
                            };

                        } catch (error) {
                            console.error(`âŒ [CONCURRENCY] Error en intento ${attempt}:`, error);

                            // Determinar si es un error recuperable
                            const isRecoverable = error.message.includes('VerificaciÃ³n fallida') ||
                                                error.message.includes('Integridad comprometida') ||
                                                error.status === 429 || // Rate limit
                                                error.status === 503;   // Service unavailable

                            if (isRecoverable && attempt < this.maxRetries) {
                                console.log(`â³ [CONCURRENCY] Error recuperable, reintentando en ${currentRetryDelay}ms...`);
                                await this.sleep(currentRetryDelay);
                                // Aumentar delay exponencialmente (backoff)
                                currentRetryDelay = Math.floor(currentRetryDelay * 1.5);
                            } else {
                                // Error no recuperable o mÃ¡ximo de reintentos alcanzado
                                throw error;
                            }
                        }
                    }

                    // Si llega aquÃ­, agotÃ³ los reintentos
                    throw new Error(`Conflicto de concurrencia: No se pudo escribir despuÃ©s de ${this.maxRetries} intentos`);

                } finally {
                    // SIEMPRE liberar el lock, incluso si hay error
                    this.isWriting = false;
                }
            },

            /**
             * ValidaciÃ³n adicional: Verificar que no hay duplicados en el rango de escritura
             * @param {string} spreadsheetId - ID de la hoja
             * @param {string} sheetName - Nombre de la hoja
             * @param {number} targetRow - Fila inicial de escritura
             * @param {number} recordsCount - Cantidad de registros escritos
             * @param {string} palletId - ID del pallet para detectar duplicados
             * @returns {boolean} true si no hay conflictos detectados
             */
            async validateNoConflicts(spreadsheetId, sheetName, targetRow, recordsCount, palletId) {
                try {
                    // Leer un rango amplio alrededor de la zona de escritura
                    const bufferRows = 10;
                    const startRow = Math.max(2, targetRow - bufferRows); // Evitar fila 1 (encabezados)
                    const endRow = targetRow + recordsCount + bufferRows;

                    const response = await gapi.client.sheets.spreadsheets.values.get({
                        spreadsheetId: spreadsheetId,
                        range: `${sheetName}!A${startRow}:J${endRow}`
                    });

                    const rows = response.result.values || [];

                    // Verificar si hay registros con el mismo pallet ID
                    const conflicts = rows.filter(row => row[8] === palletId); // Columna I[8] = pallet

                    if (conflicts.length > recordsCount) {
                        console.warn(`âš ï¸ [CONCURRENCY] Posible duplicaciÃ³n: ${conflicts.length} registros con pallet ${palletId} (esperados: ${recordsCount})`);
                        return false;
                    }

                    console.log(`âœ… [CONCURRENCY] ValidaciÃ³n de duplicados OK: ${conflicts.length} registros encontrados`);
                    return true;
                } catch (error) {
                    console.error('âŒ [CONCURRENCY] Error en validaciÃ³n de conflictos:', error);
                    // No fallar la operaciÃ³n por error de validaciÃ³n
                    return true;
                }
            },

            /**
             * Helper: Espera un tiempo determinado
             */
            sleep(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }
        };

        // ==================== PERSISTENCE MANAGER (OFFLINE-FIRST) ====================
        const PersistenceManager = {
            DB_NAME: 'PalletDecoderDB',
            DB_VERSION: 2,
            db: null,

            STORES: {
                DRAFT_BOXES: 'draft_boxes',
                PENDING_SYNC: 'pending_sync_v2',
                SYNCED_RECORDS: 'synced_records',
                SESSIONS: 'sessions'
            },

            async init() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(this.DB_NAME, this.DB_VERSION);

                    request.onerror = () => {
                        console.error('âŒ [PERSISTENCE] Error abriendo IndexedDB:', request.error);
                        reject(request.error);
                    };

                    request.onsuccess = (e) => {
                        this.db = e.target.result;
                        console.log('âœ… [PERSISTENCE] IndexedDB inicializada');
                        resolve(this.db);
                    };

                    request.onupgradeneeded = (e) => {
                        const db = e.target.result;
                        console.log('ðŸ”§ [PERSISTENCE] Creando/actualizando stores...');

                        // Store para cajas en borrador (tarima activa)
                        if (!db.objectStoreNames.contains(this.STORES.DRAFT_BOXES)) {
                            const draftStore = db.createObjectStore(this.STORES.DRAFT_BOXES, { keyPath: '_id' });
                            draftStore.createIndex('_category', '_category', { unique: false });
                            draftStore.createIndex('_palletId', '_palletId', { unique: false });
                            draftStore.createIndex('_sessionId', '_sessionId', { unique: false });
                            draftStore.createIndex('_timestamp', '_timestamp', { unique: false });
                        }

                        // Store para registros pendientes de sincronizaciÃ³n
                        if (!db.objectStoreNames.contains(this.STORES.PENDING_SYNC)) {
                            const pendingStore = db.createObjectStore(this.STORES.PENDING_SYNC, { keyPath: '_id' });
                            pendingStore.createIndex('_status', '_status', { unique: false });
                            pendingStore.createIndex('_timestamp', '_timestamp', { unique: false });
                        }

                        // Store para registros sincronizados (auditorÃ­a)
                        if (!db.objectStoreNames.contains(this.STORES.SYNCED_RECORDS)) {
                            const syncedStore = db.createObjectStore(this.STORES.SYNCED_RECORDS, { keyPath: '_id' });
                            syncedStore.createIndex('_syncedAt', '_syncedAt', { unique: false });
                        }

                        // Store para sesiones
                        if (!db.objectStoreNames.contains(this.STORES.SESSIONS)) {
                            const sessionStore = db.createObjectStore(this.STORES.SESSIONS, { keyPath: 'id' });
                            sessionStore.createIndex('createdAt', 'createdAt', { unique: false });
                        }
                    };
                });
            },

            // Guardar caja en borrador (PERSISTENCIA INSTANTÃNEA)
            async saveDraftBox(boxRecord) {
                if (!this.db) await this.init();
                
                return new Promise((resolve, reject) => {
                    try {
                        const tx = this.db.transaction([this.STORES.DRAFT_BOXES], 'readwrite');
                        const store = tx.objectStore(this.STORES.DRAFT_BOXES);
                        const request = store.put(boxRecord);

                        request.onsuccess = () => {
                            console.log(`ðŸ’¾ [PERSISTENCE] Caja guardada: ${boxRecord._id}`);
                            resolve(boxRecord);
                        };

                        request.onerror = () => {
                            console.error('âŒ [PERSISTENCE] Error guardando caja:', request.error);
                            reject(request.error);
                        };
                    } catch (error) {
                        console.error('âŒ [PERSISTENCE] Error en saveDraftBox:', error);
                        reject(error);
                    }
                });
            },

            // Obtener todas las cajas en borrador
            async getDraftBoxes(sessionId = null) {
                if (!this.db) await this.init();
                
                return new Promise((resolve, reject) => {
                    try {
                        const tx = this.db.transaction([this.STORES.DRAFT_BOXES], 'readonly');
                        const store = tx.objectStore(this.STORES.DRAFT_BOXES);
                        const request = sessionId 
                            ? store.index('_sessionId').getAll(sessionId)
                            : store.getAll();

                        request.onsuccess = () => {
                            resolve(request.result || []);
                        };

                        request.onerror = () => {
                            console.error('âŒ [PERSISTENCE] Error obteniendo draft boxes:', request.error);
                            reject(request.error);
                        };
                    } catch (error) {
                        console.error('âŒ [PERSISTENCE] Error en getDraftBoxes:', error);
                        resolve([]);
                    }
                });
            },

            // Eliminar caja de borrador
            async deleteDraftBox(boxId) {
                if (!this.db) await this.init();
                
                return new Promise((resolve, reject) => {
                    try {
                        const tx = this.db.transaction([this.STORES.DRAFT_BOXES], 'readwrite');
                        const store = tx.objectStore(this.STORES.DRAFT_BOXES);
                        const request = store.delete(boxId);

                        request.onsuccess = () => {
                            console.log(`ðŸ—‘ï¸ [PERSISTENCE] Caja eliminada: ${boxId}`);
                            resolve();
                        };

                        request.onerror = () => {
                            console.error('âŒ [PERSISTENCE] Error eliminando caja:', request.error);
                            reject(request.error);
                        };
                    } catch (error) {
                        console.error('âŒ [PERSISTENCE] Error en deleteDraftBox:', error);
                        reject(error);
                    }
                });
            },

            // Limpiar todas las cajas de un pallet
            async clearDraftBoxesByPallet(palletId) {
                if (!this.db) await this.init();
                
                return new Promise(async (resolve, reject) => {
                    try {
                        const boxes = await this.getDraftBoxes();
                        const boxesToDelete = boxes.filter(box => box._palletId === palletId);
                        
                        const tx = this.db.transaction([this.STORES.DRAFT_BOXES], 'readwrite');
                        const store = tx.objectStore(this.STORES.DRAFT_BOXES);
                        
                        boxesToDelete.forEach(box => {
                            store.delete(box._id);
                        });

                        tx.oncomplete = () => {
                            console.log(`ðŸ—‘ï¸ [PERSISTENCE] ${boxesToDelete.length} cajas eliminadas del pallet ${palletId}`);
                            resolve(boxesToDelete.length);
                        };

                        tx.onerror = () => {
                            console.error('âŒ [PERSISTENCE] Error limpiando draft boxes:', tx.error);
                            reject(tx.error);
                        };
                    } catch (error) {
                        console.error('âŒ [PERSISTENCE] Error en clearDraftBoxesByPallet:', error);
                        reject(error);
                    }
                });
            },

            // Mover cajas de draft a pending (TRANSICIÃ“N ATÃ“MICA)
            async moveToPending(records) {
                if (!this.db) await this.init();
                
                return new Promise(async (resolve, reject) => {
                    try {
                        const tx = this.db.transaction([this.STORES.DRAFT_BOXES, this.STORES.PENDING_SYNC], 'readwrite');
                        const draftStore = tx.objectStore(this.STORES.DRAFT_BOXES);
                        const pendingStore = tx.objectStore(this.STORES.PENDING_SYNC);

                        // Mover cada registro
                        records.forEach(record => {
                            // Eliminar de draft
                            draftStore.delete(record._id);
                            // Agregar a pending
                            pendingStore.put(record);
                        });

                        tx.oncomplete = () => {
                            console.log(`âœ… [PERSISTENCE] ${records.length} registros movidos a PENDING`);
                            resolve();
                        };

                        tx.onerror = () => {
                            console.error('âŒ [PERSISTENCE] Error moviendo a pending:', tx.error);
                            reject(tx.error);
                        };
                    } catch (error) {
                        console.error('âŒ [PERSISTENCE] Error en moveToPending:', error);
                        reject(error);
                    }
                });
            },

            // Obtener registros pendientes
            async getPendingSync() {
                if (!this.db) await this.init();
                
                return new Promise((resolve, reject) => {
                    try {
                        const tx = this.db.transaction([this.STORES.PENDING_SYNC], 'readonly');
                        const store = tx.objectStore(this.STORES.PENDING_SYNC);
                        const request = store.getAll();

                        request.onsuccess = () => {
                            resolve(request.result || []);
                        };

                        request.onerror = () => {
                            console.error('âŒ [PERSISTENCE] Error obteniendo pending sync:', request.error);
                            reject(request.error);
                        };
                    } catch (error) {
                        console.error('âŒ [PERSISTENCE] Error en getPendingSync:', error);
                        resolve([]);
                    }
                });
            },

            // Contar registros pendientes
            async getPendingCount() {
                if (!this.db) await this.init();
                
                return new Promise((resolve, reject) => {
                    try {
                        const tx = this.db.transaction([this.STORES.PENDING_SYNC], 'readonly');
                        const store = tx.objectStore(this.STORES.PENDING_SYNC);
                        const request = store.count();

                        request.onsuccess = () => {
                            resolve(request.result || 0);
                        };

                        request.onerror = () => {
                            console.error('âŒ [PERSISTENCE] Error contando pending:', request.error);
                            resolve(0);
                        };
                    } catch (error) {
                        console.error('âŒ [PERSISTENCE] Error en getPendingCount:', error);
                        resolve(0);
                    }
                });
            },

            // Marcar registros como sincronizados
            async markAsSynced(records) {
                if (!this.db) await this.init();
                
                return new Promise(async (resolve, reject) => {
                    try {
                        const tx = this.db.transaction([this.STORES.PENDING_SYNC, this.STORES.SYNCED_RECORDS], 'readwrite');
                        const pendingStore = tx.objectStore(this.STORES.PENDING_SYNC);
                        const syncedStore = tx.objectStore(this.STORES.SYNCED_RECORDS);

                        records.forEach(record => {
                            // Actualizar estado
                            record._status = 'synced';
                            record._syncedAt = generateTimestamp();
                            
                            // Eliminar de pending
                            pendingStore.delete(record._id);
                            
                            // Agregar a synced (auditorÃ­a)
                            syncedStore.put(record);
                        });

                        tx.oncomplete = () => {
                            console.log(`âœ… [PERSISTENCE] ${records.length} registros marcados como SYNCED`);
                            resolve();
                        };

                        tx.onerror = () => {
                            console.error('âŒ [PERSISTENCE] Error marcando como synced:', tx.error);
                            reject(tx.error);
                        };
                    } catch (error) {
                        console.error('âŒ [PERSISTENCE] Error en markAsSynced:', error);
                        reject(error);
                    }
                });
            },

            // Guardar/actualizar sesiÃ³n activa
            async saveSession(sessionData) {
                if (!this.db) await this.init();
                
                return new Promise((resolve, reject) => {
                    try {
                        const tx = this.db.transaction([this.STORES.SESSIONS], 'readwrite');
                        const store = tx.objectStore(this.STORES.SESSIONS);
                        const request = store.put(sessionData);

                        request.onsuccess = () => {
                            console.log(`ðŸ’¾ [PERSISTENCE] SesiÃ³n guardada: ${sessionData.id}`);
                            resolve();
                        };

                        request.onerror = () => {
                            console.error('âŒ [PERSISTENCE] Error guardando sesiÃ³n:', request.error);
                            reject(request.error);
                        };
                    } catch (error) {
                        console.error('âŒ [PERSISTENCE] Error en saveSession:', error);
                        reject(error);
                    }
                });
            },

            // Obtener sesiÃ³n activa
            async getActiveSession() {
                if (!this.db) await this.init();
                
                return new Promise((resolve, reject) => {
                    try {
                        const tx = this.db.transaction([this.STORES.SESSIONS], 'readonly');
                        const store = tx.objectStore(this.STORES.SESSIONS);
                        const request = store.getAll();

                        request.onsuccess = () => {
                            const sessions = request.result || [];
                            // Retornar la sesiÃ³n mÃ¡s reciente que no estÃ© cerrada
                            const activeSession = sessions
                                .filter(s => !s.closed)
                                .sort((a, b) => b.createdAt - a.createdAt)[0];
                            resolve(activeSession || null);
                        };

                        request.onerror = () => {
                            console.error('âŒ [PERSISTENCE] Error obteniendo sesiÃ³n activa:', request.error);
                            resolve(null);
                        };
                    } catch (error) {
                        console.error('âŒ [PERSISTENCE] Error en getActiveSession:', error);
                        resolve(null);
                    }
                });
            }
        };

        // ==================== DEDUPLICATION MANAGER ====================
        const DeduplicationManager = {
            // Flag para evitar race conditions durante envÃ­o
            _sendingInProgress: false,
            _currentSendingPalletId: null,

            // Genera una clave Ãºnica para un registro basada en pallet + scan1 + location
            generateRecordKey(record) {
                return `${record.pallet}|${record.scan1}|${record.location}`;
            },

            // Genera una clave Ãºnica para un pallet completo
            generatePalletKey(palletId, location) {
                return `${palletId}|${location}`;
            },

            // Verifica si un pallet ya fue sincronizado (excluyendo el pallet actualmente en envÃ­o)
            isPalletSynced(palletId, location) {
                // Si este pallet estÃ¡ actualmente siendo enviado, NO es duplicado
                if (this._sendingInProgress && this._currentSendingPalletId === palletId) {
                    console.log(`ðŸŸ¢ [DEDUP] Pallet ${palletId} estÃ¡ en proceso de envÃ­o - NO es duplicado`);
                    return false;
                }
                const key = this.generatePalletKey(palletId, location);
                return SYNCED_PALLETS.has(key);
            },

            // Marca el inicio de un envÃ­o para evitar falsos positivos
            startSending(palletId) {
                this._sendingInProgress = true;
                this._currentSendingPalletId = palletId;
                console.log(`ðŸŸ¡ [DEDUP] Iniciando envÃ­o de pallet: ${palletId}`);
            },

            // Marca el fin de un envÃ­o
            endSending() {
                this._sendingInProgress = false;
                this._currentSendingPalletId = null;
                console.log(`ðŸŸ¢ [DEDUP] EnvÃ­o finalizado`);
            },

            // Marca un pallet como sincronizado
            markPalletAsSynced(palletId, location) {
                const key = this.generatePalletKey(palletId, location);
                SYNCED_PALLETS.add(key);
                this.saveSyncedPallets();
                console.log(`âœ… [DEDUP] Pallet marcado como sincronizado: ${key}`);
            },

            // Verifica si un registro ya existe en PENDING_SYNC
            isRecordInPendingSync(record) {
                const key = this.generateRecordKey(record);
                return PENDING_SYNC.some(r => this.generateRecordKey(r) === key);
            },

            // Filtra registros duplicados antes de agregar a PENDING_SYNC
            // IMPORTANTE: Excluye registros del pallet actualmente en envÃ­o para evitar falsos positivos
            filterDuplicateRecords(records, currentPalletId = null) {
                const uniqueRecords = [];
                const seenKeys = new Set();

                for (const record of records) {
                    const key = this.generateRecordKey(record);
                    
                    // Si el registro pertenece al pallet actual en envÃ­o, verificar solo duplicados internos
                    const isCurrentPallet = currentPalletId && record.pallet === currentPalletId;
                    
                    // Verificar si ya estÃ¡ en los nuevos registros (duplicado interno)
                    if (seenKeys.has(key)) {
                        console.warn(`âš ï¸ [DEDUP] Registro duplicado interno filtrado: ${key}`);
                        continue;
                    }
                    
                    // Si es del pallet actual, solo verificar duplicados internos, NO contra PENDING_SYNC
                    // Esto evita falsos positivos cuando se reintenta un envÃ­o fallido
                    if (isCurrentPallet) {
                        uniqueRecords.push(record);
                        seenKeys.add(key);
                    } else {
                        // Para otros pallets, verificar tambiÃ©n contra PENDING_SYNC
                        if (!this.isRecordInPendingSync(record)) {
                            uniqueRecords.push(record);
                            seenKeys.add(key);
                        } else {
                            console.warn(`âš ï¸ [DEDUP] Registro duplicado en PENDING_SYNC filtrado: ${key}`);
                        }
                    }
                }

                return uniqueRecords;
            },

            // Verifica contra la BD de escritura si el pallet ya existe
            // IMPORTANTE: Solo retorna true si hay una coincidencia EXACTA del ID completo
            async checkPalletExistsInDatabase(palletId) {
                if (!gapi?.client?.getToken()) {
                    console.warn('âš ï¸ [DEDUP] No hay token de Google, no se puede verificar BD');
                    return false;
                }

                if (!palletId || palletId.trim() === '') {
                    console.warn('âš ï¸ [DEDUP] ID de pallet vacÃ­o, no se puede verificar');
                    return false;
                }

                const cleanPalletId = palletId.toString().trim().toUpperCase();
                console.log(`ðŸ” [DEDUP] Verificando pallet en BD: "${cleanPalletId}"`);

                try {
                    const response = await gapi.client.sheets.spreadsheets.values.get({
                        spreadsheetId: CONFIG.SPREADSHEET_WRITE,
                        range: `${CONFIG.SHEET_NAME}!I:I` // Columna I = pallet
                    });

                    const rows = response.result.values || [];
                    // Limpiar y normalizar todos los IDs de la BD para comparaciÃ³n exacta
                    const existingPallets = rows
                        .flat()
                        .filter(p => p && p.toString().trim() !== '')
                        .map(p => p.toString().trim().toUpperCase());
                    
                    // ComparaciÃ³n EXACTA (no parcial)
                    const exists = existingPallets.some(p => p === cleanPalletId);
                    
                    if (exists) {
                        console.log(`ðŸ” [DEDUP] Pallet "${cleanPalletId}" ENCONTRADO en BD (${existingPallets.length} pallets totales)`);
                    } else {
                        console.log(`âœ… [DEDUP] Pallet "${cleanPalletId}" NO existe en BD - OK para enviar`);
                    }
                    
                    return exists;
                } catch (error) {
                    console.error('âŒ [DEDUP] Error verificando pallet en BD:', error);
                    // En caso de error, permitir el envÃ­o (no bloquear por error de red)
                    return false;
                }
            },

            // Guarda el registro de pallets sincronizados en localStorage
            saveSyncedPallets() {
                try {
                    localStorage.setItem('pd_synced_pallets', JSON.stringify([...SYNCED_PALLETS]));
                } catch (e) {
                    console.error('âŒ [DEDUP] Error guardando pallets sincronizados:', e);
                }
            },

            // Carga el registro de pallets sincronizados desde localStorage
            loadSyncedPallets() {
                try {
                    const saved = localStorage.getItem('pd_synced_pallets');
                    if (saved) {
                        const parsed = JSON.parse(saved);
                        // Validar que sea un array antes de crear el Set
                        if (Array.isArray(parsed)) {
                            SYNCED_PALLETS = new Set(parsed);
                            console.log(`ðŸ“‚ [DEDUP] Cargados ${SYNCED_PALLETS.size} pallets sincronizados`);
                        } else {
                            console.warn('âš ï¸ [DEDUP] Datos corruptos en localStorage, limpiando...');
                            SYNCED_PALLETS = new Set();
                            this.saveSyncedPallets();
                        }
                    }
                } catch (e) {
                    console.error('âŒ [DEDUP] Error cargando pallets sincronizados, limpiando:', e);
                    SYNCED_PALLETS = new Set();
                    localStorage.removeItem('pd_synced_pallets');
                }
            },

            // Limpia registros antiguos (mÃ¡s de 24 horas para evitar acumulaciÃ³n)
            cleanOldRecords() {
                const now = Date.now();
                const oneDayAgo = now - (24 * 60 * 60 * 1000); // 24 horas en lugar de 7 dÃ­as
                let cleaned = 0;

                for (const key of SYNCED_PALLETS) {
                    const palletId = key.split('|')[0];
                    // Extraer timestamp del pallet ID (formato: PREFIX-TIMESTAMP-RANDOM)
                    const parts = palletId.split('-');
                    if (parts.length >= 2) {
                        const timestampBase36 = parts[1];
                        const timestamp = parseInt(timestampBase36, 36);
                        // Si el timestamp es invÃ¡lido o muy antiguo, limpiar
                        if (isNaN(timestamp) || timestamp < oneDayAgo) {
                            SYNCED_PALLETS.delete(key);
                            cleaned++;
                        }
                    } else {
                        // Formato invÃ¡lido, eliminar
                        SYNCED_PALLETS.delete(key);
                        cleaned++;
                    }
                }

                if (cleaned > 0) {
                    console.log(`ðŸ§¹ [DEDUP] Limpiados ${cleaned} registros antiguos/invÃ¡lidos`);
                    this.saveSyncedPallets();
                }
            },

            // FunciÃ³n para limpiar completamente el cache de pallets sincronizados
            // Ãštil para resolver problemas de falsos positivos
            clearSyncedPallets() {
                SYNCED_PALLETS.clear();
                localStorage.removeItem('pd_synced_pallets');
                console.log('ðŸ§¹ [DEDUP] Cache de pallets sincronizados limpiado completamente');
            }
        };

        // ==================== PROCESSED BOXES MANAGER (Lazy Load) ====================
        // Almacena cajas ya procesadas del servidor para validaciÃ³n dual
        let PROCESSED_BOXES_MAP = new Map(); // Map<scan1, {scan2, pallet, date, time, user, location}>
        let PROCESSED_BOXES_LAST_UPDATE = null;
        const PROCESSED_BOXES_DB_NAME = 'ProcessedBoxesDB';
        const PROCESSED_BOXES_STORE = 'boxes';
        let PROCESSED_BOXES_DB = null;

        const ProcessedBoxesManager = {
            SYNC_INTERVAL: 60 * 60 * 1000, // 1 hora
            intervalId: null,
            isLoading: false,

            // FunciÃ³n de limpieza profunda de cÃ³digos - elimina caracteres invisibles y normaliza
            cleanCode(code) {
                if (code === null || code === undefined) return '';
                return code
                    .toString()
                    .replace(/[\u200B\uFEFF\u00A0\u2000-\u200F\u2028\u2029]/g, '') // Caracteres invisibles
                    .replace(/[\r\n\t]/g, '') // Saltos de lÃ­nea y tabs
                    .trim()
                    .toUpperCase();
            },

            async init() {
                await this.openDatabase();
                await this.loadFromIndexedDB();
                this.startAutoSync();
                console.log(`ðŸ“¦ [PROCESSED] Inicializado con ${PROCESSED_BOXES_MAP.size} cajas procesadas`);
            },

            async openDatabase() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(PROCESSED_BOXES_DB_NAME, 1);
                    
                    request.onerror = () => {
                        console.error('âŒ [PROCESSED] Error abriendo IndexedDB');
                        reject(request.error);
                    };
                    
                    request.onsuccess = () => {
                        PROCESSED_BOXES_DB = request.result;
                        resolve();
                    };
                    
                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        if (!db.objectStoreNames.contains(PROCESSED_BOXES_STORE)) {
                            db.createObjectStore(PROCESSED_BOXES_STORE, { keyPath: 'key' });
                        }
                    };
                });
            },

            async loadFromIndexedDB() {
                if (!PROCESSED_BOXES_DB) return;
                
                try {
                    // Cargar datos de cajas procesadas
                    const dataResult = await new Promise((resolve, reject) => {
                        const transaction = PROCESSED_BOXES_DB.transaction([PROCESSED_BOXES_STORE], 'readonly');
                        const store = transaction.objectStore(PROCESSED_BOXES_STORE);
                        const request = store.get('processedBoxes');
                        request.onsuccess = () => resolve(request.result);
                        request.onerror = () => reject(request.error);
                    });
                    
                    if (dataResult?.value) {
                        const entries = dataResult.value;
                        // IMPORTANTE: Reconstruir Map con claves normalizadas para evitar falsos positivos
                        PROCESSED_BOXES_MAP = new Map();
                        for (const [key, value] of entries) {
                            const cleanKey = this.cleanCode(key);
                            if (cleanKey && cleanKey.length > 0) {
                                PROCESSED_BOXES_MAP.set(cleanKey, value);
                            }
                        }
                        console.log(`ðŸ“‚ [PROCESSED] Cargadas ${PROCESSED_BOXES_MAP.size} cajas desde IndexedDB (normalizadas)`);
                    }
                    
                    // Cargar timestamp de Ãºltima actualizaciÃ³n
                    const timestampResult = await new Promise((resolve, reject) => {
                        const transaction = PROCESSED_BOXES_DB.transaction([PROCESSED_BOXES_STORE], 'readonly');
                        const store = transaction.objectStore(PROCESSED_BOXES_STORE);
                        const request = store.get('lastUpdate');
                        request.onsuccess = () => resolve(request.result);
                        request.onerror = () => reject(request.error);
                    });
                    
                    if (timestampResult?.value) {
                        PROCESSED_BOXES_LAST_UPDATE = new Date(timestampResult.value);
                    }
                } catch (error) {
                    console.error('âŒ [PROCESSED] Error cargando desde IndexedDB:', error);
                }
            },

            async saveToIndexedDB() {
                if (!PROCESSED_BOXES_DB) return;
                
                try {
                    const transaction = PROCESSED_BOXES_DB.transaction([PROCESSED_BOXES_STORE], 'readwrite');
                    const store = transaction.objectStore(PROCESSED_BOXES_STORE);
                    
                    const entries = [...PROCESSED_BOXES_MAP.entries()];
                    store.put({ key: 'processedBoxes', value: entries });
                    store.put({ key: 'lastUpdate', value: Date.now() });
                    
                    await new Promise((resolve, reject) => {
                        transaction.oncomplete = resolve;
                        transaction.onerror = reject;
                    });
                    
                    console.log(`ðŸ’¾ [PROCESSED] Guardadas ${PROCESSED_BOXES_MAP.size} cajas en IndexedDB`);
                } catch (error) {
                    console.error('âŒ [PROCESSED] Error guardando en IndexedDB:', error);
                }
            },

            startAutoSync() {
                if (this.intervalId) clearInterval(this.intervalId);
                this.intervalId = setInterval(() => {
                    if (IS_ONLINE && gapi?.client?.getToken()) {
                        this.syncFromServer(false);
                    }
                }, this.SYNC_INTERVAL);
            },

            async syncFromServer(showNotification = true) {
                if (this.isLoading) {
                    console.log('â³ [PROCESSED] SincronizaciÃ³n ya en progreso...');
                    return;
                }

                if (!IS_ONLINE || !gapi?.client?.getToken()) {
                    console.log('âš ï¸ [PROCESSED] Sin conexiÃ³n o sin token');
                    return;
                }

                this.isLoading = true;
                if (showNotification) {
                    window.showNotification?.('ðŸ”„ Sincronizando cajas procesadas...', 'info');
                }

                try {
                    // Descargar columnas ligeras: D(scan1), E(scan2), I(pallet), A(fecha), B(hora), C(usuario), F(location)
                    const response = await gapi.client.sheets.spreadsheets.values.get({
                        spreadsheetId: CONFIG.SPREADSHEET_WRITE,
                        range: `${CONFIG.SHEET_NAME}!A:I`
                    });

                    const rows = response.result.values || [];
                    PROCESSED_BOXES_MAP.clear();

                    // Saltar header (fila 0)
                    for (let i = 1; i < rows.length; i++) {
                        const row = rows[i];
                        if (!row || !row[3]) continue; // Columna D (scan1) es requerida

                        // Usar cleanCode para normalizaciÃ³n consistente
                        const scan1 = this.cleanCode(row[3]);
                        const scan2 = this.cleanCode(row[4]);
                        const pallet = row[8]?.toString().trim() || '';
                        const date = row[0]?.toString().trim() || '';
                        const time = row[1]?.toString().trim() || '';
                        const user = row[2]?.toString().trim() || '';
                        const location = row[5]?.toString().trim() || '';

                        if (scan1 && scan1.length > 0) {
                            const boxData = {
                                scan1,
                                scan2,
                                pallet,
                                date,
                                time,
                                user,
                                location
                            };

                            PROCESSED_BOXES_MAP.set(scan1, boxData);

                            // TambiÃ©n indexar por scan2 si existe y es diferente
                            if (scan2 && scan2.length > 0 && scan2 !== scan1) {
                                PROCESSED_BOXES_MAP.set(scan2, boxData);
                            }
                        }
                    }

                    PROCESSED_BOXES_LAST_UPDATE = new Date();
                    await this.saveToIndexedDB();

                    console.log(`âœ… [PROCESSED] Sincronizadas ${PROCESSED_BOXES_MAP.size} cajas del servidor`);
                    if (showNotification) {
                        window.showNotification?.(`âœ… ${PROCESSED_BOXES_MAP.size} cajas procesadas cargadas`, 'success');
                    }
                } catch (error) {
                    console.error('âŒ [PROCESSED] Error sincronizando desde servidor:', error);
                    if (showNotification) {
                        window.showNotification?.('âŒ Error sincronizando cajas procesadas', 'error');
                    }
                } finally {
                    this.isLoading = false;
                }
            },

            // Busca una caja en los registros procesados del servidor
            findInProcessed(code) {
                const normalizedCode = this.cleanCode(code);
                if (!normalizedCode || normalizedCode.length === 0) return null;
                
                const result = PROCESSED_BOXES_MAP.get(normalizedCode);
                if (result) {
                    console.log(`ðŸ” [PROCESSED] Encontrado en cache: ${normalizedCode}`);
                }
                return result || null;
            },

            // Busca una caja en PENDING_SYNC (registros locales no sincronizados)
            findInPendingSync(code) {
                const normalizedCode = this.cleanCode(code);
                if (!normalizedCode || normalizedCode.length === 0) return null;

                for (const record of PENDING_SYNC) {
                    const scan1 = this.cleanCode(record.scan1);
                    const scan2 = this.cleanCode(record.scan2);
                    
                    if ((scan1 && scan1 === normalizedCode) || (scan2 && scan2 === normalizedCode)) {
                        console.log(`ðŸ” [PENDING] Encontrado en pendientes: ${normalizedCode}`);
                        return {
                            scan1: record.scan1,
                            scan2: record.scan2,
                            pallet: record.pallet,
                            date: record.date,
                            time: record.time,
                            user: record.user,
                            location: record.location,
                            source: 'pending_sync'
                        };
                    }
                }
                return null;
            },

            // ValidaciÃ³n dual: busca en PENDING_SYNC y en cajas procesadas del servidor
            findProcessedBox(code) {
                // Paso A: Buscar en registros locales pendientes de sincronizar
                const pendingResult = this.findInPendingSync(code);
                if (pendingResult) {
                    return { ...pendingResult, source: 'local_pending' };
                }

                // Paso B: Buscar en listado descargado del servidor
                const serverResult = this.findInProcessed(code);
                if (serverResult) {
                    return { ...serverResult, source: 'server' };
                }

                return null;
            },

            getLastUpdateText() {
                if (!PROCESSED_BOXES_LAST_UPDATE) return 'Nunca';
                return PROCESSED_BOXES_LAST_UPDATE.toLocaleString();
            },

            getCount() {
                return PROCESSED_BOXES_MAP.size;
            },

            // Agregar registros reciÃ©n sincronizados al cache local para validaciÃ³n inmediata
            async addSyncedRecords(records) {
                if (!records || records.length === 0) return;

                let added = 0;
                for (const record of records) {
                    // Usar cleanCode para normalizaciÃ³n consistente
                    const scan1 = this.cleanCode(record.scan1);
                    const scan2 = this.cleanCode(record.scan2);

                    if (scan1 && scan1.length > 0) {
                        const boxData = {
                            scan1,
                            scan2,
                            pallet: record.pallet || '',
                            date: record.date || '',
                            time: record.time || '',
                            user: record.user || '',
                            location: record.location || ''
                        };

                        // Indexar por scan1
                        PROCESSED_BOXES_MAP.set(scan1, boxData);
                        added++;

                        // TambiÃ©n indexar por scan2 si existe y es diferente
                        if (scan2 && scan2.length > 0 && scan2 !== scan1) {
                            PROCESSED_BOXES_MAP.set(scan2, boxData);
                            added++;
                        }
                    }
                }

                // Guardar en IndexedDB para persistencia
                await this.saveToIndexedDB();
                console.log(`ðŸ“¦ [PROCESSED] Agregados ${added} registros sincronizados al cache local`);
            }
        };

        // ==================== SYNC MANAGER ====================
        const SyncManager = {
            inProgress: false,
            retryCount: 0,
            intervalId: null,
            heartbeatId: null,
            AUTO_SYNC_INTERVAL: 45000, // 45 segundos (mÃ¡s agresivo)
            HEARTBEAT_INTERVAL: 10000, // 10 segundos para actualizar contador

            init() {
                this.load();
                DeduplicationManager.loadSyncedPallets();
                DeduplicationManager.cleanOldRecords();
                this.startAutoSync();
                this.startHeartbeat(); // FASE 5: Iniciar heartbeat
                this.setupExitProtection();
                this.updateUI(PENDING_SYNC.length === 0);
            },

            setupExitProtection() {
                window.addEventListener('beforeunload', (e) => {
                    const hasUnsavedData = PENDING_SYNC.length > 0 ||
                        STATE.pallets.ok.boxes.length > 0 ||
                        STATE.pallets.blocked.boxes.length > 0 ||
                        STATE.pallets.nowms.boxes.length > 0;

                    if (hasUnsavedData) {
                        e.preventDefault();
                        e.returnValue = 'Â¡Tienes datos sin sincronizar! Â¿Seguro que quieres salir?';
                        return e.returnValue;
                    }
                });
            },

            // FASE 5: Heartbeat de SincronizaciÃ³n AutomÃ¡tica
            startHeartbeat() {
                if (this.heartbeatId) clearInterval(this.heartbeatId);
                
                this.heartbeatId = setInterval(async () => {
                    try {
                        // 1. Actualizar contador de pendientes en UI
                        await updateConnectionIndicator();
                        
                        // 2. Sincronizar PENDING_SYNC desde IndexedDB (fuente de verdad)
                        const pendingFromDB = await PersistenceManager.getPendingSync();
                        if (pendingFromDB.length !== PENDING_SYNC.length) {
                            console.log(`ðŸ”„ [HEARTBEAT] Sincronizando PENDING_SYNC: ${PENDING_SYNC.length} â†’ ${pendingFromDB.length}`);
                            PENDING_SYNC = pendingFromDB;
                        }
                        
                        // 3. Intentar sincronizaciÃ³n automÃ¡tica si hay pendientes
                        if (IS_ONLINE && gapi?.client?.getToken() && PENDING_SYNC.length > 0 && !this.inProgress) {
                            console.log(`ðŸ”„ [HEARTBEAT] SincronizaciÃ³n automÃ¡tica: ${PENDING_SYNC.length} registros pendientes`);
                            this.sync(false);
                        }
                    } catch (error) {
                        console.warn('âš ï¸ [HEARTBEAT] Error en heartbeat:', error);
                    }
                }, this.HEARTBEAT_INTERVAL);
                
                console.log(`âœ… [HEARTBEAT] Iniciado - Intervalo: ${this.HEARTBEAT_INTERVAL}ms`);
            },

            startAutoSync() {
                if (this.intervalId) clearInterval(this.intervalId);
                this.intervalId = setInterval(() => {
                    if (IS_ONLINE && gapi?.client?.getToken() && PENDING_SYNC.length > 0) {
                        this.sync(false);
                    }
                }, this.AUTO_SYNC_INTERVAL);
                console.log(`âœ… [AUTO-SYNC] Iniciado - Intervalo: ${this.AUTO_SYNC_INTERVAL}ms`);
            },

            async sync(showMessages = true) {
                if (this.inProgress) {
                    if (showMessages) showNotification('â³ SincronizaciÃ³n en progreso...', 'info');
                    return { success: false };
                }

                if (!IS_ONLINE) {
                    if (showMessages) showNotification('âš ï¸ Sin conexiÃ³n a internet', 'warning');
                    return { success: false };
                }

                if (!gapi?.client?.getToken()) {
                    if (showMessages) showNotification('âš ï¸ No conectado a Google', 'warning');
                    return { success: false };
                }

                if (PENDING_SYNC.length === 0) {
                    this.updateUI(true);
                    if (showMessages) showNotification('âœ… Todo sincronizado', 'success');
                    return { success: true, synced: 0 };
                }

                return await this._doSync(showMessages, false);
            },

            async syncSlow(showMessages = true) {
                if (this.inProgress) {
                    if (showMessages) showNotification('â³ SincronizaciÃ³n en progreso...', 'info');
                    return { success: false };
                }

                if (!IS_ONLINE) {
                    if (showMessages) showNotification('âš ï¸ Sin conexiÃ³n a internet', 'warning');
                    return { success: false };
                }

                if (!gapi?.client?.getToken()) {
                    if (showMessages) showNotification('âš ï¸ No conectado a Google', 'warning');
                    return { success: false };
                }

                if (PENDING_SYNC.length === 0) {
                    this.updateUI(true);
                    if (showMessages) showNotification('âœ… Todo sincronizado', 'success');
                    return { success: true, synced: 0 };
                }

                return await this._doSync(showMessages, true);
            },

            async _doSync(showMessages, slowMode = false) {
                this.inProgress = true;
                updateConnectionIndicator(true);

                const syncMessage = slowMode ? 'â±ï¸ SincronizaciÃ³n lenta...' : 'ðŸ”„ Sincronizando...';
                if (showMessages) showNotification(syncMessage, 'info');

                try {
                    // DEDUPLICACIÃ“N: Filtrar registros que ya fueron sincronizados
                    const recordsToSync = [];
                    const palletLocationPairs = new Set();
                    
                    for (const record of PENDING_SYNC) {
                        const palletKey = DeduplicationManager.generatePalletKey(record.pallet, record.location);
                        
                        // Verificar si este pallet+location ya fue sincronizado
                        if (!SYNCED_PALLETS.has(palletKey)) {
                            recordsToSync.push(record);
                            palletLocationPairs.add(palletKey);
                        } else {
                            console.warn(`âš ï¸ [DEDUP-SYNC] Registro omitido (pallet ya sincronizado): ${palletKey}`);
                        }
                    }

                    // Si todos los registros ya fueron sincronizados, limpiar y salir
                    if (recordsToSync.length === 0) {
                        console.log('âœ… [DEDUP-SYNC] Todos los registros pendientes ya fueron sincronizados previamente');
                        PENDING_SYNC = [];
                        this.save();
                        this.updateUI(true);
                        if (showMessages) showNotification('âœ… Todo sincronizado (sin duplicados)', 'success');
                        return { success: true, synced: 0 };
                    }

                    // Columnas: A-J (incluye UbicaciÃ³n FÃ­sica de Origen en columna J)
                    const values = recordsToSync.map(r => [
                        r.date, r.time, r.user, r.scan1, r.scan2,
                        r.location, r.status, r.note, r.pallet, r.originLocation || ''
                    ]);

                    console.log(`ðŸ“¤ Intentando sincronizar con CONTROL DE CONCURRENCIA (${slowMode ? 'MODO LENTO' : 'MODO NORMAL'}):`);
                    console.log('  - SpreadsheetId:', CONFIG.SPREADSHEET_WRITE);
                    console.log('  - Hoja:', CONFIG.SHEET_NAME);
                    console.log('  - Registros:', values.length);
                    console.log('  - Primer registro:', values[0]);

                    let response;
                    if (slowMode) {
                        // ========== MODO LENTO: SINCRONIZACIÃ“N REGISTRO POR REGISTRO ==========
                        console.log('â±ï¸ [SLOW-SYNC] Iniciando sincronizaciÃ³n lenta con delays entre registros...');
                        let synced = 0;
                        const failed = [];

                        for (let i = 0; i < values.length; i++) {
                            try {
                                if (showMessages && i % 5 === 0) {
                                    showNotification(`â±ï¸ Procesando registro ${i + 1} de ${values.length}...`, 'info');
                                }

                                const singleResponse = await ConcurrencyControl.writeWithConcurrencyControl(
                                    CONFIG.SPREADSHEET_WRITE,
                                    CONFIG.SHEET_NAME,
                                    [values[i]]
                                );

                                if (singleResponse && singleResponse.success) {
                                    synced++;
                                    // Marcar este registro especÃ­fico como sincronizado
                                    await PersistenceManager.markAsSynced([recordsToSync[i]]);
                                    const palletKey = DeduplicationManager.generatePalletKey(
                                        recordsToSync[i].pallet,
                                        recordsToSync[i].location
                                    );
                                    SYNCED_PALLETS.add(palletKey);
                                } else {
                                    failed.push(recordsToSync[i]);
                                }

                                // Delay de 2 segundos entre registros en modo lento
                                if (i < values.length - 1) {
                                    await new Promise(resolve => setTimeout(resolve, 2000));
                                }
                            } catch (err) {
                                console.error(`âŒ [SLOW-SYNC] Error en registro ${i + 1}:`, err);
                                failed.push(recordsToSync[i]);
                            }
                        }

                        DeduplicationManager.saveSyncedPallets();
                        ProcessedBoxesManager.addSyncedRecords(recordsToSync.filter((_, i) => !failed.includes(recordsToSync[i])));

                        PENDING_SYNC = await PersistenceManager.getPendingSync();
                        this.updateUI(failed.length === 0);

                        if (showMessages) {
                            if (failed.length === 0) {
                                showNotification(`âœ… ${synced} registros sincronizados (modo lento)`, 'success');
                            } else {
                                showNotification(`âš ï¸ ${synced} OK, ${failed.length} con error`, 'warning');
                            }
                        }

                        return { success: failed.length === 0, synced, failed: failed.length };
                    } else {
                        // ========== MODO NORMAL: USAR CONTROL DE CONCURRENCIA EN LOTE ==========
                        response = await ConcurrencyControl.writeWithConcurrencyControl(
                            CONFIG.SPREADSHEET_WRITE,
                            CONFIG.SHEET_NAME,
                            values
                        );
                    }

                    // HANDSHAKE: Validar respuesta con control de concurrencia
                    if (!response || !response.success || response.status !== 200) {
                        throw new Error(`Escritura con control de concurrencia fallÃ³ - Status: ${response?.status || 'desconocido'}`);
                    }

                    const updatedRows = response.updatedRows;
                    const updatedRange = response.range;

                    if (!updatedRows || updatedRows !== recordsToSync.length) {
                        throw new Error(`Handshake fallido: Se enviaron ${recordsToSync.length} registros pero se confirmaron ${updatedRows || 0}`);
                    }

                    console.log('âœ… HANDSHAKE CONFIRMADO CON CONCURRENCIA:');
                    console.log('  - Status:', response.status);
                    console.log('  - Registros enviados:', recordsToSync.length);
                    console.log('  - Registros confirmados:', updatedRows);
                    console.log('  - Filas escritas:', `${response.startRow}-${response.endRow}`);
                    console.log('  - Rango actualizado:', updatedRange);

                    const synced = recordsToSync.length;
                    
                    // SOLO si handshake exitoso: Marcar registros como sincronizados en IndexedDB
                    try {
                        await PersistenceManager.markAsSynced(recordsToSync);
                        console.log(`âœ… [PERSISTENCE] ${synced} registros marcados como SYNCED en IndexedDB`);
                    } catch (error) {
                        console.error('âŒ [PERSISTENCE] Error marcando como synced:', error);
                    }
                    
                    // Marcar pallets como sincronizados
                    for (const palletKey of palletLocationPairs) {
                        SYNCED_PALLETS.add(palletKey);
                    }
                    DeduplicationManager.saveSyncedPallets();
                    console.log(`âœ… [DEDUP-SYNC] Marcados ${palletLocationPairs.size} pallets como sincronizados`);
                    
                    // VALIDACIÃ“N DUAL: Agregar registros sincronizados al cache
                    ProcessedBoxesManager.addSyncedRecords(recordsToSync);
                    
                    // SOLO si handshake exitoso: Actualizar PENDING_SYNC desde IndexedDB
                    PENDING_SYNC = await PersistenceManager.getPendingSync();
                    console.log(`ðŸ“Š [PERSISTENCE] ${PENDING_SYNC.length} registros pendientes restantes`);
                    
                    this.updateUI(true);

                    if (showMessages) showNotification(`âœ… ${synced} registros sincronizados y confirmados`, 'success');
                    return { success: true, synced, confirmed: true };
                } catch (e) {
                    console.error('âŒ Error completo de sincronizaciÃ³n:', e);
                    console.error('  - Mensaje:', e.message);
                    console.error('  - Result:', e.result);
                    console.error('  - Status:', e.status);

                    // ========== NUEVO: MANEJO ESPECIAL PARA ERRORES DE CONCURRENCIA ==========
                    // Si es un error de concurrencia, mantener en PENDING_SYNC para reintento
                    if (e.message && (
                        e.message.includes('Conflicto de concurrencia') ||
                        e.message.includes('Ya hay una operaciÃ³n de escritura en progreso') ||
                        e.message.includes('VerificaciÃ³n fallida') ||
                        e.message.includes('Integridad comprometida')
                    )) {
                        console.warn('âš ï¸ [CONCURRENCY] Error de concurrencia detectado');
                        console.warn('âš ï¸ [CONCURRENCY] Los datos permanecen en PENDING_SYNC para reintento automÃ¡tico');

                        this.updateUI(false);

                        const pendingCount = PENDING_SYNC.length;
                        if (showMessages) {
                            showNotification(
                                `âš ï¸ Conflicto de escritura detectado. ${pendingCount} registro${pendingCount > 1 ? 's' : ''} en cola para reintento.`,
                                'warning'
                            );
                        }

                        return {
                            success: false,
                            reason: 'concurrency_conflict',
                            queued: true,
                            pendingCount: pendingCount
                        };
                    }

                    // Para otros errores, comportamiento normal
                    this.updateUI(false);
                    if (showMessages) showNotification(`âŒ Error: ${e.result?.error?.message || e.message || 'Error desconocido'}`, 'error');
                    return { success: false };
                } finally {
                    this.inProgress = false;
                    updateConnectionIndicator();
                }
            },

            async save() {
                try {
                    // Guardar en localStorage (primario)
                    localStorage.setItem('pd_pending_sync', JSON.stringify(PENDING_SYNC));
                    
                    // Guardar tambiÃ©n en IndexedDB como respaldo (mÃ¡s robusto)
                    await this.saveToIndexedDB();
                    
                    console.log(`ðŸ’¾ [SYNC] Guardados ${PENDING_SYNC.length} registros pendientes`);
                } catch (e) {
                    console.error('âŒ [SYNC] Error guardando pendientes:', e);
                }
            },

            async load() {
                try {
                    // Cargar desde PersistenceManager (fuente de verdad)
                    PENDING_SYNC = await PersistenceManager.getPendingSync();
                    console.log(`ðŸ“‚ [SYNC] Cargados ${PENDING_SYNC.length} registros pendientes desde IndexedDB`);
                    
                    // Sincronizar con localStorage como respaldo
                    if (PENDING_SYNC.length > 0) {
                        localStorage.setItem('pd_pending_sync', JSON.stringify(PENDING_SYNC));
                    }
                } catch (e) {
                    console.error('âŒ [SYNC] Error cargando pendientes:', e);
                    // Fallback a localStorage si falla IndexedDB
                    try {
                        const saved = localStorage.getItem('pd_pending_sync');
                        if (saved) {
                            PENDING_SYNC = JSON.parse(saved);
                            console.log(`ðŸ“‚ [SYNC] Fallback: Cargados ${PENDING_SYNC.length} registros de localStorage`);
                        }
                    } catch (e2) {
                        console.error('âŒ [SYNC] Error en fallback localStorage:', e2);
                    }
                }
            },

            // Guardar en IndexedDB como respaldo
            async saveToIndexedDB() {
                return new Promise((resolve) => {
                    try {
                        const request = indexedDB.open('PendingSyncDB', 1);
                        
                        request.onupgradeneeded = (e) => {
                            const db = e.target.result;
                            if (!db.objectStoreNames.contains('pending')) {
                                db.createObjectStore('pending', { keyPath: 'id', autoIncrement: true });
                            }
                        };
                        
                        request.onsuccess = (e) => {
                            const db = e.target.result;
                            const tx = db.transaction('pending', 'readwrite');
                            const store = tx.objectStore('pending');
                            
                            // Limpiar y guardar todos los registros
                            store.clear();
                            PENDING_SYNC.forEach((record, index) => {
                                store.put({ ...record, id: index });
                            });
                            
                            tx.oncomplete = () => {
                                db.close();
                                resolve(true);
                            };
                            tx.onerror = () => {
                                db.close();
                                resolve(false);
                            };
                        };
                        
                        request.onerror = () => resolve(false);
                    } catch (e) {
                        resolve(false);
                    }
                });
            },

            // Cargar desde IndexedDB
            async loadFromIndexedDB() {
                return new Promise((resolve) => {
                    try {
                        const request = indexedDB.open('PendingSyncDB', 1);
                        
                        request.onupgradeneeded = (e) => {
                            const db = e.target.result;
                            if (!db.objectStoreNames.contains('pending')) {
                                db.createObjectStore('pending', { keyPath: 'id', autoIncrement: true });
                            }
                        };
                        
                        request.onsuccess = (e) => {
                            const db = e.target.result;
                            const tx = db.transaction('pending', 'readonly');
                            const store = tx.objectStore('pending');
                            const getAll = store.getAll();
                            
                            getAll.onsuccess = () => {
                                db.close();
                                // Remover el campo 'id' que agregamos para IndexedDB
                                const records = (getAll.result || []).map(r => {
                                    const { id, ...record } = r;
                                    return record;
                                });
                                resolve(records);
                            };
                            getAll.onerror = () => {
                                db.close();
                                resolve([]);
                            };
                        };
                        
                        request.onerror = () => resolve([]);
                    } catch (e) {
                        resolve([]);
                    }
                });
            },

            updateUI(synced) {
                const el = document.getElementById('sync-status');
                if (!el) return;

                // Contador de registros pendientes con estado detallado
                const pendingCount = PENDING_SYNC.length;
                const pendingWithStatus = PENDING_SYNC.filter(r => r._status === 'pending').length;
                
                if (!IS_ONLINE) {
                    el.className = 'sync-status sync-warning';
                    if (pendingCount > 0) {
                        el.innerHTML = `âš ï¸ Sin conexiÃ³n<br><strong>${pendingCount} registros en cola</strong>`;
                        el.style.cursor = 'pointer';
                        el.title = `${pendingCount} registros esperando sincronizaciÃ³n. Click para ver detalles.`;
                    } else {
                        el.innerHTML = `âš ï¸ Sin conexiÃ³n`;
                        el.title = 'Sin conexiÃ³n a internet';
                    }
                } else if (pendingCount > 0) {
                    el.className = 'sync-status sync-warning';
                    el.innerHTML = `â³ <strong>${pendingCount}</strong> pendiente${pendingCount !== 1 ? 's' : ''}`;
                    el.style.cursor = 'pointer';
                    el.title = `${pendingCount} registros esperando sincronizaciÃ³n. Click para sincronizar ahora.`;
                } else if (synced) {
                    el.className = 'sync-status sync-ok';
                    el.innerHTML = 'âœ… Sincronizado';
                    el.style.cursor = 'pointer';
                    el.title = 'Todos los registros estÃ¡n sincronizados';
                } else {
                    el.className = 'sync-status sync-error';
                    el.innerHTML = 'âŒ Error sync';
                    el.style.cursor = 'pointer';
                    el.title = 'Error en sincronizaciÃ³n. Click para reintentar.';
                }
                
                // Actualizar tambiÃ©n el tÃ­tulo de la pÃ¡gina si hay pendientes
                this.updatePageTitle(pendingCount);
            },
            
            updatePageTitle(pendingCount) {
                const baseTitle = 'Pallet Decoder';
                if (pendingCount > 0) {
                    document.title = `(${pendingCount}) ${baseTitle} - Pendientes`;
                } else {
                    document.title = baseTitle;
                }
            },

            showPanel() {
                const overlay = document.createElement('div');
                overlay.className = 'popup-overlay show';
                overlay.innerHTML = `
                    <div class="popup-content" style="max-width: 450px;">
                        <div class="popup-header">
                            <span>ðŸ“Š Estado de SincronizaciÃ³n</span>
                            <button class="popup-close" data-action="close">Ã—</button>
                        </div>
                        <div style="margin-bottom: 15px;">
                            <div style="padding: 15px; background: #f5f5f5; border-radius: 8px; margin-bottom: 10px; text-align: center;">
                                <div style="font-size: 0.85em; color: #666;">Pendientes de sincronizar</div>
                                <div style="font-size: 2em; font-weight: 700; color: ${PENDING_SYNC.length > 0 ? 'var(--warning)' : 'var(--success)'};">
                                    ${PENDING_SYNC.length}
                                </div>
                            </div>
                            <div style="font-size: 0.9em; padding: 10px; background: #f9f9f9; border-radius: 6px;">
                                ${IS_ONLINE ? 'ðŸŸ¢ Conectado a internet' : 'ðŸ”´ Sin conexiÃ³n'}<br>
                                ${gapi?.client?.getToken() ? 'ðŸŸ¢ Google conectado' : 'ðŸ”´ Google desconectado'}<br>
                                ðŸ“„ Hoja destino: <strong>${CONFIG.SHEET_NAME}</strong>
                            </div>
                        </div>
                        <div class="popup-buttons">
                            ${PENDING_SYNC.length > 0 && IS_ONLINE && gapi?.client?.getToken() ? `
                                <button class="btn btn-success btn-full" data-action="sync">
                                    ðŸ”„ Sincronizar Ahora
                                </button>
                                <button class="btn btn-warning btn-full" data-action="sync-slow" style="margin-top: 10px;">
                                    â±ï¸ SincronizaciÃ³n Lenta (mÃ¡s segura)
                                </button>
                            ` : ''}
                            <button class="btn btn-secondary btn-full" data-action="close">
                                Cerrar
                            </button>
                        </div>
                    </div>
                `;
                document.body.appendChild(overlay);
                
                const closePopup = () => overlay.remove();
                
                overlay.addEventListener('click', (e) => {
                    if (e.target === overlay) closePopup();
                    if (e.target.dataset.action === 'close') closePopup();
                    if (e.target.dataset.action === 'sync') {
                        closePopup();
                        SyncManager.sync();
                    }
                    if (e.target.dataset.action === 'sync-slow') {
                        closePopup();
                        SyncManager.syncSlow();
                    }
                });
            }
        };

        // ==================== SYNC QUEUE (SISTEMA DE COLA SECUENCIAL) ====================
        const SyncQueue = {
            processing: false,
            currentIndex: 0,
            totalRecords: 0,
            failedRecords: [],
            successCount: 0,
            
            async init() {
                // Cargar registros pendientes desde IndexedDB
                await this.loadPendingRecords();
                // Actualizar UI
                await this.updateCounter();
                // Iniciar heartbeat para actualizar contador
                this.startHeartbeat();
            },
            
            async loadPendingRecords() {
                try {
                    const pendingFromDB = await PersistenceManager.getPendingSync();
                    PENDING_SYNC = pendingFromDB;
                    console.log(`ðŸ“‚ [QUEUE] Cargados ${PENDING_SYNC.length} registros pendientes desde IndexedDB`);
                } catch (error) {
                    console.error('âŒ [QUEUE] Error cargando registros:', error);
                }
            },
            
            startHeartbeat() {
                setInterval(async () => {
                    if (!this.processing) {
                        await this.loadPendingRecords();
                        await this.updateCounter();
                    }
                }, 10000); // Cada 10 segundos
            },
            
            async updateCounter() {
                const syncStatus = document.getElementById('sync-status');
                const syncStatusText = document.getElementById('sync-status-text');
                if (!syncStatus || !syncStatusText) return;
                
                const pendingCount = PENDING_SYNC.length;
                
                if (this.processing) {
                    syncStatus.className = 'sync-status sync-syncing';
                    syncStatusText.textContent = `ðŸ”„ Procesando: ${this.currentIndex} de ${this.totalRecords}`;
                } else if (pendingCount > 0) {
                    syncStatus.className = 'sync-status sync-pending';
                    syncStatusText.textContent = `ðŸ“¤ ${pendingCount} Registro${pendingCount !== 1 ? 's' : ''} pendiente${pendingCount !== 1 ? 's' : ''}`;
                } else {
                    syncStatus.className = 'sync-status sync-ok';
                    syncStatusText.textContent = 'âœ… Sincronizado';
                }
            },
            
            showPanel() {
                const pendingCount = PENDING_SYNC.length;
                const hasConnection = IS_ONLINE && gapi?.client?.getToken();
                
                const overlay = document.createElement('div');
                overlay.className = 'popup-overlay show';
                overlay.id = 'sync-queue-panel';
                
                let failedHTML = '';
                if (this.failedRecords.length > 0) {
                    failedHTML = `
                        <div style="padding: 10px; background: #fee; border: 1px solid #fcc; border-radius: 6px; margin-bottom: 10px;">
                            <strong>âš ï¸ ${this.failedRecords.length} registro(s) con error:</strong>
                            <div style="max-height: 150px; overflow-y: auto; margin-top: 5px; font-size: 0.85em;">
                                ${this.failedRecords.map(r => `
                                    <div style="padding: 5px; border-bottom: 1px solid #fdd;">
                                        ${r.record.scan1} - ${r.error}
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    `;
                }
                
                overlay.innerHTML = `
                    <div class="popup-content" style="max-width: 500px;">
                        <div class="popup-header">
                            <span>ðŸ“Š Estado de SincronizaciÃ³n</span>
                            <button class="popup-close" onclick="document.getElementById('sync-queue-panel').remove()">Ã—</button>
                        </div>
                        <div style="margin-bottom: 15px;">
                            <div style="padding: 20px; background: ${pendingCount > 0 ? '#fff3cd' : '#d4edda'}; border-radius: 8px; margin-bottom: 15px; text-align: center;">
                                <div style="font-size: 0.9em; color: #666; margin-bottom: 5px;">Registros Pendientes</div>
                                <div style="font-size: 3em; font-weight: 700; color: ${pendingCount > 0 ? '#856404' : '#155724'};">
                                    ${pendingCount}
                                </div>
                            </div>
                            
                            ${failedHTML}
                            
                            <div style="font-size: 0.9em; padding: 12px; background: #f9f9f9; border-radius: 6px; line-height: 1.6;">
                                <div style="margin-bottom: 5px;">
                                    ${IS_ONLINE ? 'ðŸŸ¢ <strong>Conectado</strong> a internet' : 'ðŸ”´ <strong>Sin conexiÃ³n</strong> a internet'}
                                </div>
                                <div style="margin-bottom: 5px;">
                                    ${gapi?.client?.getToken() ? 'ðŸŸ¢ <strong>Google conectado</strong>' : 'ðŸ”´ <strong>Google desconectado</strong>'}
                                </div>
                                <div style="color: #666; font-size: 0.85em;">
                                    ðŸ“„ Hoja: <strong>${CONFIG.SHEET_NAME}</strong>
                                </div>
                            </div>
                            
                            ${this.processing ? `
                                <div style="margin-top: 15px; padding: 15px; background: #e3f2fd; border-radius: 6px; text-align: center;">
                                    <div style="font-weight: 600; color: #1976d2; margin-bottom: 8px;">
                                        ðŸ”„ Sincronizando...
                                    </div>
                                    <div style="font-size: 0.9em; color: #666;">
                                        Procesando registro ${this.currentIndex} de ${this.totalRecords}
                                    </div>
                                    <div style="margin-top: 10px; background: #fff; border-radius: 4px; height: 8px; overflow: hidden;">
                                        <div style="background: #1976d2; height: 100%; width: ${(this.currentIndex / this.totalRecords * 100)}%; transition: width 0.3s;"></div>
                                    </div>
                                </div>
                            ` : ''}
                        </div>
                        <div class="popup-buttons">
                            ${pendingCount > 0 && hasConnection && !this.processing ? `
                                <button class="btn btn-success btn-full" onclick="SyncQueue.startSync()" style="font-size: 1.1em; padding: 12px;">
                                    ðŸš€ Sincronizar Ahora
                                </button>
                            ` : ''}
                            ${this.failedRecords.length > 0 && !this.processing ? `
                                <button class="btn btn-warning btn-full" onclick="SyncQueue.retryFailed()">
                                    ðŸ”„ Reintentar Fallidos
                                </button>
                            ` : ''}
                            ${!hasConnection && pendingCount > 0 ? `
                                <div style="padding: 10px; background: #fff3cd; border-radius: 6px; text-align: center; margin-bottom: 10px;">
                                    âš ï¸ Conecta a internet para sincronizar
                                </div>
                            ` : ''}
                            <button class="btn btn-secondary btn-full" onclick="document.getElementById('sync-queue-panel').remove()">
                                Cerrar
                            </button>
                        </div>
                    </div>
                `;
                
                document.body.appendChild(overlay);
                
                overlay.addEventListener('click', (e) => {
                    if (e.target === overlay) overlay.remove();
                });
            },
            
            async startSync() {
                if (this.processing) {
                    showNotification('â³ SincronizaciÃ³n en progreso...', 'info');
                    return;
                }
                
                if (!IS_ONLINE) {
                    showNotification('âš ï¸ Sin conexiÃ³n a internet', 'warning');
                    return;
                }
                
                if (!gapi?.client?.getToken()) {
                    showNotification('âš ï¸ No conectado a Google', 'warning');
                    return;
                }
                
                if (PENDING_SYNC.length === 0) {
                    showNotification('âœ… No hay registros pendientes', 'success');
                    return;
                }
                
                // Cerrar panel si estÃ¡ abierto
                const panel = document.getElementById('sync-queue-panel');
                if (panel) panel.remove();
                
                // Limpiar estados de error previos
                this.failedRecords = [];
                this.successCount = 0;
                this.currentIndex = 0;
                this.totalRecords = PENDING_SYNC.length;
                this.processing = true;
                
                console.log(`ðŸš€ [QUEUE] Iniciando sincronizaciÃ³n de ${this.totalRecords} registros`);
                await this.updateCounter();
                
                // Procesar registros uno por uno
                await this.processQueue();
                
                // Finalizar
                this.processing = false;
                await this.updateCounter();
                
                // Mostrar resultado
                if (this.failedRecords.length === 0) {
                    showNotification(`âœ… SincronizaciÃ³n completada: ${this.successCount} registros enviados`, 'success');
                } else {
                    showNotification(`âš ï¸ SincronizaciÃ³n completada con ${this.failedRecords.length} errores. ${this.successCount} registros enviados.`, 'warning');
                    this.showPanel(); // Mostrar panel con errores
                }
            },
            
            async processQueue() {
                const recordsToProcess = [...PENDING_SYNC];
                
                for (let i = 0; i < recordsToProcess.length; i++) {
                    this.currentIndex = i + 1;
                    await this.updateCounter();
                    
                    const record = recordsToProcess[i];
                    console.log(`ðŸ“¤ [QUEUE] Procesando registro ${this.currentIndex}/${this.totalRecords}: ${record.scan1}`);
                    
                    try {
                        // Enviar registro individual
                        const success = await this.sendSingleRecord(record);
                        
                        if (success) {
                            // Ã‰xito: eliminar de PENDING_SYNC
                            PENDING_SYNC = PENDING_SYNC.filter(r => r._id !== record._id);
                            await PersistenceManager.markAsSynced([record]);
                            this.successCount++;
                            console.log(`âœ… [QUEUE] Registro ${this.currentIndex} sincronizado exitosamente`);
                        } else {
                            // Error: marcar como fallido
                            this.failedRecords.push({
                                record: record,
                                error: 'Error de servidor (no Status 200)'
                            });
                            console.error(`âŒ [QUEUE] Registro ${this.currentIndex} fallÃ³`);
                        }
                    } catch (error) {
                        // Error de red o excepciÃ³n
                        this.failedRecords.push({
                            record: record,
                            error: error.message || 'Error desconocido'
                        });
                        console.error(`âŒ [QUEUE] Error procesando registro ${this.currentIndex}:`, error);
                    }
                    
                    // PequeÃ±a pausa entre registros para evitar rate limiting
                    await new Promise(resolve => setTimeout(resolve, 300));
                }
                
                // Guardar estado actualizado
                await PersistenceManager.savePendingSync(PENDING_SYNC);
            },
            
            async sendSingleRecord(record) {
                try {
                    const values = [[
                        record.date, record.time, record.user, record.scan1, record.scan2,
                        record.location, record.status, record.note, record.pallet, record.originLocation || ''
                    ]];

                    // ========== NUEVO: USAR CONTROL DE CONCURRENCIA ==========
                    const response = await ConcurrencyControl.writeWithConcurrencyControl(
                        CONFIG.SPREADSHEET_WRITE,
                        CONFIG.SHEET_NAME,
                        values
                    );

                    // Validar Status 200 y Ã©xito
                    if (response.success && response.status === 200) {
                        console.log(`âœ… [QUEUE] Registro escrito con concurrencia en fila ${response.startRow}`);
                        return true;
                    } else {
                        console.warn(`âš ï¸ [QUEUE] Respuesta no exitosa: Status ${response.status}`);
                        return false;
                    }
                } catch (error) {
                    console.error(`âŒ [QUEUE] Error enviando registro:`, error);
                    throw error;
                }
            },
            
            async retryFailed() {
                if (this.failedRecords.length === 0) {
                    showNotification('âœ… No hay registros fallidos para reintentar', 'info');
                    return;
                }
                
                // Cerrar panel
                const panel = document.getElementById('sync-queue-panel');
                if (panel) panel.remove();
                
                // Limpiar y reintentar
                this.failedRecords = [];
                await this.startSync();
            }
        };

        // ==================== INITIALIZATION ====================
        document.addEventListener('DOMContentLoaded', async () => {
            initAudio();
            
            // FASE 2: RESTAURACIÃ“N AUTOMÃTICA (antes de cargar desde localStorage)
            await restoreFromIndexedDB();
            
            loadFromStorage();
            setupEventListeners();
            setupConnectionMonitor();
            
            // Inicializar nuevo sistema de cola de sincronizaciÃ³n
            await SyncQueue.init();
            
            gapi.load('client', initGAPI);
        });

        // RESTAURACIÃ“N AUTOMÃTICA desde IndexedDB
        async function restoreFromIndexedDB() {
            try {
                console.log('ðŸ”„ [RESTORE] ========== INICIANDO RESTAURACIÃ“N ==========');
                console.log('ðŸ”„ [RESTORE] Timestamp:', new Date().toISOString());
                
                // 1. Inicializar PersistenceManager
                console.log('ðŸ”„ [RESTORE] Paso 1: Inicializando PersistenceManager...');
                await PersistenceManager.init();
                console.log('âœ… [RESTORE] PersistenceManager inicializado');
                
                // 2. Obtener sesiÃ³n activa
                console.log('ðŸ”„ [RESTORE] Paso 2: Buscando sesiÃ³n activa...');
                const activeSession = await PersistenceManager.getActiveSession();
                console.log('ðŸ”„ [RESTORE] SesiÃ³n activa:', activeSession);
                
                if (activeSession) {
                    console.log('âœ… [RESTORE] SesiÃ³n activa encontrada:', activeSession.id);
                    console.log('ðŸ“Š [RESTORE] Detalles de sesiÃ³n:', JSON.stringify(activeSession, null, 2));
                    
                    // Asignar sesiÃ³n activa
                    CURRENT_SESSION_ID = activeSession.id;
                    console.log('âœ… [RESTORE] CURRENT_SESSION_ID asignado:', CURRENT_SESSION_ID);
                    
                    // 3. Restaurar cajas en borrador
                    console.log('ðŸ”„ [RESTORE] Paso 3: Obteniendo cajas en borrador...');
                    const draftBoxes = await PersistenceManager.getDraftBoxes(activeSession.id);
                    console.log(`ðŸ“¦ [RESTORE] Cajas encontradas: ${draftBoxes.length}`);
                    
                    if (draftBoxes.length > 0) {
                        console.log(`âœ… [RESTORE] Restaurando ${draftBoxes.length} cajas en borrador...`);
                        console.log('ðŸ“¦ [RESTORE] Primera caja:', JSON.stringify(draftBoxes[0], null, 2));
                        
                        // 4. Repoblar STATE.pallets desde IndexedDB (fuente de verdad)
                        console.log('ðŸ”„ [RESTORE] Paso 4: Repoblando STATE.pallets...');
                        let okCount = 0, blockedCount = 0, nowmsCount = 0;
                        
                        draftBoxes.forEach(box => {
                            if (box._category && STATE.pallets[box._category]) {
                                STATE.pallets[box._category].boxes.push(box);
                                if (box._category === 'ok') okCount++;
                                else if (box._category === 'blocked') blockedCount++;
                                else if (box._category === 'nowms') nowmsCount++;
                            } else {
                                console.warn('âš ï¸ [RESTORE] Caja sin categorÃ­a vÃ¡lida:', box);
                            }
                        });
                        
                        console.log(`âœ… [RESTORE] Cajas repobladas - OK: ${okCount}, Blocked: ${blockedCount}, NoWMS: ${nowmsCount}`);
                        console.log('ðŸ“Š [RESTORE] STATE.pallets.ok.boxes.length:', STATE.pallets.ok.boxes.length);
                        console.log('ðŸ“Š [RESTORE] STATE.pallets.blocked.boxes.length:', STATE.pallets.blocked.boxes.length);
                        console.log('ðŸ“Š [RESTORE] STATE.pallets.nowms.boxes.length:', STATE.pallets.nowms.boxes.length);
                        
                        // 5. Restaurar IDs de pallets si existen en la sesiÃ³n
                        console.log('ðŸ”„ [RESTORE] Paso 5: Restaurando IDs de pallets...');
                        if (activeSession.palletIds) {
                            console.log('ðŸ“Š [RESTORE] IDs de pallets en sesiÃ³n:', activeSession.palletIds);
                            if (activeSession.palletIds.ok) {
                                STATE.pallets.ok.id = activeSession.palletIds.ok;
                                console.log('âœ… [RESTORE] Pallet OK ID:', STATE.pallets.ok.id);
                            }
                            if (activeSession.palletIds.blocked) {
                                STATE.pallets.blocked.id = activeSession.palletIds.blocked;
                                console.log('âœ… [RESTORE] Pallet Blocked ID:', STATE.pallets.blocked.id);
                            }
                            if (activeSession.palletIds.nowms) {
                                STATE.pallets.nowms.id = activeSession.palletIds.nowms;
                                console.log('âœ… [RESTORE] Pallet NoWMS ID:', STATE.pallets.nowms.id);
                            }
                        } else {
                            console.warn('âš ï¸ [RESTORE] No hay IDs de pallets en la sesiÃ³n');
                        }
                        
                        // 6. Actualizar UI despuÃ©s de restaurar
                        console.log('ðŸ”„ [RESTORE] Paso 6: Actualizando UI...');
                        setTimeout(() => {
                            console.log('ðŸŽ¨ [RESTORE] Ejecutando updateUI()...');
                            updateUI();
                            console.log('ðŸ’¾ [RESTORE] Ejecutando saveToStorage()...');
                            saveToStorage(); // Sincronizar con localStorage
                            console.log('âœ… [RESTORE] ========== RESTAURACIÃ“N COMPLETADA ==========');
                            showNotification(`âœ… SesiÃ³n restaurada: ${draftBoxes.length} cajas recuperadas`, 'success');
                        }, 100);
                    } else {
                        console.log('â„¹ï¸ [RESTORE] No hay cajas en borrador para restaurar');
                    }
                } else {
                    console.log('â„¹ï¸ [RESTORE] No hay sesiÃ³n activa, creando nueva...');
                    
                    // Crear nueva sesiÃ³n
                    const newSession = {
                        id: generateUUID(),
                        createdAt: generateTimestamp(),
                        closed: false,
                        palletIds: {
                            ok: STATE.pallets.ok.id,
                            blocked: STATE.pallets.blocked.id,
                            nowms: STATE.pallets.nowms.id
                        }
                    };
                    
                    await PersistenceManager.saveSession(newSession);
                    window.CURRENT_SESSION_ID = newSession.id;
                    console.log('âœ… [RESTORE] Nueva sesiÃ³n creada:', newSession.id);
                }
                
                // 6. Cargar registros pendientes de sincronizaciÃ³n desde IndexedDB
                const pendingRecords = await PersistenceManager.getPendingSync();
                if (pendingRecords.length > 0) {
                    console.log(`âœ… [RESTORE] ${pendingRecords.length} registros pendientes de sincronizaciÃ³n`);
                    PENDING_SYNC = pendingRecords;
                    
                    // Actualizar contador UI
                    setTimeout(() => {
                        SyncManager.updateUI(false);
                    }, 200);
                }
                
            } catch (error) {
                console.error('âŒ [RESTORE] Error en restauraciÃ³n automÃ¡tica:', error);
                // Continuar con flujo normal si falla la restauraciÃ³n
            }
        }

        function initAudio() {
            try {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                document.addEventListener('click', () => {
                    if (audioCtx?.state === 'suspended') audioCtx.resume();
                }, { once: true });
            } catch (e) {}
        }

        async function initGAPI() {
            try {
                await gapi.client.init({
                    discoveryDocs: ["https://sheets.googleapis.com/$discovery/rest?version=v4"]
                });
                TOKEN_CLIENT = google.accounts.oauth2.initTokenClient({
                    client_id: CONFIG.CLIENT_ID,
                    scope: CONFIG.SCOPES,
                    callback: handleAuthCallback
                });
            } catch (e) {
                showNotification('Error inicializando API', 'error');
            }
        }

        async function handleAuthCallback(response) {
            if (response?.access_token) {
                try {
                    // Mostrar preloader durante todo el proceso de carga
                    showLoadingOverlay(true, 'ðŸ” Autenticando...', 'Verificando credenciales');

                    gapi.client.setToken(response);

                    showLoadingOverlay(true, 'ðŸ‘¤ Cargando perfil...', 'Obteniendo informaciÃ³n del usuario');
                    await getUserProfile();

                    // Cargar TODAS las bases de datos en paralelo
                    showLoadingOverlay(true, 'ðŸ“¦ Cargando Inventarios...', 'Descargando bases de datos...');
                    console.log('ðŸ”„ Iniciando carga de todas las bases de datos...');
                    await Promise.all([
                        loadInventory(),         // WMS - Base de datos principal
                        loadFILE2Inventory(),    // FILE2 - Base de datos secundaria
                        loadPriorityInventory()  // PRIORIDAD - CÃ³digos prioritarios
                    ]);
                    console.log('âœ… Todas las bases de datos cargadas');

                    showLoadingOverlay(true, 'âš™ï¸ Finalizando...', 'Inicializando sistema de sincronizaciÃ³n');
                    SyncManager.init();
                    
                    // Sincronizar pendientes si existen (en background)
                    if (PENDING_SYNC.length > 0) {
                        SyncManager.sync().catch(err => console.warn('âš ï¸ Error en sync inicial:', err));
                    }

                    // Solo mostrar la app despuÃ©s de que lo esencial estÃ© listo
                    showLoadingOverlay(true, 'âœ… Â¡Listo!', 'Abriendo aplicaciÃ³n');
                    setTimeout(() => {
                        showApp();
                        showLoadingOverlay(false);
                        
                        // OPTIMIZACIÃ“N: Inicializar ProcessedBoxesManager en BACKGROUND (no bloqueante)
                        console.log('ðŸ”„ [BACKGROUND] Inicializando ProcessedBoxesManager...');
                        ProcessedBoxesManager.init().then(() => {
                            console.log('âœ… [BACKGROUND] ProcessedBoxesManager inicializado');
                            // Sincronizar cajas procesadas del servidor (sin notificaciÃ³n)
                            ProcessedBoxesManager.syncFromServer(false);
                        }).catch(err => {
                            console.warn('âš ï¸ [BACKGROUND] Error inicializando ProcessedBoxesManager:', err);
                        });
                    }, 500); // PequeÃ±o delay para que el usuario vea el mensaje de "Â¡Listo!"
                } catch (error) {
                    console.error('âŒ Error durante la inicializaciÃ³n:', error);
                    showNotification('âŒ Error al inicializar el sistema', 'error');
                    showLoadingOverlay(false);
                }
            }
        }

        function handleLogin() {
            TOKEN_CLIENT?.requestAccessToken();
        }

        function formatUserName(fullName) {
            if (!fullName) return 'Usuario';
            // Split name into parts, capitalize first letter of each word
            return fullName.toLowerCase()
                .split(' ')
                .map(word => word.charAt(0).toUpperCase() + word.slice(1))
                .join(' ');
        }

        async function getUserProfile() {
            try {
                const response = await fetch('https://www.googleapis.com/oauth2/v2/userinfo', {
                    headers: { Authorization: `Bearer ${gapi.client.getToken().access_token}` }
                });
                const data = await response.json();
                USER_EMAIL = data.email || '';
                USER_GOOGLE_NAME = formatUserName(data.name) || 'Usuario';

                const savedAlias = localStorage.getItem(`pd_alias_${USER_EMAIL}`);
                if (savedAlias) {
                    CURRENT_USER = formatUserName(savedAlias);
                    showNotification(`âœ… Bienvenido, ${CURRENT_USER}`, 'success');
                    updateUserFooter();
                } else {
                    showAliasPopup();
                }
            } catch (e) {
                CURRENT_USER = 'Usuario';
                updateUserFooter();
            }
        }

        function showApp() {
            document.getElementById('login-screen').classList.add('hidden');
            document.getElementById('main-app').classList.remove('hidden');
            updateUserFooter();
            GlobalTabs.init();
            // Only update UI and focus if there are active tabs
            if (GlobalTabs.tabs.length > 0) {
                updateUI();
            }
        }

        function handleLogout() {
            // Verificar si hay datos sin sincronizar en TODOS los tabs
            const hasUnsyncedData = PENDING_SYNC.length > 0;
            const hasClassicData = STATE.pallets.ok.boxes.length > 0 ||
                STATE.pallets.blocked.boxes.length > 0 ||
                STATE.pallets.nowms.boxes.length > 0;

            let hasTabData = false;
            if (typeof GlobalTabs !== 'undefined' && GlobalTabs.tabs) {
                hasTabData = GlobalTabs.tabs.some(tab => {
                    const classicBoxes = Object.values(tab.state.classic.pallets).reduce((sum, p) => sum + p.boxes.length, 0);
                    const unifiedBoxes = tab.state.unified.boxes.length;
                    return classicBoxes > 0 || unifiedBoxes > 0;
                });
            }

            const hasData = hasUnsyncedData || hasClassicData || hasTabData;

            if (hasData) {
                if (!confirm('âš ï¸ Tienes datos sin sincronizar. Â¿Seguro que quieres cerrar sesiÃ³n y BORRAR todos los datos?')) {
                    return;
                }
            }

            // LIMPIAR TODO EL CACHE AL CERRAR SESIÃ“N
            console.log('ðŸ—‘ï¸ Cerrando sesiÃ³n - Limpiando cache completo...');

            // Limpiar estado del mÃ³dulo clÃ¡sico
            STATE.pallets = {
                ok: { id: generatePalletId('OK'), boxes: [], location: '' },
                blocked: { id: generatePalletId('BLK'), boxes: [], location: '' },
                nowms: { id: generatePalletId('NW'), boxes: [], location: '' }
            };
            STATE.history = [];
            STATE.pendingCode1 = null;

            // Limpiar PENDING_SYNC
            PENDING_SYNC = [];

            // Limpiar todos los tabs
            if (typeof GlobalTabs !== 'undefined') {
                GlobalTabs.tabs = [];
                GlobalTabs.activeTabId = null;
            }

            // Limpiar localStorage
            localStorage.removeItem('pd_system_state');
            localStorage.removeItem('pd_global_tabs');
            localStorage.removeItem('pd_pending_sync');
            localStorage.removeItem('pd_synced_pallets');
            SYNCED_PALLETS = new Set();

            console.log('âœ… Cache limpiado completamente (incluyendo registro de pallets sincronizados)');

            // Revocar token de Google
            if (gapi?.client?.getToken()) {
                google.accounts.oauth2.revoke(gapi.client.getToken().access_token);
                gapi.client.setToken(null);
            }

            CURRENT_USER = '';
            USER_EMAIL = '';
            document.getElementById('login-screen').classList.remove('hidden');
            document.getElementById('main-app').classList.add('hidden');

            showNotification('âœ… SesiÃ³n cerrada y datos eliminados', 'info');
        }

        // ==================== ALIAS/NICKNAME SYSTEM ====================
        function showAliasPopup() {
            document.querySelectorAll('.alias-popup').forEach(e => e.remove());

            const overlay = document.createElement('div');
            overlay.className = 'popup-overlay show alias-popup';
            overlay.innerHTML = `
                <div class="popup-content" style="max-width: 400px;">
                    <div class="popup-header">ðŸ‘¤ Â¿CÃ³mo te llamamos?</div>
                    <p style="margin-bottom: 15px; color: #666;">
                    Hola <strong>${USER_GOOGLE_NAME || 'Usuario'}</strong>, por favor ingresa tu nombre completo (nombre y apellido):
                </p>    
                    <div class="popup-buttons">
                        <button class="btn btn-primary btn-full" onclick="saveUserAlias('${USER_GOOGLE_NAME}', true)">
                            ðŸ‘¤ Usar mi nombre de Google
                        </button>
                        <div style="text-align: center; color: #999; font-size: 0.85em;">o</div>
                        <div style="display: flex; gap: 8px;">
                            <input type="text" id="alias-input" placeholder="Ej: Juan PÃ©rez"
                                style="flex: 1; padding: 12px; border: 2px solid #ddd; border-radius: 6px; font-size: 1em;"
                                maxlength="20">
                            <button class="btn btn-success" onclick="saveUserAlias(document.getElementById('alias-input').value)">
                                ðŸ’¾
                            </button>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(overlay);

            const input = overlay.querySelector('#alias-input');
            input.addEventListener('keypress', (e) => {
                if (e.key === 'Enter' && input.value.trim()) {
                    saveUserAlias(input.value);
                }
            });
            input.focus();
        }

        function saveUserAlias(alias, isGoogleName = false) {
            const finalAlias = alias?.trim() || USER_GOOGLE_NAME;
            
            // Validar que se ingrese nombre y apellido
            if (!finalAlias) {
                showNotification('âš ï¸ Por favor ingresa tu nombre completo', 'warning');
                return;
            }
            
            // Verificar que tenga al menos dos palabras (nombre y apellido)
            const nameParts = finalAlias.split(/\s+/).filter(part => part.length > 0);
            if (nameParts.length < 2) {
                showNotification('âš ï¸ Por favor ingresa nombre y apellido', 'warning');
                return;
            }

            // Format the name with title case
            CURRENT_USER = formatUserName(finalAlias);
            localStorage.setItem(`pd_alias_${USER_EMAIL}`, CURRENT_USER);

            document.querySelectorAll('.alias-popup').forEach(e => e.remove());
            showNotification(`âœ… ${isGoogleName ? 'Nombre' : 'Alias'} guardado: ${CURRENT_USER}`, 'success');
            updateUserFooter();
        }

        function changeUserAlias() {
            showAliasPopup();
        }

        function getInitials(name) {
            if (!name || name === 'No conectado') return '?';
            // Get first letters of first two words
            return name.split(' ')
                .filter((word, index) => index < 2) // Take first two words max
                .map(word => word.charAt(0).toUpperCase())
                .join('')
                .substring(0, 2); // Ensure max 2 characters
        }

        function updateUserFooter() {
            const avatar = document.getElementById('user-avatar');
            const avatarText = document.getElementById('user-avatar-text');
            const nameDisplay = document.getElementById('user-name-display');
            const emailDisplay = document.getElementById('user-email-display');

            if (avatar && avatarText) {
                const displayName = CURRENT_USER || 'No conectado';
                avatarText.textContent = getInitials(displayName);
                avatar.title = USER_EMAIL || 'No conectado';
            }
            
            if (nameDisplay) {
                nameDisplay.textContent = CURRENT_USER ? formatUserName(CURRENT_USER) : 'No conectado';
                nameDisplay.title = `Haz clic para cambiar el nombre`;
            }
            
            if (emailDisplay) {
                emailDisplay.textContent = USER_EMAIL || 'Inicia sesiÃ³n';
                emailDisplay.title = USER_EMAIL || '';
            }

            updateConnectionIndicator();
        }

        // ==================== INVENTORY ====================
        function showLoadingOverlay(show = true, message = null, subtext = null) {
            const overlay = document.getElementById('loading-overlay');
            if (overlay) {
                if (show) {
                    overlay.classList.add('show');
                    if (message) {
                        const textEl = document.getElementById('loading-text');
                        if (textEl) textEl.textContent = message;
                    }
                    if (subtext) {
                        const subtextEl = document.getElementById('loading-subtext');
                        if (subtextEl) subtextEl.textContent = subtext;
                    }
                } else {
                    overlay.classList.remove('show');
                }
            }
        }

        async function loadInventory() {
            try {
                updateConnectionIndicator(true);

                console.log('ðŸ”„ Cargando inventario WMS desde CSV...');
                const response = await fetch(CONFIG.INVENTORY_CSV_URL, {
                    method: 'GET',
                    mode: 'cors',
                    cache: 'no-cache'
                });

                console.log('ðŸ“¡ WMS - Respuesta recibida:', response.status, response.statusText);
                if (!response.ok) throw new Error(`HTTP ${response.status}`);

                const csv = await response.text();
                console.log('ðŸ“„ WMS - CSV recibido, tamaÃ±o:', csv.length, 'caracteres');
                if (!csv || csv.trim().length === 0) throw new Error('CSV vacÃ­o');

                parseInventoryCSV(csv);
                await saveToStorage();
                console.log('âœ… WMS - Inventario parseado:', STATE.inventory.size, 'cÃ³digos');
                updateBdInfo();
            } catch (e) {
                console.error('âŒ Error cargando inventario WMS:', e);
                showNotification(`âš ï¸ Error WMS: ${e.message}`, 'warning');

                if (STATE.inventory.size > 0) {
                    showNotification(`Usando ${STATE.inventory.size} cÃ³digos WMS en cachÃ©`, 'info');
                } else {
                    console.warn('âš ï¸ No hay cÃ³digos WMS en cachÃ©. Inventario vacÃ­o.');
                }
            } finally {
                updateConnectionIndicator();
            }
        }

        function parseInventoryCSV(csv) {
            const lines = csv.split('\n').filter(line => line.trim().length > 0);
            STATE.inventory.clear();

            console.log('ðŸ“Š Parseando CSV:', lines.length, 'lÃ­neas totales');

            // Mostrar header y primera lÃ­nea de datos
            if (lines.length > 0) {
                const header = parseCSVLine(lines[0]);
                console.log('ðŸ“‹ Header (columnas):', header.length, 'â†’', header.slice(0, 5).join(' | '));
            }
            if (lines.length > 1) {
                const firstRow = parseCSVLine(lines[1]);
                console.log('ðŸ“„ Primera fila:', firstRow.length, 'columnas â†’', firstRow.slice(0, 5).join(' | '));
                console.log('   â†’ CÃ³digo en col[1]:', firstRow[1]);
            }

            let validRows = 0;
            let invalidRows = 0;

            for (let i = 1; i < lines.length; i++) {
                const cols = parseCSVLine(lines[i]);

                if (cols.length >= 11) {
                    const code = (cols[1] || '').toString().trim().toUpperCase();

                    if (code && code.length > 0) {
                        const availableStock = parseFloat(cols[9]) || 0;
                        const lockedInventory = parseFloat(cols[10]) || 0;

                        STATE.inventory.set(code, {
                            code,
                            boxType: cols[0] || '',
                            warehouse: cols[3] || '',
                            cellNo: cols[6] || '',  // Columna G (Ã­ndice 6)
                            area: cols[8] || '',
                            availableStock,
                            lockedInventory,
                            sku: cols[12] || '',
                            productName: cols[13] || '',
                            isAvailable: availableStock > 0,
                            isBlocked: lockedInventory > 0
                        });
                        validRows++;
                    } else {
                        invalidRows++;
                        if (invalidRows <= 3) {
                            console.log(`âš ï¸ Fila ${i}: cÃ³digo vacÃ­o. Cols:`, cols.length, 'â†’ Col[1]:', cols[1]);
                        }
                    }
                } else {
                    invalidRows++;
                    if (invalidRows <= 3) {
                        console.log(`âš ï¸ Fila ${i}: solo tiene ${cols.length} columnas (necesita >= 11)`);
                    }
                }
            }

            STATE.inventoryLastUpdate = new Date().toLocaleString();
            console.log('âœ… Parseado completo:', STATE.inventory.size, 'cÃ³digos Ãºnicos');
            console.log('ðŸ“Š Filas vÃ¡lidas:', validRows, '| Filas invÃ¡lidas:', invalidRows);

            // Mostrar primeros 3 cÃ³digos como ejemplo
            if (STATE.inventory.size > 0) {
                const samples = Array.from(STATE.inventory.keys()).slice(0, 3);
                console.log('ðŸ“¦ Ejemplos de cÃ³digos:', samples.join(', '));
            }
        }

        function parseCSVLine(line) {
            const result = [];
            let current = '';
            let inQuotes = false;

            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                if (char === '"') {
                    inQuotes = !inQuotes;
                } else if (char === ',' && !inQuotes) {
                    result.push(current.trim());
                    current = '';
                } else {
                    current += char;
                }
            }
            result.push(current.trim());
            return result;
        }

        async function refreshInventory() {
            // Recargar AMBAS bases de datos
            await Promise.all([
                loadInventory(),      // WMS
                loadFILE2Inventory()  // FILE2
            ]);
        }

        // ==================== FILE2 LOADING (Segundo nivel de bÃºsqueda) ====================
        async function loadFILE2Inventory() {
            // Verificar cachÃ© en IndexedDB (30 minutos de validez)
            try {
                const cachedData = await loadFile2FromIndexedDB();

                if (cachedData) {
                    const cacheAge = Date.now() - cachedData.timestamp;
                    const THIRTY_MINUTES = 30 * 60 * 1000;

                    if (cacheAge < THIRTY_MINUTES) {
                        BD_CODES_FILE2 = new Set(cachedData.codes);
                        FILE2_LAST_UPDATE = new Date(cachedData.timestamp).toLocaleString();
                        console.log(`âœ… FILE2: ${BD_CODES_FILE2.size} cÃ³digos desde IndexedDB (${Math.round(cacheAge / 60000)} min)`);
                        return;
                    } else {
                        console.log('â° CachÃ© de FILE2 expirado, recargando...');
                    }
                }
            } catch (e) {
                console.warn('âš ï¸ Error leyendo cachÃ© FILE2 de IndexedDB, recargando...', e);
            }

            // Cargar desde CSV
            try {
                console.log('ðŸ”„ Cargando FILE2 desde CSV...');
                const response = await fetch(CONFIG.FILE2_CSV_URL, {
                    method: 'GET',
                    mode: 'cors',
                    cache: 'no-cache'
                });

                console.log('ðŸ“¡ FILE2 respuesta:', response.status, response.statusText);
                if (!response.ok) throw new Error(`HTTP ${response.status}`);

                const csv = await response.text();
                console.log('ðŸ“„ FILE2 CSV recibido, tamaÃ±o:', csv.length, 'caracteres');
                if (!csv || csv.trim().length === 0) throw new Error('FILE2 CSV vacÃ­o');

                // Parsear CSV de FILE2 - SOLO columna I (Ã­ndice 8)
                const lines = csv.split('\n').filter(line => line.trim().length > 0);
                BD_CODES_FILE2.clear();

                console.log('ðŸ“Š FILE2: parseando', lines.length, 'lÃ­neas');

                // Saltar header (lÃ­nea 0) y procesar solo columna I
                for (let i = 1; i < lines.length; i++) {
                    const cols = parseCSVLine(lines[i]);
                    if (cols.length >= 9) {  // Necesita al menos 9 columnas para tener Ã­ndice 8
                        const code = cols[8]?.toString().trim();  // Columna I (Ã­ndice 8)
                        if (code && code.length > 0) {
                            const normalized = normalizeCode(code);
                            BD_CODES_FILE2.add(normalized);
                        }
                    }
                }

                // Guardar en IndexedDB (soporta hasta 50+ MB, ideal para 188k cÃ³digos)
                const now = Date.now();
                try {
                    const codesArray = [...BD_CODES_FILE2];
                    await saveFile2ToIndexedDB(codesArray, now);
                    console.log(`ðŸ’¾ FILE2 guardado en IndexedDB: ${codesArray.length} cÃ³digos`);
                } catch (storageError) {
                    console.warn('âš ï¸ No se pudo guardar FILE2 en IndexedDB:', storageError.message);
                    // Continuar sin cachÃ© - se recargarÃ¡ en la prÃ³xima sesiÃ³n
                }
                FILE2_LAST_UPDATE = new Date(now).toLocaleString();

                console.log(`âœ… FILE2: ${BD_CODES_FILE2.size} cÃ³digos Ãºnicos cargados`);

                // Mostrar ejemplos
                if (BD_CODES_FILE2.size > 0) {
                    const samples = Array.from(BD_CODES_FILE2).slice(0, 3);
                    console.log('ðŸ“¦ FILE2 ejemplos:', samples.join(', '));
                }
            } catch (error) {
                console.error('âŒ Error cargando FILE2:', error);
            }
        }

        // ==================== PRIORITY LOADING (ValidaciÃ³n de cÃ³digos prioritarios) ====================
        async function loadPriorityInventory() {
            // Verificar cachÃ© en IndexedDB (30 minutos de validez)
            try {
                const cachedData = await loadPriorityFromIndexedDB();

                if (cachedData) {
                    const cacheAge = Date.now() - cachedData.timestamp;
                    const THIRTY_MINUTES = 30 * 60 * 1000;

                    if (cacheAge < THIRTY_MINUTES) {
                        PRIORITY_CODES = new Set(cachedData.codes);
                        PRIORITY_LAST_UPDATE = new Date(cachedData.timestamp).toLocaleString();
                        console.log(`ðŸ”´ PRIORIDAD: ${PRIORITY_CODES.size} cÃ³digos desde IndexedDB (${Math.round(cacheAge / 60000)} min)`);
                        return;
                    } else {
                        console.log('â° CachÃ© de PRIORIDAD expirado, recargando...');
                    }
                }
            } catch (e) {
                console.warn('âš ï¸ Error leyendo cachÃ© PRIORIDAD de IndexedDB, recargando...', e);
            }

            // Cargar desde CSV
            try {
                console.log('ðŸ”„ Cargando PRIORIDAD desde CSV...');
                const response = await fetch(CONFIG.PRIORITY_CSV_URL, {
                    method: 'GET',
                    mode: 'cors',
                    cache: 'no-cache'
                });

                console.log('ðŸ“¡ PRIORIDAD respuesta:', response.status, response.statusText);
                if (!response.ok) throw new Error(`HTTP ${response.status}`);

                const csv = await response.text();
                console.log('ðŸ“„ PRIORIDAD CSV recibido, tamaÃ±o:', csv.length, 'caracteres');
                if (!csv || csv.trim().length === 0) throw new Error('PRIORIDAD CSV vacÃ­o');

                // Parsear CSV de PRIORIDAD - Primera columna (Ã­ndice 0)
                const lines = csv.split('\n').filter(line => line.trim().length > 0);
                PRIORITY_CODES.clear();

                console.log('ðŸ“Š PRIORIDAD: parseando', lines.length, 'lÃ­neas');

                // Saltar header (lÃ­nea 0) y procesar primera columna
                for (let i = 1; i < lines.length; i++) {
                    const cols = parseCSVLine(lines[i]);
                    if (cols.length >= 1) {
                        const code = cols[0]?.toString().trim();  // Primera columna
                        if (code && code.length > 0) {
                            const normalized = normalizeCode(code);
                            PRIORITY_CODES.add(normalized);
                        }
                    }
                }

                // Guardar en IndexedDB
                const now = Date.now();
                try {
                    const codesArray = [...PRIORITY_CODES];
                    await savePriorityToIndexedDB(codesArray, now);
                    console.log(`ðŸ’¾ PRIORIDAD guardada en IndexedDB: ${codesArray.length} cÃ³digos`);
                } catch (storageError) {
                    console.warn('âš ï¸ No se pudo guardar PRIORIDAD en IndexedDB:', storageError.message);
                }
                PRIORITY_LAST_UPDATE = new Date(now).toLocaleString();

                console.log(`âœ… PRIORIDAD: ${PRIORITY_CODES.size} cÃ³digos Ãºnicos cargados`);

                // Mostrar ejemplos
                if (PRIORITY_CODES.size > 0) {
                    const samples = Array.from(PRIORITY_CODES).slice(0, 3);
                    console.log('ðŸ”´ PRIORIDAD ejemplos:', samples.join(', '));
                }
            } catch (error) {
                console.error('âŒ Error cargando PRIORIDAD:', error);
            }
        }

        /**
         * Verifica si un cÃ³digo es prioritario
         * Retorna: { isPriority: boolean, variant: string }
         */
        async function checkIfPriority(rawCode) {
            // Cargar cÃ³digos de prioridad si aÃºn no estÃ¡n cargados
            if (PRIORITY_CODES.size === 0) {
                await loadPriorityInventory();
            }

            const normalized = normalizeCode(rawCode);

            // Intentar bÃºsqueda con variantes
            const variants = [
                normalized,
                normalized.replace(/\//g, '-'),
                normalized.replace(/-/g, '/')
            ];

            for (const variant of variants) {
                if (PRIORITY_CODES.has(variant)) {
                    return {
                        isPriority: true,
                        variant: variant
                    };
                }
            }

            return {
                isPriority: false,
                variant: null
            };
        }

        /**
         * BÃºsqueda de dos niveles: WMS (inventario principal) + FILE2 (base secundaria)
         * Retorna: { code: string, item: object|null, source: 'WMS'|'FILE2'|'UNKNOWN', variant: string }
         */
        async function findCodeInInventoryTwoLevel(rawCode) {
            const normalized = normalizeCode(rawCode);

            // NIVEL 1: Buscar en WMS (inventario principal)
            const wmsResult = findCodeInInventory(rawCode);
            if (wmsResult.item) {
                return {
                    ...wmsResult,
                    source: 'WMS'
                };
            }

            // NIVEL 2: Buscar en FILE2 (carga bajo demanda con cachÃ©)
            if (BD_CODES_FILE2.size === 0) {
                await loadFILE2Inventory();
            }

            // Intentar bÃºsqueda con variantes en FILE2
            const variants = [
                normalized,
                normalized.replace(/\//g, '-'),
                normalized.replace(/-/g, '/')
            ];

            for (const variant of variants) {
                if (BD_CODES_FILE2.has(variant)) {
                    // Encontrado en FILE2 - crear item sintÃ©tico
                    return {
                        code: variant,
                        item: {
                            cellNo: '-',
                            sku: '-',
                            productName: 'Archivo 2',
                            availableStock: 0,
                            isBlocked: false,
                            isAvailable: true
                        },
                        source: 'FILE2',
                        variant: variant === normalized ? 'original' :
                                variant.includes('-') ? 'dash' : 'slash'
                    };
                }
            }

            // No encontrado en ningÃºn nivel
            return {
                code: normalized,
                item: null,
                source: 'UNKNOWN',
                variant: 'none'
            };
        }

        function updateBdInfo() {
            const totalCodes = STATE.inventory.size + BD_CODES_FILE2.size;
            document.getElementById('bd-count').textContent = totalCodes.toLocaleString();
            document.getElementById('bd-update-time').textContent =
                `WMS: ${STATE.inventoryLastUpdate || 'Sin actualizar'}`;
        }

        // ==================== SCAN PROCESSING ====================
        function setupEventListeners() {
            // Setup login button
            const loginButton = document.getElementById('login-button');
            if (loginButton) {
                loginButton.addEventListener('click', handleLogin);
            }

            const scanInput = document.getElementById('scan-input');
            scanInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && scanInput.value.trim()) {
                    e.preventDefault();
                    processScan(scanInput.value.trim());
                    scanInput.value = '';  // Limpiar automÃ¡ticamente
                }
            });

            const code2Input = document.getElementById('code2-input');
            code2Input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && code2Input.value.trim()) {
                    e.preventDefault();
                    processCode2(code2Input.value.trim());
                    code2Input.value = '';  // Limpiar automÃ¡ticamente
                }
            });

            // Agregar event listeners para los campos de ubicaciÃ³n
            // Para actualizar el estado de los botones "Enviar Tarima"
            const locationOk = document.getElementById('location-ok');
            const locationBlocked = document.getElementById('location-blocked');
            const locationNowms = document.getElementById('location-nowms');

            if (locationOk) {
                locationOk.addEventListener('input', updateSendButtons);
            }
            if (locationBlocked) {
                locationBlocked.addEventListener('input', updateSendButtons);
            }
            if (locationNowms) {
                locationNowms.addEventListener('input', updateSendButtons);
            }
        }

        async function processScan(rawCode) {
            // BÃºsqueda de dos niveles: WMS + FILE2
            const result = await findCodeInInventoryTwoLevel(rawCode);
            const code = result.code;
            const item = result.item;
            const source = result.source;

            // VALIDACIÃ“N DE PRIORIDAD (en paralelo)
            const priorityCheck = await checkIfPriority(rawCode);
            const isPriority = priorityCheck.isPriority;

            // Check duplicates across all pallets con info detallada
            const duplicateInfo = findDuplicate(code);

            if (duplicateInfo) {
                showDuplicatePopup(code, duplicateInfo, rawCode);
                flashInput('warning');
                playSound('warning');
                return;
            }

            if (!item) {
                // Not found in both levels - show Code2 input
                // PROTECCIÃ“N: Si ya hay un pendingCode1, advertir al usuario
                if (STATE.pendingCode1 && STATE.pendingCode1.code !== code) {
                    const userConfirm = confirm(
                        `âš ï¸ Ya tienes un cÃ³digo pendiente: ${STATE.pendingCode1.code}\n\n` +
                        `Â¿Deseas cancelar el cÃ³digo anterior y usar el nuevo cÃ³digo: ${code}?`
                    );
                    if (!userConfirm) {
                        flashInput('warning');
                        playSound('warning');
                        // Mantener el foco en code2-input para continuar con el cÃ³digo anterior
                        setTimeout(() => document.getElementById('code2-input').focus(), 100);
                        return;
                    }
                }

                STATE.pendingCode1 = { raw: rawCode, code, isPriority };
                showResultBox('error', code, 'NO ENCONTRADO',
                    'CÃ³digo no encontrado en WMS ni Archivo 2. Ingresa CÃ³digo 2 o usa INSERTADO.', null);
                document.getElementById('code2-container').classList.add('show');
                flashInput('error');
                playSound('error');
                setTimeout(() => document.getElementById('code2-input').focus(), 100);
                return;
            }

            // Hide code2 container
            document.getElementById('code2-container').classList.remove('show');
            STATE.pendingCode1 = null;

            // MOSTRAR ALERTA SI ES PRIORIDAD
            if (isPriority) {
                showPriorityAlert(code);
            }

            // Determine status and add to appropriate pallet
            if (item.isBlocked) {
                addBox('blocked', createBoxData(rawCode, code, '', item, source, isPriority));
                showResultBox('blocked', code, 'BLOQUEADO', 'Inventario bloqueado', item);
                playSound('warning');
            } else if (item.isAvailable) {
                addBox('ok', createBoxData(rawCode, code, '', item, source, isPriority));
                const statusMsg = source === 'FILE2' ? 'Validado en Archivo 2 (OK - No WMS)' : 'Validado correctamente';
                showResultBox('success', code, 'OK', statusMsg, item);
                playSound('success');
            } else {
                addBox('blocked', createBoxData(rawCode, code, '', item, source, isPriority));
                showResultBox('blocked', code, 'SIN STOCK', 'Sin stock disponible', item);
                playSound('warning');
            }

            flashInput('success');
        }

        // Buscar duplicado con informaciÃ³n detallada - VALIDACIÃ“N DUAL
        function findDuplicate(code) {
            // BYPASS: Si estamos en modo ajuste, saltar toda la validaciÃ³n de duplicados
            if (window.ADJUSTMENT_MODE && window.ADJUSTMENT_MODE.active) {
                console.log('ðŸ”§ [AJUSTE] Modo ajuste activo - Saltando validaciÃ³n de duplicados');
                return null;
            }

            // Usar limpieza profunda para evitar falsos positivos
            const normalizedCode = ProcessedBoxesManager.cleanCode(code);
            if (!normalizedCode || normalizedCode.length === 0) {
                console.log('âš ï¸ [DUPLICATE] CÃ³digo vacÃ­o despuÃ©s de limpieza, saltando validaciÃ³n');
                return null;
            }

            const categories = ['ok', 'blocked', 'nowms'];
            const categoryNames = { ok: 'OK', blocked: 'Bloqueado', nowms: 'No WMS' };

            // PASO 1: Buscar en pallets de la sesiÃ³n actual (STATE.pallets)
            for (const cat of categories) {
                const boxes = STATE.pallets[cat].boxes;
                const index = boxes.findIndex(b => {
                    const boxCode = ProcessedBoxesManager.cleanCode(b.code);
                    const boxScan2 = ProcessedBoxesManager.cleanCode(b.scan2);
                    return (boxCode && boxCode === normalizedCode) || (boxScan2 && boxScan2 === normalizedCode);
                });
                if (index !== -1) {
                    const box = boxes[index];
                    return {
                        source: 'current_session',
                        category: cat,
                        categoryName: categoryNames[cat],
                        index,
                        box,
                        timestamp: box.timestamp,
                        user: CURRENT_USER,
                        pallet: STATE.pallets[cat].id,
                        location: STATE.pallets[cat].location || 'Sin ubicaciÃ³n'
                    };
                }
            }

            // PASO 2: Buscar en PENDING_SYNC (registros locales pendientes de sincronizar)
            const pendingResult = ProcessedBoxesManager.findInPendingSync(normalizedCode);
            if (pendingResult) {
                return {
                    source: 'pending_sync',
                    category: null,
                    categoryName: 'Pendiente de sincronizar',
                    index: -1,
                    box: null,
                    timestamp: `${pendingResult.date} ${pendingResult.time}`,
                    user: pendingResult.user,
                    pallet: pendingResult.pallet,
                    location: pendingResult.location,
                    scan1: pendingResult.scan1,
                    scan2: pendingResult.scan2
                };
            }

            // PASO 3: Buscar en cajas procesadas del servidor (Lazy Load)
            const serverResult = ProcessedBoxesManager.findInProcessed(normalizedCode);
            if (serverResult) {
                return {
                    source: 'server',
                    category: null,
                    categoryName: 'Base de datos',
                    index: -1,
                    box: null,
                    timestamp: `${serverResult.date} ${serverResult.time}`,
                    user: serverResult.user,
                    pallet: serverResult.pallet,
                    location: serverResult.location,
                    scan1: serverResult.scan1,
                    scan2: serverResult.scan2
                };
            }

            return null;
        }

        // Mostrar alerta de prioridad
        function showPriorityAlert(code) {
            const overlay = document.createElement('div');
            overlay.className = 'popup-overlay show priority-alert-overlay';
            overlay.innerHTML = `
                <div class="popup-content priority-alert-popup" style="border: 3px solid #7c69fd; max-width: 500px;">
                    <div class="popup-header" style="background: linear-gradient(135deg, #7c69fd, #7B1FA2); color: white;">
                        <span>ðŸ”´ Â¡ATENCIÃ“N: CAJA DE PRIORIDAD!</span>
                        <button class="popup-close" data-action="close" style="color: white;">Ã—</button>
                    </div>
                    <div style="padding: 25px; text-align: center;">
                        <div style="font-size: 4em; margin-bottom: 15px;">âš ï¸</div>
                        <h3 style="color: #7c69fd; margin-bottom: 15px; font-size: 1.3em;">CÃ“DIGO PRIORITARIO DETECTADO</h3>
                        <div style="background: #F3E5F5; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                            <div style="font-size: 0.9em; color: #666; margin-bottom: 5px;">CÃ³digo:</div>
                            <div style="font-size: 1.5em; font-weight: 700; color: #7c69fd; font-family: 'Courier New', monospace;">
                                ${code}
                            </div>
                        </div>
                        <div style="background: #ffffff; border-left: 4px solid #FF9800; padding: 15px; margin-bottom: 20px; text-align: left;">
                            <strong style="color: #E65100;">âš¡ ACCIÃ“N REQUERIDA:</strong><br>
                            <span style="color: #666; font-size: 0.95em;">
                                Separar de inmediato y notificar al encargado para su gestiÃ³n oportuna.
                            </span>
                        </div>
                        <button class="btn btn-primary btn-full" data-action="close" style="background: #7c69fd; font-size: 1.1em; padding: 12px;">
                            âœ“ Entendido
                        </button>
                    </div>
                </div>
            `;
            document.body.appendChild(overlay);
            
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay || e.target.dataset.action === 'close') {
                    overlay.remove();
                }
            });

            // Reproducir sonido de alerta (mÃ¡s fuerte)
            playSound('warning');
            setTimeout(() => playSound('warning'), 300);

            // Auto-focus en el botÃ³n
            setTimeout(() => {
                const btn = overlay.querySelector('.btn-primary');
                if (btn) btn.focus();
            }, 100);

            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) overlay.remove();
            });
        }

        // Mostrar popup de duplicado con opciÃ³n de ingreso forzado - ALERTA DETALLADA
        function showDuplicatePopup(code, duplicateInfo, rawCode) {
            // Determinar el origen del duplicado para mostrar mensaje apropiado
            const sourceLabels = {
                'current_session': 'ðŸ“‹ SesiÃ³n Actual',
                'pending_sync': 'â³ Pendiente de Sincronizar',
                'server': 'ðŸ—„ï¸ Base de Datos Central'
            };
            const sourceLabel = sourceLabels[duplicateInfo.source] || 'Registro Previo';
            
            // Determinar si permitir ingreso forzado (solo para sesiÃ³n actual)
            const allowForceInsert = duplicateInfo.source === 'current_session';
            
            const overlay = document.createElement('div');
            overlay.className = 'popup-overlay show';
            overlay.innerHTML = `
                <div class="popup-content duplicate-popup" style="border: 2px solid #F44336; max-width: 320px; padding: 0;">
                    <div style="display: flex; justify-content: space-between; align-items: center; padding: 8px 12px; background: #FFEBEE; border-bottom: 1px solid #FFCDD2;">
                        <span style="font-weight: 600; color: #D32F2F; font-size: 0.85em;">â›” Caja Duplicada</span>
                        <button class="popup-close" data-action="close" style="color: #D32F2F; font-size: 1.2em; background: none; border: none; cursor: pointer;">Ã—</button>
                    </div>
                    <div style="padding: 12px;">
                        <div style="background: #fff; padding: 8px; border-radius: 4px; margin-bottom: 10px; border: 1px solid #eee;">
                            <div style="font-size: 0.75em; color: #999;">CÃ³digo:</div>
                            <div style="font-size: 1em; font-weight: 700; color: #333; font-family: monospace; word-break: break-all;">${code}</div>
                        </div>
                        <div style="font-size: 0.75em; color: #E65100; font-weight: 600; margin-bottom: 6px;">${sourceLabel}</div>
                        <div style="font-size: 0.8em; line-height: 1.6;">
                            <div><span style="color: #888;">ðŸ“¦</span> ${duplicateInfo.pallet || 'N/A'}</div>
                            <div><span style="color: #888;">ðŸ‘¤</span> ${duplicateInfo.user || '-'}</div>
                            <div><span style="color: #888;">ðŸ•</span> ${duplicateInfo.timestamp || '-'}</div>
                            <div><span style="color: #888;">ðŸ“</span> ${duplicateInfo.location || '-'}</div>
                        </div>
                        ${!allowForceInsert ? `<div style="background: #FFCDD2; padding: 6px; border-radius: 4px; margin-top: 10px; text-align: center; font-size: 0.75em; color: #C62828;">âš ï¸ Sin ingreso forzado</div>` : ''}
                        <div style="margin-top: 10px;">
                            ${allowForceInsert ? `<button class="btn btn-warning btn-full" data-action="force" style="padding: 8px; font-size: 0.85em; margin-bottom: 6px;">âš¡ Forzar</button>` : ''}
                            <button class="btn btn-secondary btn-full" data-action="close" style="padding: 8px; font-size: 0.85em;">${allowForceInsert ? 'Cancelar' : 'OK'}</button>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(overlay);
            
            const closePopup = () => overlay.remove();
            
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) closePopup();
                if (e.target.dataset.action === 'close') closePopup();
                if (e.target.dataset.action === 'force') {
                    forceInsertDuplicate(code, rawCode);
                    closePopup();
                }
            });
        }

        // Forzar inserciÃ³n de duplicado
        async function forceInsertDuplicate(code, rawCode) {
            // Usar bÃºsqueda de dos niveles para el duplicado tambiÃ©n
            const result = await findCodeInInventoryTwoLevel(rawCode);
            const finalCode = result.code;
            const item = result.item;
            const source = result.source;

            // Validar prioridad
            const priorityCheck = await checkIfPriority(rawCode);
            const isPriority = priorityCheck.isPriority;

            if (isPriority) {
                showPriorityAlert(finalCode);
            }

            if (!item) {
                addBox('nowms', createBoxData(rawCode, finalCode, '', null, 'UNKNOWN', isPriority));
                showNotification('âš¡ Duplicado insertado en No WMS', 'warning');
            } else if (item.isBlocked) {
                addBox('blocked', createBoxData(rawCode, finalCode, '', item, source, isPriority));
                showNotification('âš¡ Duplicado insertado en Bloqueado', 'warning');
            } else {
                addBox('ok', createBoxData(rawCode, finalCode, '', item, source, isPriority));
                showNotification('âš¡ Duplicado insertado en OK', 'warning');
            }

            playSound('warning');
            document.getElementById('scan-input').focus();
        }

        async function processCode2(rawCode2) {
            if (!STATE.pendingCode1) return;

            // BÃºsqueda de dos niveles para Code2 tambiÃ©n
            const result = await findCodeInInventoryTwoLevel(rawCode2);
            const code2 = result.code;
            const item = result.item;
            const source = result.source;

            // Validar prioridad del cÃ³digo 2
            const priorityCheck2 = await checkIfPriority(rawCode2);
            const isPriorityCode2 = priorityCheck2.isPriority;
            const isPriority = STATE.pendingCode1.isPriority || isPriorityCode2;

            if (isPriority) {
                showPriorityAlert(item ? code2 : STATE.pendingCode1.code);
            }

            document.getElementById('code2-container').classList.remove('show');

            if (!item) {
                // ESCENARIO 2: Ambos cÃ³digos fallaron - add to No WMS con AMBOS cÃ³digos
                addBox('nowms', createBoxData(STATE.pendingCode1.raw, STATE.pendingCode1.code, rawCode2, null, 'UNKNOWN', isPriority));
                showResultBox('error', STATE.pendingCode1.code, 'NO WMS',
                    `Ambos cÃ³digos no encontrados. Guardados: ${STATE.pendingCode1.code} y ${code2}`, null);
                playSound('error');
            } else {
                // ESCENARIO 3: CÃ³digo 2 SÃ coincide - HACER SWAP
                // El cÃ³digo 2 que coincidiÃ³ se convierte en el principal (scan1)
                // El cÃ³digo 1 que fallÃ³ se guarda como secundario (scan2)
                let status;
                if (item.isBlocked) {
                    status = 'blocked';
                    // SWAP: code2 va a scan1, pendingCode1.raw va a scan2
                    addBox('blocked', createBoxData(rawCode2, code2, STATE.pendingCode1.raw, item, source, isPriority));
                    showResultBox('blocked', code2, 'BLOQUEADO (CÃ³digo 2 Validado)',
                        'CÃ³digo 2 validado correctamente - Inventario bloqueado', item);
                    playSound('warning');
                } else {
                    status = 'ok';
                    // SWAP: code2 va a scan1, pendingCode1.raw va a scan2
                    addBox('ok', createBoxData(rawCode2, code2, STATE.pendingCode1.raw, item, source, isPriority));
                    const statusMsg = source === 'FILE2' ? 'CÃ³digo 2 validado en Archivo 2 (SWAP realizado)' : 'CÃ³digo 2 validado correctamente (SWAP realizado)';
                    showResultBox('success', code2, 'OK (CÃ³digo 2 Validado)', statusMsg, item);
                    playSound('success');
                }
            }

            STATE.pendingCode1 = null;
            flashInput('success');
            document.getElementById('scan-input').focus();
        }

        function forceInsert() {
            if (!STATE.pendingCode1) {
                showNotification('âš ï¸ Primero escanea un cÃ³digo', 'warning');
                return;
            }

            const code2Value = document.getElementById('code2-input').value.trim();
            const isPriority = STATE.pendingCode1.isPriority || false;

            if (isPriority) {
                showPriorityAlert(STATE.pendingCode1.code);
            }

            // Guardar AMBOS cÃ³digos
            addBox('nowms', createBoxData(
                STATE.pendingCode1.raw,
                STATE.pendingCode1.code,
                code2Value,  // Puede estar vacÃ­o o tener valor
                null,
                'UNKNOWN',
                isPriority
            ));

            const msg = code2Value
                ? `Insertado con cÃ³digos: ${STATE.pendingCode1.code} y ${code2Value}`
                : `Insertado con cÃ³digo: ${STATE.pendingCode1.code}`;

            showResultBox('error', STATE.pendingCode1.code, 'INSERTADO (No WMS)', msg, null);

            document.getElementById('code2-container').classList.remove('show');
            document.getElementById('code2-input').value = '';
            STATE.pendingCode1 = null;

            playSound('warning');
            flashInput('warning');
            document.getElementById('scan-input').focus();
            showNotification('âš¡ Registro insertado forzosamente', 'warning');
        }

        function createBoxData(raw, code, scan2, item, source = 'WMS', isPriority = false) {
            const cleanScan2 = scan2 ? normalizeCode(scan2) : '';
            return {
                raw,
                code,
                scan1: code,
                scan2: cleanScan2,  // CÃ³digo limpio del segundo escaneo
                rawScan2: scan2 || '',  // Valor raw para referencia
                location: item?.cellNo || '-',
                sku: item?.sku || '-',
                product: item?.productName || '-',
                timestamp: new Date().toLocaleTimeString(),
                source: source,  // 'WMS' | 'FILE2' | 'UNKNOWN'
                isPriority: isPriority  // true si es un cÃ³digo prioritario
            };
        }

        function normalizeCode(raw) {
            let code = raw.trim().toUpperCase();

            // Patrones de extracciÃ³n especiales (JSON, etc)
            const patterns = [
                /\[id\[.*?\[([^\[]+)\[/i,
                /Â¨idÂ¨.*?Â¨([^Â¨]+)Â¨/i,
                /"id"\s*:\s*"([^"]+)"/i
            ];

            for (const pattern of patterns) {
                const match = code.match(pattern);
                if (match) return match[1];
            }

            // PatrÃ³n especial: IDxxxxxx-xxOPERATION... â†’ extraer solo xxxxxx-xx
            // Ejemplo: ID51014088-10PERATIONFBMTYPENBOUNDSOURCESELLER â†’ 51014088-10
            const idPattern = /^ID(\d+[-\/]\d+)/i;
            const idMatch = code.match(idPattern);
            if (idMatch) {
                console.log(`ðŸ” CÃ³digo extraÃ­do de patrÃ³n ID: ${idMatch[1]} (original: ${raw})`);
                return idMatch[1];
            }

            // Limpiar caracteres especiales excepto guiones, diagonales y letras/nÃºmeros
            return code.replace(/[^a-zA-Z0-9\-\/]/g, '');
        }

        /**
         * BÃºsqueda inteligente de cÃ³digo en inventario
         * Intenta primero con "-", luego con "/" si no encuentra
         * Retorna: { code: string, item: object|null, variant: 'dash'|'slash'|'original' }
         */
        function findCodeInInventory(rawCode) {
            const normalized = normalizeCode(rawCode);

            // 1. Intentar buscar tal como viene (despuÃ©s de normalizar)
            let item = STATE.inventory.get(normalized);
            if (item) {
                return { code: normalized, item, variant: 'original' };
            }

            // 2. Si contiene "/", intentar con "-"
            if (normalized.includes('/')) {
                const withDash = normalized.replace(/\//g, '-');
                item = STATE.inventory.get(withDash);
                if (item) {
                    return { code: withDash, item, variant: 'dash' };
                }
            }

            // 3. Si contiene "-", intentar con "/"
            if (normalized.includes('-')) {
                const withSlash = normalized.replace(/-/g, '/');
                item = STATE.inventory.get(withSlash);
                if (item) {
                    return { code: withSlash, item, variant: 'slash' };
                }
            }

            // No encontrado en ninguna variante
            return { code: normalized, item: null, variant: 'none' };
        }

        // ==================== VALIDADOR DE UBICACIONES ====================
        // NOTE: Using shared validation from wms-utils.js
        // validateLocation() is now imported from wms-utils.js

        /**
         * Valida ubicaciÃ³n con verificaciÃ³n de uso diario
         * Incluye: formato, rangos, y validaciÃ³n de uso diario (local + BD)
         */
        async function confirmInvalidLocation(location) {
            try {
                console.log('Validating location:', location);
                
                // 1. Validar formato y rangos usando funciÃ³n compartida
                if (typeof validateLocation !== 'function') {
                    console.error('validateLocation is not a function');
                    showNotification('âŒ Error: FunciÃ³n de validaciÃ³n no disponible', 'error');
                    return { confirmed: false, formatted: null };
                }
                
                const validation = validateLocation(location);
                console.log('Location validation result:', validation);

                if (!validation.valid) {
                    // UbicaciÃ³n invÃ¡lida - mostrar error y rechazar
                    showNotification(`âŒ ${validation.message}`, 'error');
                    return { confirmed: false, formatted: null };
                }

                // 2. Validar uso diario en historial local
                if (typeof validateLocationDailyUsage !== 'function') {
                    console.error('validateLocationDailyUsage is not a function');
                    showNotification('âŒ Error: FunciÃ³n de validaciÃ³n diaria no disponible', 'error');
                    return { confirmed: false, formatted: null };
                }
                
                const dailyUsageLocal = validateLocationDailyUsage(location, window.STATE?.history || []);
                console.log('Daily usage local check:', dailyUsageLocal);
                
                if (!dailyUsageLocal.valid) {
                    showNotification(`âŒ ${dailyUsageLocal.message}`, 'error');
                    return { confirmed: false, formatted: null };
                }

                // 3. Validar uso diario en base de datos (si hay conexiÃ³n)
                if (window.IS_ONLINE && window.gapi?.client?.getToken) {
                    try {
                        console.log('Checking online database for location usage...');
                        const response = await window.gapi.client.sheets.spreadsheets.values.get({
                            spreadsheetId: window.CONFIG?.SPREADSHEET_WRITE,
                            range: `${window.CONFIG?.SHEET_NAME || 'BD'}!A:J`
                        });
                        
                        const dbRecords = response.result.values || [];
                        console.log('Retrieved', dbRecords.length, 'records from database');
                        
                        if (typeof validateLocationDailyUsageDB !== 'function') {
                            console.error('validateLocationDailyUsageDB is not a function');
                            showNotification('âŒ Error: FunciÃ³n de validaciÃ³n de BD no disponible', 'error');
                            return { confirmed: false, formatted: null };
                        }
                        
                        const dailyUsageDB = validateLocationDailyUsageDB(location, dbRecords);
                        console.log('Daily usage DB check:', dailyUsageDB);
                        
                        if (!dailyUsageDB.valid) {
                            showNotification(`âŒ ${dailyUsageDB.message}`, 'error');
                            return { confirmed: false, formatted: null };
                        }
                    } catch (error) {
                        console.warn('âš ï¸ No se pudo validar uso diario en BD:', error);
                        // Continuar si falla la validaciÃ³n de BD (modo offline)
                    }
                } else {
                    console.log('Skipping DB validation - offline or no auth token');
                }

                // 4. Todo vÃ¡lido - retornar ubicaciÃ³n normalizada
                console.log('Location validation successful, normalized:', validation.normalized);
                return { 
                    confirmed: true, 
                    formatted: validation.normalized 
                };
                
            } catch (error) {
                console.error('Error in confirmInvalidLocation:', error);
                showNotification('âŒ Error al validar la ubicaciÃ³n. Por favor, intente nuevamente.', 'error');
                return { confirmed: false, formatted: null };
            }
        }

        function showResultBox(type, code, title, message, item) {
            const box = document.getElementById('result-box');
            const icons = { success: 'âœ…', warning: 'âš ï¸', blocked: 'âš ï¸', error: 'âŒ' };

            box.className = `result-box show ${type}`;
            document.getElementById('result-icon').textContent = icons[type] || 'ðŸ“¦';
            document.getElementById('result-title').textContent = `${title}: ${code}`;

            const detailsEl = document.getElementById('result-details');
            if (item) {
                detailsEl.innerHTML = `
                    <div class="result-info-item"><span class="result-info-label">Ubic:</span><span class="result-info-value">${item.cellNo || '-'}</span></div>
                    <div class="result-info-item"><span class="result-info-label">SKU:</span><span class="result-info-value">${item.sku || '-'}</span></div>
                    <div class="result-info-item"><span class="result-info-label">Stock:</span><span class="result-info-value">${item.availableStock || 0}</span></div>
                `;
            } else {
                detailsEl.innerHTML = `<div class="result-info-item" style="color: #666;">${message}</div>`;
            }
        }

        function flashInput(type) {
            const input = document.getElementById('scan-input');
            if (!input) return;
            input.classList.remove('success', 'error');
            if (type === 'success') {
                input.classList.add('success');
            } else if (type === 'error') {
                input.classList.add('error');
            }
            setTimeout(() => input.classList.remove('success', 'error'), 500);
        }

        // ==================== BOX MANAGEMENT ====================
        // REFACTORIZADO: Persistencia instantÃ¡nea con transacciÃ³n atÃ³mica
        async function addBox(category, boxData) {
            try {
                console.log('ðŸ“¦ [ADD-BOX] ========== AGREGANDO CAJA ==========');
                console.log('ðŸ“¦ [ADD-BOX] CategorÃ­a:', category);
                console.log('ðŸ“¦ [ADD-BOX] Datos:', boxData);
                console.log('ðŸ“¦ [ADD-BOX] CURRENT_SESSION_ID:', CURRENT_SESSION_ID);
                
                // 1. CREAR REGISTRO CON METADATA COMPLETA
                const boxRecord = {
                    _id: generateUUID(),
                    _timestamp: generateTimestamp(),
                    _status: 'draft',
                    _sessionId: CURRENT_SESSION_ID || 'default',
                    _category: category,
                    _palletId: STATE.pallets[category].id,
                    ...boxData
                };
                
                console.log('ðŸ“¦ [ADD-BOX] Registro creado:', JSON.stringify(boxRecord, null, 2));

                // 2. PERSISTENCIA INSTANTÃNEA EN IndexedDB (fuente de verdad)
                console.log('ðŸ’¾ [ADD-BOX] Guardando en IndexedDB...');
                await PersistenceManager.saveDraftBox(boxRecord);
                console.log(`âœ… [ADD-BOX] Caja persistida en IndexedDB: ${boxRecord._id}`);

                // 3. LUEGO actualizar RAM (vista)
                console.log('ðŸ’¾ [ADD-BOX] Agregando a STATE.pallets...');
                STATE.pallets[category].boxes.push(boxRecord);
                console.log(`âœ… [ADD-BOX] STATE.pallets.${category}.boxes.length:`, STATE.pallets[category].boxes.length);
                
                // 4. Guardar en localStorage como respaldo (no bloqueante)
                console.log('ðŸ’¾ [ADD-BOX] Guardando en localStorage...');
                saveToStorage().catch(err => console.warn('âš ï¸ Error en saveToStorage:', err));

                // 5. Actualizar tabs globales
                if (typeof GlobalTabs !== 'undefined' && GlobalTabs.saveCurrentTabState) {
                    GlobalTabs.saveCurrentTabState();
                }

                if (typeof GlobalTabs !== 'undefined' && GlobalTabs.updateGlobalSummary) {
                    GlobalTabs.updateGlobalSummary();
                }

                // 6. Actualizar UI
                console.log('ðŸŽ¨ [ADD-BOX] Actualizando UI...');
                updateUI();
                console.log('âœ… [ADD-BOX] ========== CAJA AGREGADA ==========');
                
                return boxRecord;
            } catch (error) {
                console.error('âŒ [ADD-BOX] Error crÃ­tico en addBox:', error);
                console.error('âŒ [ADD-BOX] Stack:', error.stack);
                // Fallback: agregar solo a RAM si falla IndexedDB
                STATE.pallets[category].boxes.push(boxData);
                updateUI();
                showNotification('âš ï¸ Caja agregada (modo degradado)', 'warning');
                return boxData;
            }
        }

        async function deleteBox(category, index) {
            if (confirm('Â¿Eliminar esta caja?')) {
                try {
                    const box = STATE.pallets[category].boxes[index];
                    
                    // 1. Eliminar de IndexedDB primero (si tiene _id)
                    if (box._id) {
                        await PersistenceManager.deleteDraftBox(box._id);
                        console.log(`âœ… [ATOMIC-DELETE] Caja eliminada de IndexedDB: ${box._id}`);
                    }
                    
                    // 2. Eliminar de RAM
                    STATE.pallets[category].boxes.splice(index, 1);
                    
                    // 3. Guardar en localStorage como respaldo
                    saveToStorage().catch(err => console.warn('âš ï¸ Error en saveToStorage:', err));

                    // 4. Actualizar tabs globales
                    if (typeof GlobalTabs !== 'undefined' && GlobalTabs.saveCurrentTabState) {
                        GlobalTabs.saveCurrentTabState();
                    }

                    if (typeof GlobalTabs !== 'undefined' && GlobalTabs.updateGlobalSummary) {
                        GlobalTabs.updateGlobalSummary();
                    }

                    // 5. Actualizar UI
                    updateUI();
                    showNotification('Caja eliminada', 'info');
                } catch (error) {
                    console.error('âŒ [ATOMIC-DELETE] Error eliminando caja:', error);
                    showNotification('âš ï¸ Error al eliminar caja', 'error');
                }
            }
        }

        // ==================== SEND INDIVIDUAL PALLET ====================
        // OPTIMIZADO: ValidaciÃ³n rÃ¡pida usando cache local, sin consultas remotas bloqueantes
        async function sendPallet(category) {
            const pallet = STATE.pallets[category];
            const locationInput = document.getElementById(`location-${category}`);
            const location = locationInput.value.trim();

            if (pallet.boxes.length === 0) {
                showNotification('âš ï¸ No hay cajas en esta tarima', 'warning');
                return;
            }

            if (!location) {
                showNotification('âš ï¸ Ingresa la ubicaciÃ³n destino', 'warning');
                locationInput.focus();
                return;
            }

            // OPTIMIZADO: ValidaciÃ³n LOCAL rÃ¡pida (sin consulta remota)
            // La verificaciÃ³n contra BD se hace en background despuÃ©s del envÃ­o
            const localDuplicate = DeduplicationManager.isPalletSynced(pallet.id, location);
            if (localDuplicate) {
                const prefixes = { ok: 'OK', blocked: 'BLK', nowms: 'NW' };
                pallet.id = generatePalletId(prefixes[category]);
                document.getElementById(`${category}-pallet`).textContent = pallet.id;
                saveToStorage();
                console.log(`ðŸ”„ [DEDUP] Pallet duplicado local detectado, nuevo ID: ${pallet.id}`);
            }

            // Pre-validaciÃ³n: confirmar cantidad fÃ­sica (inmediato)
            showSendValidationPopup(category, location);
        }

        // Popup de pre-validaciÃ³n de cantidad fÃ­sica (blind count protocol)
        function showSendValidationPopup(category, location) {
            const pallet = STATE.pallets[category];
            const boxCount = pallet.boxes.length;
            const categoryNames = { ok: 'OK âœ…', blocked: 'Bloqueado âš ï¸', nowms: 'No WMS âŒ' };

            // Enable blind mode - blur all counters
            document.body.classList.add('blind-mode');

            const overlay = document.createElement('div');
            overlay.className = 'popup-overlay show';
            overlay.id = 'send-validation-popup';
            overlay.innerHTML = `
                <div class="popup-content send-validation-popup">
                    <div class="popup-header">
                        <span>ðŸ“¦ Validar EnvÃ­o - ${categoryNames[category]}</span>
                        <button class="popup-close" id="validation-close-btn">Ã—</button>
                    </div>
                    <p style="margin-bottom: 15px; font-size: 0.9em;">
                        <strong>Destino:</strong> ${location}<br>
                        <span style="color: #888; font-size: 0.85em;">ðŸ”’ Conteo oculto - Verifica fÃ­sicamente</span>
                    </p>
                    <div class="validation-input-group">
                        <label>Â¿CuÃ¡ntas cajas fÃ­sicas hay en la tarima?</label>
                        <input type="number" id="physical-count-input" min="0" placeholder="" autofocus>
                    </div>
                    <div id="validation-status"></div>
                    <div class="popup-buttons">
                        <button class="btn btn-success btn-full" id="confirm-send-btn" disabled>
                            ðŸ“¤ Confirmar EnvÃ­o
                        </button>
                        <button class="btn btn-secondary btn-full" id="validation-cancel-btn">
                            Cancelar
                        </button>
                    </div>
                </div>
            `;
            document.body.appendChild(overlay);

            // Attach event listeners
            const closeBtn = document.getElementById('validation-close-btn');
            const cancelBtn = document.getElementById('validation-cancel-btn');
            const confirmBtn = document.getElementById('confirm-send-btn');
            const input = document.getElementById('physical-count-input');

            if (closeBtn) closeBtn.addEventListener('click', closeBlindValidationPopup);
            if (cancelBtn) cancelBtn.addEventListener('click', closeBlindValidationPopup);
            if (confirmBtn) {
                confirmBtn.addEventListener('click', () => {
                    // HARD BLOCK: Verificar si ya estÃ¡ procesando
                    if (isSubmitting) {
                        console.warn('âš ï¸ [SEND] Ya hay un envÃ­o en progreso');
                        return;
                    }
                    
                    // PRIMERA LÃNEA: Establecer isSubmitting = true
                    isSubmitting = true;
                    
                    // BLOQUEO INMEDIATO: Deshabilitar botÃ³n fÃ­sicamente
                    confirmBtn.disabled = true;
                    confirmBtn.innerHTML = '<span style="display: inline-block; animation: spin 1s linear infinite;">â³</span> Procesando envÃ­o...';
                    confirmBtn.style.opacity = '0.6';
                    confirmBtn.style.cursor = 'not-allowed';
                    
                    // Cerrar popup inmediatamente
                    closeBlindValidationPopup();
                    
                    // Ejecutar envÃ­o
                    confirmSendPallet(category, location);
                });
            }
            if (input) {
                input.addEventListener('input', () => validateBoxCount(boxCount));
                input.focus();
            }

            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) closeBlindValidationPopup();
            });
        }

        // Close validation popup and disable blind mode
        function closeBlindValidationPopup() {
            document.body.classList.remove('blind-mode');
            const popup = document.getElementById('send-validation-popup');
            if (popup) popup.remove();
        }

        // Validar cantidad de cajas fÃ­sicas vs escaneadas
        function validateBoxCount(expectedCount) {
            const input = document.getElementById('physical-count-input');
            const statusDiv = document.getElementById('validation-status');
            const confirmBtn = document.getElementById('confirm-send-btn');
            const physicalCount = parseInt(input.value) || 0;

            // Validar que expectedCount sea un nÃºmero vÃ¡lido
            const validExpectedCount = parseInt(expectedCount) || 0;
            if (validExpectedCount <= 0) {
                statusDiv.innerHTML = '';
                confirmBtn.disabled = true;
                return;
            }

            if (physicalCount === validExpectedCount) {
                statusDiv.innerHTML = `<div class="validation-match">âœ… Â¡Correcto! Cantidad coincide (${validExpectedCount} cajas)</div>`;
                confirmBtn.disabled = false;
            } else if (physicalCount > 0) {
                const diff = physicalCount - validExpectedCount;
                const diffText = diff > 0 ? `+${diff} de mÃ¡s` : `${Math.abs(diff)} faltan`;
                statusDiv.innerHTML = `<div class="validation-mismatch">âŒ No coincide: Escaneadas ${validExpectedCount}, FÃ­sicas ${physicalCount} (${diffText})</div>`;
                confirmBtn.disabled = true;
            } else {
                statusDiv.innerHTML = '';
                confirmBtn.disabled = true;
            }
        }

        // Confirmar envÃ­o despuÃ©s de validaciÃ³n
        async function confirmSendPallet(category, location) {
            // Obtener botÃ³n de confirmaciÃ³n
            const confirmBtn = document.getElementById('confirm-send-btn');
            
            try {
                console.log('ðŸš€ [SEND] ========== INICIANDO ENVÃO DE PALLET ==========');
                console.log('ðŸš€ [SEND] CategorÃ­a:', category);
                console.log('ðŸš€ [SEND] UbicaciÃ³n:', location);
                
                // PROTECCIÃ“N: Prevenir doble click / duplicaciÃ³n
                if (window.SENDING_IN_PROGRESS) {
                    console.warn('âš ï¸ [SEND] EnvÃ­o ya en progreso, ignorando solicitud duplicada');
                    return;
                }
                
                window.SENDING_IN_PROGRESS = true;
                console.log('ðŸ”’ [SEND] Flag SENDING_IN_PROGRESS activado');
                
                // DESHABILITAR BOTÃ“N INMEDIATAMENTE (Anti-spam)
                if (confirmBtn) {
                    confirmBtn.disabled = true;
                    confirmBtn.textContent = 'â³ Procesando...';
                    confirmBtn.style.opacity = '0.6';
                    confirmBtn.style.cursor = 'not-allowed';
                }
                
                // Cerrar popup de validaciÃ³n y disable blind mode
                document.body.classList.remove('blind-mode');
                const popup = document.getElementById('send-validation-popup');
                if (popup) popup.remove();

                const pallet = STATE.pallets[category];
                if (!pallet) {
                    console.error('âŒ [SEND] Pallet not found for category:', category);
                    showNotification('âŒ Error: No se encontrÃ³ la tarima', 'error');
                    window.SENDING_IN_PROGRESS = false;
                    isSubmitting = false;
                    return;
                }

                const locationInput = document.getElementById(`location-${category}`);
                const originLocationInput = document.getElementById('origin-location');
                const originLocation = originLocationInput ? originLocationInput.value.trim().toUpperCase() : '';

                console.log('ðŸ” [SEND] Validando ubicaciÃ³n:', location);
                
                // Validar formato de ubicaciÃ³n y uso diario
                if (typeof confirmInvalidLocation !== 'function') {
                    console.error('âŒ [SEND] confirmInvalidLocation is not a function');
                    showNotification('âŒ Error: FunciÃ³n de validaciÃ³n no disponible', 'error');
                    window.SENDING_IN_PROGRESS = false;
                    isSubmitting = false;
                    return;
                }

                console.log('ðŸ” [SEND] Llamando a confirmInvalidLocation()...');
                const locationCheck = await confirmInvalidLocation(location);
                console.log('ðŸ” [SEND] Resultado de validaciÃ³n:', JSON.stringify(locationCheck, null, 2));
                
                if (!locationCheck || !locationCheck.confirmed) {
                    const errorMsg = locationCheck?.message || 'UbicaciÃ³n invÃ¡lida o en uso';
                    console.error('âŒ [SEND] Location validation failed:', errorMsg);
                    console.error('âŒ [SEND] locationCheck completo:', locationCheck);
                    showNotification(`âŒ ${errorMsg}`, 'error');
                    if (locationInput) locationInput.focus();
                    window.SENDING_IN_PROGRESS = false;
                    isSubmitting = false;
                    return;
                }
                
                console.log('âœ… [SEND] UbicaciÃ³n validada correctamente');

                // Usar la ubicaciÃ³n formateada (normalizada si es vÃ¡lida)
                const finalLocation = locationCheck.formatted;
                console.log('Using normalized location:', finalLocation);

                // BYPASS: Si estamos en modo AJUSTE, saltar validaciÃ³n de ubicaciÃ³n duplicada
                const isAdjustmentMode = window.ADJUSTMENT_MODE && window.ADJUSTMENT_MODE.active;
                
                if (!isAdjustmentMode) {
                    console.log('ðŸ” [VALIDATION] ========== VALIDACIÃ“N DE UBICACIÃ“N DUPLICADA ==========');
                    // VALIDACIÃ“N CRÃTICA: Verificar si la ubicaciÃ³n ya fue usada HOY
                    const today = new Date().toISOString().split('T')[0]; // YYYY-MM-DD
                    console.log('ðŸ” [VALIDATION] Fecha hoy:', today);
                    console.log('ðŸ” [VALIDATION] UbicaciÃ³n a validar:', finalLocation);
                    
                    // IMPORTANTE: Sincronizar PENDING_SYNC desde IndexedDB antes de validar
                    try {
                        const pendingFromDB = await PersistenceManager.getPendingSync();
                        PENDING_SYNC = pendingFromDB;
                        console.log(`ðŸ” [VALIDATION] PENDING_SYNC actualizado: ${PENDING_SYNC.length} registros`);
                    } catch (error) {
                        console.warn('âš ï¸ [VALIDATION] Error sincronizando PENDING_SYNC:', error);
                    }
                    
                    // CAPA 1: Verificar en PENDING_SYNC (registros locales pendientes)
                    console.log('ðŸ” [VALIDATION] Capa 1: Verificando en PENDING_SYNC...');
                    const usedInPending = PENDING_SYNC.some(record => {
                        const recordDate = record.date; // YYYY-MM-DD
                        const match = recordDate === today && record.location === finalLocation;
                        if (match) {
                            console.log('âŒ [VALIDATION] Match encontrado en PENDING_SYNC:', record);
                        }
                        return match;
                    });

                    if (usedInPending) {
                        console.error(`âŒ [VALIDATION] BLOQUEADO - UbicaciÃ³n ${finalLocation} ya fue usada hoy en registros pendientes`);
                        showNotification(`âŒ La ubicaciÃ³n ${finalLocation} ya fue usada hoy. Elige otra ubicaciÃ³n.`, 'error');
                        if (locationInput) locationInput.focus();
                        window.SENDING_IN_PROGRESS = false;
                        isSubmitting = false;
                        return;
                    }
                    console.log('âœ… [VALIDATION] Capa 1: No encontrado en PENDING_SYNC');

                    // CAPA 2: Verificar en STATE.history (registros locales del historial)
                    console.log('ðŸ” [VALIDATION] Capa 2: Verificando en STATE.history...');
                    console.log('ðŸ” [VALIDATION] STATE.history.length:', STATE.history.length);
                    const usedInHistory = STATE.history.some(record => {
                        const recordDate = record.date; // YYYY-MM-DD
                        const match = recordDate === today && record.location === finalLocation;
                        if (match) {
                            console.log('âŒ [VALIDATION] Match encontrado en STATE.history:', record);
                        }
                        return match;
                    });

                    if (usedInHistory) {
                        console.error(`âŒ [VALIDATION] BLOQUEADO - UbicaciÃ³n ${finalLocation} ya fue usada hoy en historial local`);
                        showNotification(`âŒ La ubicaciÃ³n ${finalLocation} ya fue usada hoy. Elige otra ubicaciÃ³n.`, 'error');
                        if (locationInput) locationInput.focus();
                        window.SENDING_IN_PROGRESS = false;
                        isSubmitting = false;
                        return;
                    }
                    console.log('âœ… [VALIDATION] Capa 2: No encontrado en STATE.history');

                    // CAPA 3: Verificar en cachÃ© de datos del servidor (PROCESSED_BOXES_MAP)
                    console.log('ðŸ” [VALIDATION] Capa 3: Verificando en cachÃ© del servidor...');
                    console.log(`ðŸ” [VALIDATION] PROCESSED_BOXES_MAP.size: ${PROCESSED_BOXES_MAP.size}`);
                    
                    let usedInServerCache = false;
                    for (const [code, boxData] of PROCESSED_BOXES_MAP) {
                        const dbDate = boxData.date; // Formato: YYYY-MM-DD
                        const dbLocation = boxData.location;
                        const match = dbDate === today && dbLocation === finalLocation;
                        if (match) {
                            console.log('âŒ [VALIDATION] Match encontrado en cachÃ© del servidor:', boxData);
                            usedInServerCache = true;
                            break;
                        }
                    }

                    if (usedInServerCache) {
                        console.error(`âŒ [VALIDATION] BLOQUEADO - UbicaciÃ³n ${finalLocation} ya fue usada hoy por otro usuario`);
                        showNotification(`âŒ La ubicaciÃ³n ${finalLocation} ya fue usada hoy por otro usuario. Elige otra ubicaciÃ³n.`, 'error');
                        if (locationInput) locationInput.focus();
                        window.SENDING_IN_PROGRESS = false;
                        isSubmitting = false;
                        return;
                    }
                    console.log('âœ… [VALIDATION] Capa 3: No encontrado en cachÃ© del servidor');

                    console.log('âœ… [VALIDATION] ========== UBICACIÃ“N VALIDADA - NO DUPLICADA ==========');
                } else {
                    console.log('ðŸ”§ [AJUSTE] ========== BYPASS DE VALIDACIÃ“N ACTIVADO (MODO AJUSTE) ==========');
                }
                
                if (locationInput) {
                    locationInput.value = finalLocation;
                }

                const statusMap = { ok: 'OK', blocked: 'BLOQUEADO', nowms: 'NO WMS' };
                const { dateStr, timeStr } = getLocalDateTime();
                console.log('Using date/time:', { dateStr, timeStr });

                // Incluye columna J: UbicaciÃ³n FÃ­sica de Origen
                const records = pallet.boxes.map(box => {
                    // Determinar estatus y nota segÃºn source
                    let finalStatus = statusMap[category];
                    let finalNote = '';

                    // Si es FILE2 y estÃ¡ en pallet OK, cambiar estatus a "OK - NO WMS"
                    if (box.source === 'FILE2' && category === 'ok') {
                        finalStatus = 'OK - NO WMS';
                        finalNote = 'Estatus: NO WMS';
                    } else if (box.source === 'FILE2' && category === 'blocked') {
                        // Si es FILE2 y bloqueado, agregar nota tambiÃ©n
                        finalNote = 'Estatus: NO WMS';
                    }

                    // Si es PRIORIDAD, concatenar al estatus
                    if (box.isPriority) {
                        finalStatus = finalStatus + ' - PRIORIDAD';
                        finalNote = finalNote ? finalNote + ' | PRIORIDAD' : 'PRIORIDAD';
                    }

                    // Si estamos en modo ajuste, agregar nota de ediciÃ³n
                    if (window.ADJUSTMENT_MODE && window.ADJUSTMENT_MODE.active) {
                        finalNote = finalNote ? finalNote + ' | Informacion Editada' : 'Informacion Editada';
                    }

                    return {
                        _id: generateUUID(), // ID Ãºnico para el registro
                        _timestamp: generateTimestamp(), // Timestamp de creaciÃ³n
                        _status: 'pending', // Estado de sincronizaciÃ³n
                        date: dateStr,
                        time: timeStr,
                        user: CURRENT_USER || 'Usuario',
                        scan1: box.code || box.scan1,  // Usar cÃ³digo normalizado, con fallback
                        scan2: box.scan2 || '',
                        location: finalLocation,
                        status: finalStatus,
                        note: finalNote,
                        pallet: pallet.id,
                        originLocation: originLocation
                    };
                });

                // Add to history
                STATE.history = [...records, ...STATE.history].slice(0, 1000);

                // PROTECCIÃ“N: Marcar inicio de envÃ­o para evitar falsos positivos
                DeduplicationManager.startSending(pallet.id);

                try {
                    // DEDUPLICACIÃ“N: Verificar si el pallet ya fue sincronizado
                    const palletKey = DeduplicationManager.generatePalletKey(pallet.id, finalLocation);
                    if (DeduplicationManager.isPalletSynced(pallet.id, finalLocation)) {
                        console.warn(`âš ï¸ [DEDUP] Pallet ${pallet.id} ya fue sincronizado a ${finalLocation}. Generando nuevo ID.`);
                        // Generar nuevo ID de pallet para evitar conflicto
                        const prefixes = { ok: 'OK', blocked: 'BLK', nowms: 'NW' };
                        const newPalletId = generatePalletId(prefixes[category]);
                        records.forEach(r => r.pallet = newPalletId);
                        pallet.id = newPalletId;
                        showNotification(`âš ï¸ Pallet duplicado detectado. Nuevo ID: ${newPalletId}`, 'warning');
                    }

                    // Limpiar registros previos del mismo pallet en PENDING_SYNC (evita duplicados por reintentos)
                    PENDING_SYNC = PENDING_SYNC.filter(r => r.pallet !== pallet.id);

                    // DEDUPLICACIÃ“N: Filtrar registros duplicados antes de agregar (pasando el pallet actual)
                    const uniqueRecords = DeduplicationManager.filterDuplicateRecords(records, pallet.id);
                    
                    if (uniqueRecords.length === 0) {
                        console.warn('âš ï¸ [DEDUP] Todos los registros ya existen en PENDING_SYNC');
                        showNotification('âš ï¸ Registros duplicados - ya estÃ¡n pendientes de sincronizar', 'warning');
                        return;
                    }

                    // FASE 4: PROTOCOLO ATÃ“MICO - TRANSICIÃ“N draft â†’ pending
                    console.log('ðŸ”„ [ATOMIC] Iniciando transiciÃ³n draft â†’ pending...');
                    
                    // 1. MOVER CAJAS DE DRAFT A PENDING en IndexedDB (TRANSACCIÃ“N ATÃ“MICA)
                    try {
                        await PersistenceManager.moveToPending(uniqueRecords);
                        console.log(`âœ… [ATOMIC] ${uniqueRecords.length} registros movidos a PENDING en IndexedDB`);
                    } catch (error) {
                        console.error('âŒ [ATOMIC] Error moviendo a pending:', error);
                        showNotification('âŒ Error al procesar pallet. Intenta nuevamente.', 'error');
                        return;
                    }
                    
                    // 2. ACTUALIZAR PENDING_SYNC en RAM (sincronizado con IndexedDB)
                    PENDING_SYNC = await PersistenceManager.getPendingSync();
                    
                    // 3. LIMPIAR DRAFT_BOXES del pallet actual
                    await PersistenceManager.clearDraftBoxesByPallet(pallet.id);
                    
                    // 4. VALIDACIÃ“N DE CONECTIVIDAD
                    if (!IS_ONLINE) {
                        // Modo offline - datos YA estÃ¡n seguros en pending
                        console.log('ðŸ“´ [OFFLINE] Datos guardados en PENDING, se sincronizarÃ¡n cuando haya conexiÃ³n');
                        
                        // Reset pallet en RAM
                        const prefixes = { ok: 'OK', blocked: 'BLK', nowms: 'NW' };
                        STATE.pallets[category] = {
                            id: generatePalletId(prefixes[category]),
                            boxes: [],
                            location: ''
                        };
                        locationInput.value = '';
                        
                        updateUI();
                        playSound('success');
                        originLocationInput.focus();
                        originLocationInput.select();
                        
                        showNotification(`ðŸ’¾ Pallet guardado localmente: ${uniqueRecords.length} registros en cola (se sincronizarÃ¡n automÃ¡ticamente)`, 'info');
                        SyncManager.updateUI(false);
                        return;
                    }

                    // 5. VERIFICAR TOKEN DE GOOGLE
                    if (!gapi?.client?.getToken()) {
                        console.error('âŒ [AUTH] Token de Google no disponible');
                        showNotification(`âš ï¸ Pallet guardado en cola. Reconecta a Google para sincronizar (${PENDING_SYNC.length} pendientes).`, 'warning');
                        
                        // Reset pallet en RAM
                        const prefixes = { ok: 'OK', blocked: 'BLK', nowms: 'NW' };
                        STATE.pallets[category] = {
                            id: generatePalletId(prefixes[category]),
                            boxes: [],
                            location: ''
                        };
                        locationInput.value = '';
                        updateUI();
                        SyncManager.updateUI(false);
                        return;
                    }

                    // 6. SINCRONIZACIÃ“N CON TIMEOUT Y RETRY (datos YA estÃ¡n en pending)
                    let syncResult = { success: false, confirmed: false };
                    const maxRetries = 2;
                    let lastError = null;
                    
                    for (let attempt = 1; attempt <= maxRetries; attempt++) {
                        try {
                            console.log(`ðŸ”„ [ATOMIC] Intento ${attempt}/${maxRetries} - Sincronizando con timeout de 15s...`);
                            
                            if (attempt > 1) {
                                showNotification(`ðŸ”„ Reintentando conexiÃ³n con Google (intento ${attempt}/${maxRetries})...`, 'info');
                            }
                            
                            // Crear promesa con timeout de 15 segundos
                            const syncPromise = SyncManager.sync(false);
                            const timeoutPromise = new Promise((_, reject) => 
                                setTimeout(() => reject(new Error('Timeout: El servidor no respondiÃ³ en 15 segundos')), 15000)
                            );
                            
                            syncResult = await Promise.race([syncPromise, timeoutPromise]);
                            
                            // Si llegamos aquÃ­, la sincronizaciÃ³n fue exitosa
                            console.log(`âœ… [ATOMIC] SincronizaciÃ³n exitosa en intento ${attempt}`);
                            break; // Salir del loop de reintentos
                            
                        } catch (err) {
                            lastError = err;
                            console.error(`âŒ [ATOMIC] Error en intento ${attempt}:`, err);
                            
                            // Si es el Ãºltimo intento, procesar el error
                            if (attempt === maxRetries) {
                                // Determinar tipo de error con mensajes especÃ­ficos
                                let errorMessage = 'âŒ Error al enviar pallet: ';
                                
                                if (err.message?.includes('Timeout')) {
                                    errorMessage += 'El servidor no respondiÃ³ a tiempo. Verifica tu conexiÃ³n e intenta nuevamente.';
                                } else if (err.message?.includes('Invalid Credentials') || err.status === 401) {
                                    errorMessage = 'âŒ ConexiÃ³n perdida. Por favor, desconecta manualmente y vuelve a conectarte a Google para continuar.';
                                } else if (err.message?.includes('Network') || err.message?.includes('ERR_NETWORK_IO_SUSPENDED') || err.message?.includes('ERR_TIMED_OUT') || !navigator.onLine) {
                                    errorMessage = 'âŒ Problema de conexiÃ³n con Google. Verifica tu red e intenta nuevamente.';
                                } else {
                                    errorMessage += 'No se pudo confirmar con el servidor. Intenta nuevamente.';
                                }
                                
                                // CAPTURA CRÃTICA: Datos YA estÃ¡n seguros en IndexedDB (pending)
                                console.error('âŒ [CRITICAL-CAPTURE] SincronizaciÃ³n fallÃ³, datos seguros en PENDING');
                                
                                // Actualizar contador UI
                                SyncManager.updateUI(false);
                                
                                // Cerrar modal para desbloquear UI
                                document.body.classList.remove('blind-mode');
                                const popup = document.getElementById('send-validation-popup');
                                if (popup) popup.remove();
                                
                                // Reset pallet en RAM (datos estÃ¡n en pending, no se pierden)
                                const prefixes = { ok: 'OK', blocked: 'BLK', nowms: 'NW' };
                                STATE.pallets[category] = {
                                    id: generatePalletId(prefixes[category]),
                                    boxes: [],
                                    location: ''
                                };
                                locationInput.value = '';
                                updateUI();
                                
                                const pendingMsg = `${errorMessage}\n\nâœ… Tus datos estÃ¡n seguros en cola (${PENDING_SYNC.length} registros). Se sincronizarÃ¡n automÃ¡ticamente.`;
                                showNotification(pendingMsg, 'warning');
                                
                                console.log(`ðŸ’¾ [CRITICAL-CAPTURE] ${uniqueRecords.length} registros en PENDING (IndexedDB)`);
                                console.log(`ðŸ“Š [CRITICAL-CAPTURE] Total pendientes: ${PENDING_SYNC.length}`);
                                
                                playSound('warning');
                                return;
                            }
                            
                            // Esperar 2 segundos antes del siguiente reintento
                            if (attempt < maxRetries) {
                                await new Promise(resolve => setTimeout(resolve, 2000));
                            }
                        }
                    }

                    // 7. VALIDACIÃ“N ATÃ“MICA: Solo si HTTP 200 confirmado
                    if (syncResult.confirmed) {
                        console.log('âœ… [ATOMIC] TransiciÃ³n pending â†’ synced completada');
                        
                        // Agregar a historial local
                        STATE.history = [...records, ...STATE.history].slice(0, 1000);
                        
                        // Reset pallet (transacciÃ³n exitosa)
                        const prefixes = { ok: 'OK', blocked: 'BLK', nowms: 'NW' };
                        STATE.pallets[category] = {
                            id: generatePalletId(prefixes[category]),
                            boxes: [],
                            location: ''
                        };
                        locationInput.value = '';

                        saveToStorage();

                        if (typeof GlobalTabs !== 'undefined' && GlobalTabs.saveCurrentTabState) {
                            GlobalTabs.saveCurrentTabState();
                        }

                        if (typeof GlobalTabs !== 'undefined' && GlobalTabs.updateGlobalSummary) {
                            GlobalTabs.updateGlobalSummary();
                        }

                        updateUI();
                        playSound('success');

                        originLocationInput.focus();
                        originLocationInput.select();

                        showNotification(`âœ… Pallet enviado y confirmado: ${uniqueRecords.length} registros sincronizados`, 'success');
                    } else {
                        // âŒ FALLO: Datos permanecen en pending (se reintentarÃ¡n automÃ¡ticamente)
                        console.warn('âš ï¸ [ATOMIC] SincronizaciÃ³n fallÃ³, datos permanecen en PENDING');
                        
                        // Reset pallet en RAM (datos estÃ¡n seguros en pending)
                        const prefixes = { ok: 'OK', blocked: 'BLK', nowms: 'NW' };
                        STATE.pallets[category] = {
                            id: generatePalletId(prefixes[category]),
                            boxes: [],
                            location: ''
                        };
                        locationInput.value = '';
                        updateUI();
                        
                        showNotification(`âš ï¸ Pallet guardado en cola (${PENDING_SYNC.length} pendientes). Se sincronizarÃ¡ automÃ¡ticamente.`, 'warning');
                        SyncManager.updateUI(false);
                        return;
                    }

                    // If in adjustment mode, delete old records in background
                    if (window.ADJUSTMENT_MODE && window.ADJUSTMENT_MODE.active) {
                        const origPallet = window.ADJUSTMENT_MODE.originalPalletCode;
                        const origLocation = window.ADJUSTMENT_MODE.originalLocation;
                        
                        // Desactivar modo de ajuste y restaurar estado normal
                        deactivateAdjustmentMode();
                        
                        // Ejecutar en background
                        deleteOldPalletRecords(origPallet, origLocation).then(() => {
                            showNotification('âœ… Ajuste completado', 'success');
                        }).catch(err => {
                            console.warn('âš ï¸ Error eliminando registros antiguos:', err);
                        });
                    }
                } finally {
                    // PROTECCIÃ“N: Siempre marcar fin de envÃ­o y liberar flags
                    DeduplicationManager.endSending();
                    window.SENDING_IN_PROGRESS = false;
                    isSubmitting = false; // LIBERAR HARD BLOCK
                    console.log('ðŸ”“ [SEND] Flags liberados (SENDING_IN_PROGRESS + isSubmitting)');
                    
                    // REHABILITAR BOTÃ“N (si aÃºn existe)
                    if (confirmBtn && !confirmBtn.disabled) {
                        confirmBtn.disabled = false;
                        confirmBtn.textContent = 'ðŸ“¤ Confirmar EnvÃ­o';
                        confirmBtn.style.opacity = '1';
                        confirmBtn.style.cursor = 'pointer';
                    }
                }
            } catch (error) {
                console.error('âŒ [SEND] Error in confirmSendPallet:', error);
                console.error('âŒ [SEND] Stack:', error.stack);
                window.SENDING_IN_PROGRESS = false;
                isSubmitting = false; // LIBERAR HARD BLOCK
                
                // REHABILITAR BOTÃ“N en caso de error
                if (confirmBtn) {
                    confirmBtn.disabled = false;
                    confirmBtn.textContent = 'ðŸ“¤ Confirmar EnvÃ­o';
                    confirmBtn.style.opacity = '1';
                    confirmBtn.style.cursor = 'pointer';
                }
                
                showNotification('âŒ Error al enviar la tarima. Por favor, intente nuevamente.', 'error');
            }
        }

        async function deleteOldPalletRecords(palletCode, location) {
            try {
                // Get all data from the sheet
                const response = await gapi.client.sheets.spreadsheets.values.get({
                    spreadsheetId: CONFIG.SPREADSHEET_WRITE,
                    range: `${CONFIG.SHEET_NAME}!A:J`
                });

                const rows = response.result.values || [];
                const header = rows[0];
                
                // Find rows that match the pallet code and location (excluding header)
                const rowsToKeep = [header];
                let deletedCount = 0;

                for (let i = 1; i < rows.length; i++) {
                    const row = rows[i];
                    const rowPallet = row[8];
                    const rowLocation = row[5];
                    
                    // Keep rows that don't match the pallet being edited
                    if (rowPallet !== palletCode || !rowLocation || rowLocation.toUpperCase() !== location.toUpperCase()) {
                        rowsToKeep.push(row);
                    } else {
                        deletedCount++;
                    }
                }

                // Clear the sheet and write back only the rows we want to keep
                await gapi.client.sheets.spreadsheets.values.clear({
                    spreadsheetId: CONFIG.SPREADSHEET_WRITE,
                    range: `${CONFIG.SHEET_NAME}!A:J`
                });

                if (rowsToKeep.length > 0) {
                    await gapi.client.sheets.spreadsheets.values.update({
                        spreadsheetId: CONFIG.SPREADSHEET_WRITE,
                        range: `${CONFIG.SHEET_NAME}!A:J`,
                        valueInputOption: 'USER_ENTERED',
                        resource: { values: rowsToKeep }
                    });
                }

                console.log(`ðŸ—‘ï¸ Eliminados ${deletedCount} registros antiguos del pallet ${palletCode}`);
            } catch (error) {
                console.error('Error deleting old pallet records:', error);
                showNotification('âš ï¸ Error al eliminar registros antiguos', 'warning');
            }
        }

        // ==================== UI UPDATES ====================
        function updateUI() {
            updateCounts();
            updateLists();
            updateSidebar();
            updateSendButtons();
            updateGlobalCounter();
            updateVerificationBadges();
            GlobalTabs.updateGlobalSummary();
        }

        function updateGlobalCounter() {
            const total = STATE.pallets.ok.boxes.length +
                          STATE.pallets.blocked.boxes.length +
                          STATE.pallets.nowms.boxes.length;
            const counterEl = document.getElementById('global-box-count');
            if (counterEl) {
                counterEl.textContent = total;
            }
        }

        function updateCounts() {
            document.getElementById('ok-count').textContent = STATE.pallets.ok.boxes.length;
            document.getElementById('blocked-count').textContent = STATE.pallets.blocked.boxes.length;
            document.getElementById('nowms-count').textContent = STATE.pallets.nowms.boxes.length;

            document.getElementById('ok-pallet').textContent = STATE.pallets.ok.id;
            document.getElementById('blocked-pallet').textContent = STATE.pallets.blocked.id;
            document.getElementById('nowms-pallet').textContent = STATE.pallets.nowms.id;
        }

        function updateLists() {
            updateList('ok');
            updateList('blocked');
            updateList('nowms');
        }

        function updateList(category) {
            const listEl = document.getElementById(`${category}-list`);
            const boxes = STATE.pallets[category].boxes;

            if (boxes.length === 0) {
                listEl.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-icon">ðŸ“­</div>
                        <div>Sin cajas</div>
                    </div>
                `;
                return;
            }

            const originLoc = document.getElementById('origin-location').value.trim().toUpperCase() || '-';

            listEl.innerHTML = boxes.map((box, index) => {
                const isVerified = box.verified || false;
                const verifiedClass = isVerified ? 'verified' : '';

                // Solo mostrar check en columna OK
                const checkBtn = category === 'ok'
                    ? `<button class="box-action-btn check ${isVerified ? 'verified' : ''}" onclick="toggleBoxVerified('${category}', ${index})" title="Marcar verificado">
                         ${isVerified ? 'âœ“' : 'â—‹'}
                       </button>`
                    : '';

                // Source badge (dos niveles de bÃºsqueda)
                const source = box.source || 'WMS';
                const badgeText = source === 'WMS' ? 'OK' :
                                 source === 'FILE2' ? 'OK - NO WMS' : 'NO WMS';
                const sourceBadge = `<span class="inventory-badge badge-${source}">${badgeText}</span>`;

                // Priority badge (si es prioritario)
                const priorityBadge = box.isPriority ?
                    `<span class="priority-badge">ðŸ”´ PRIORIDAD</span>` : '';

                return `
                <div class="box-item ${verifiedClass}">
                    <div class="box-info">
                        <div class="box-code">${box.code}${box.scan2 ? ` / ${box.scan2}` : ''}${sourceBadge}${priorityBadge}</div>
                        <div class="box-meta">${box.location} â€¢ ${box.timestamp}</div>
                    </div>
                    <div class="box-actions">
                        <button class="box-action-btn copy" onclick="copyToClipboard('${box.code}')" title="Copiar cÃ³digo">â§‰</button>
                        <button class="box-action-btn copy" onclick="copyToClipboard('${box.location}')" title="Copiar ubicaciÃ³n BD">â—Ž</button>
                        ${checkBtn}
                        <button class="box-action-btn move" onclick="showMoveBoxPopup('${category}', ${index})" title="Mover a otro pallet">â‡„</button>
                        <button class="box-action-btn delete" onclick="deleteBox('${category}', ${index})" title="Eliminar">âœ•</button>
                    </div>
                </div>
            `}).join('');
        }

        // Toggle verificaciÃ³n de caja en OK
        function toggleBoxVerified(category, index) {
            if (category !== 'ok') return;
            STATE.pallets[category].boxes[index].verified = !STATE.pallets[category].boxes[index].verified;
            saveToStorage();
            updateUI();
        }

        // Copiar al portapapeles
        function copyToClipboard(text) {
            navigator.clipboard.writeText(text).then(() => {
                showNotification(`ðŸ“‹ Copiado: ${text}`, 'success');
            }).catch(() => {
                showNotification('âŒ Error al copiar', 'error');
            });
        }

        // Popup para mover caja entre pallets
        function showMoveBoxPopup(fromCategory, index) {
            const box = STATE.pallets[fromCategory].boxes[index];
            const categories = ['ok', 'blocked', 'nowms'].filter(c => c !== fromCategory);
            const categoryNames = { ok: 'OK âœ…', blocked: 'Bloqueado âš ï¸', nowms: 'No WMS âŒ' };

            const overlay = document.createElement('div');
            overlay.className = 'popup-overlay show';
            overlay.innerHTML = `
                <div class="popup-content" style="max-width: 350px;">
                    <div class="popup-header">
                        <span>â†”ï¸ Mover Caja</span>
                        <button class="popup-close" data-action="close">Ã—</button>
                    </div>
                    <p style="margin-bottom: 15px; font-size: 0.9em;">
                        <strong>CÃ³digo:</strong> <code>${box.code}</code><br>
                        <strong>Desde:</strong> ${categoryNames[fromCategory]}
                    </p>
                    <p style="margin-bottom: 10px; font-weight: 600;">Mover a:</p>
                    <div class="popup-buttons">
                        ${categories.map(cat => `
                            <button class="btn btn-${cat === 'ok' ? 'success' : cat === 'blocked' ? 'warning' : 'danger'} btn-full"
                                    data-action="move" data-category="${cat}">
                                ${categoryNames[cat]}
                            </button>
                        `).join('')}
                        <button class="btn btn-secondary btn-full" data-action="close">
                            Cancelar
                        </button>
                    </div>
                </div>
            `;
            document.body.appendChild(overlay);
            
            const closePopup = () => overlay.remove();
            
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) closePopup();
                if (e.target.dataset.action === 'close') closePopup();
                if (e.target.dataset.action === 'move') {
                    const targetCategory = e.target.dataset.category;
                    moveBox(fromCategory, index, targetCategory);
                    closePopup();
                }
            });
        }

        // Mover caja entre pallets
        function moveBox(fromCategory, index, toCategory) {
            const box = STATE.pallets[fromCategory].boxes.splice(index, 1)[0];
            box.verified = false; // Reset verificaciÃ³n al mover
            // Clonar el objeto para evitar referencias compartidas entre categorÃ­as
            STATE.pallets[toCategory].boxes.push(JSON.parse(JSON.stringify(box)));
            saveToStorage();
            updateUI();
            showNotification(`âœ… Caja movida a ${toCategory.toUpperCase()}`, 'success');
        }

        // ==================== MODAL DETALLE DE PALLET ====================
        let detailModalSort = { column: 'index', direction: 'asc' };
        let detailModalFilter = { code: '', location: '' };

        function showPalletDetailModal(category) {
            const pallet = STATE.pallets[category];
            const categoryNames = { ok: 'OK âœ…', blocked: 'Bloqueado âš ï¸', nowms: 'No WMS âŒ' };
            const categoryColors = { ok: 'var(--success)', blocked: 'var(--blocked)', nowms: 'var(--error)' };

            if (pallet.boxes.length === 0) {
                showNotification('âš ï¸ No hay cajas en esta tarima', 'warning');
                return;
            }

            const verifiedCount = category === 'ok' ? pallet.boxes.filter(b => b.verified).length : 0;
            const pendingCount = pallet.boxes.length - verifiedCount;

            const overlay = document.createElement('div');
            overlay.className = 'popup-overlay show';
            overlay.id = 'pallet-detail-modal';
            overlay.innerHTML = `
                <div class="popup-content pallet-detail-modal">
                    <div class="pallet-detail-header">
                        <div>
                            <span style="font-size: 1.2em; font-weight: 700; color: ${categoryColors[category]};">
                                ${categoryNames[category]} - ${pallet.id}
                            </span>
                            <span style="font-size: 0.9em; color: #666; margin-left: 10px;">${pallet.boxes.length} cajas</span>
                        </div>
                        <div style="display: flex; align-items: center; gap: 10px;">
                            ${category === 'ok' ? `
                                <div class="pallet-detail-counters">
                                    <span class="counter-badge ok">âœ“ ${verifiedCount}</span>
                                    <span class="counter-badge pending">â—‹ ${pendingCount}</span>
                                </div>
                            ` : ''}
                            <button class="btn btn-danger btn-small" onclick="clearAllPalletBoxes('${category}')"
                                    style="display: flex; align-items: center; gap: 6px; padding: 6px 12px;"
                                    title="Limpiar todos los registros de este pallet">
                                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <polyline points="3 6 5 6 21 6"></polyline>
                                    <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                                    <line x1="10" y1="11" x2="10" y2="17"></line>
                                    <line x1="14" y1="11" x2="14" y2="17"></line>
                                </svg>
                                Limpiar Todo
                            </button>
                            <button class="popup-close" data-action="close">Ã—</button>
                        </div>
                    </div>
                    <div class="pallet-detail-filters">
                        <input type="text" placeholder="ðŸ” Filtrar cÃ³digo..." id="detail-filter-code" onkeyup="filterDetailModal('${category}')">
                        <input type="text" placeholder="ðŸ“ Filtrar ubicaciÃ³n..." id="detail-filter-location" onkeyup="filterDetailModal('${category}')">
                        <button class="btn btn-small btn-secondary" onclick="clearDetailFilters('${category}')">Limpiar</button>
                    </div>
                    <div class="pallet-detail-table-container">
                        <table class="pallet-detail-table">
                            <thead>
                                <tr>
                                    <th onclick="sortDetailModal('${category}', 'index')"># â†•</th>
                                    <th onclick="sortDetailModal('${category}', 'code')">CÃ³digo â†•</th>
                                    <th onclick="sortDetailModal('${category}', 'scan2')">CÃ³digo 2 â†•</th>
                                    <th onclick="sortDetailModal('${category}', 'location')">UbicaciÃ³n â†•</th>
                                    <th onclick="sortDetailModal('${category}', 'timestamp')">Hora â†•</th>
                                    <th>Acciones</th>
                                </tr>
                            </thead>
                            <tbody id="detail-table-body"></tbody>
                        </table>
                    </div>
                </div>
            `;
            document.body.appendChild(overlay);
            renderDetailTable(category);
            
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay || e.target.dataset.action === 'close') {
                    overlay.remove();
                }
            });
        }

        function renderDetailTable(category) {
            const pallet = STATE.pallets[category];
            const tbody = document.getElementById('detail-table-body');
            if (!tbody) return;
            const originLoc = document.getElementById('origin-location').value.trim().toUpperCase() || '-';

            let filtered = pallet.boxes.map((box, index) => ({ ...box, originalIndex: index }));
            if (detailModalFilter.code) {
                const s = detailModalFilter.code.toUpperCase();
                filtered = filtered.filter(b => b.code.toUpperCase().includes(s) || (b.scan2 && b.scan2.toUpperCase().includes(s)));
            }
            if (detailModalFilter.location) {
                const s = detailModalFilter.location.toUpperCase();
                filtered = filtered.filter(b => b.location.toUpperCase().includes(s));
            }

            filtered.sort((a, b) => {
                let valA, valB;
                switch (detailModalSort.column) {
                    case 'code': valA = a.code; valB = b.code; break;
                    case 'scan2': valA = a.scan2 || ''; valB = b.scan2 || ''; break;
                    case 'location': valA = a.location; valB = b.location; break;
                    case 'timestamp': valA = a.timestamp; valB = b.timestamp; break;
                    default: valA = a.originalIndex; valB = b.originalIndex;
                }
                if (typeof valA === 'string') return detailModalSort.direction === 'asc' ? valA.localeCompare(valB) : valB.localeCompare(valA);
                return detailModalSort.direction === 'asc' ? valA - valB : valB - valA;
            });

            tbody.innerHTML = filtered.map((box, i) => {
                const verified = box.verified || false;
                const style = verified ? 'background: rgba(76, 175, 80, 0.1);' : '';
                const checkBtn = category === 'ok' ? `<button class="box-action-btn check ${verified ? 'verified' : ''}" onclick="toggleBoxVerifiedModal('${category}', ${box.originalIndex})">${verified ? 'âœ“' : 'â—‹'}</button>` : '';
                return `<tr style="${style}"><td>${i + 1}</td><td><code>${box.code}</code></td><td><code>${box.scan2 || '-'}</code></td><td>${box.location}</td><td>${box.timestamp}</td><td><button class="box-action-btn copy" onclick="copyToClipboard('${box.code}')">â§‰</button><button class="box-action-btn copy" onclick="copyToClipboard('${box.location}')">â—Ž</button>${checkBtn}<button class="box-action-btn move" onclick="showMoveBoxPopup('${category}', ${box.originalIndex}); document.getElementById('pallet-detail-modal')?.remove();">â‡„</button><button class="box-action-btn delete" onclick="deleteBoxModal('${category}', ${box.originalIndex})">âœ•</button></td></tr>`;
            }).join('');
        }

        function sortDetailModal(category, column) {
            if (detailModalSort.column === column) detailModalSort.direction = detailModalSort.direction === 'asc' ? 'desc' : 'asc';
            else { detailModalSort.column = column; detailModalSort.direction = 'asc'; }
            renderDetailTable(category);
        }

        function filterDetailModal(category) {
            detailModalFilter.code = document.getElementById('detail-filter-code')?.value || '';
            detailModalFilter.location = document.getElementById('detail-filter-location')?.value || '';
            renderDetailTable(category);
        }

        function clearDetailFilters(category) {
            document.getElementById('detail-filter-code').value = '';
            document.getElementById('detail-filter-location').value = '';
            detailModalFilter = { code: '', location: '' };
            renderDetailTable(category);
        }

        function toggleBoxVerifiedModal(category, index) {
            toggleBoxVerified(category, index);
            renderDetailTable(category);
            const pallet = STATE.pallets[category];
            const v = pallet.boxes.filter(b => b.verified).length;
            const p = pallet.boxes.length - v;
            const counters = document.querySelector('.pallet-detail-counters');
            if (counters) counters.innerHTML = `<span class="counter-badge ok">âœ“ ${v}</span><span class="counter-badge pending">â—‹ ${p}</span>`;
        }

        function deleteBoxModal(category, index) {
            if (confirm('Â¿Eliminar esta caja?')) {
                STATE.pallets[category].boxes.splice(index, 1);
                saveToStorage();
                updateUI();
                if (STATE.pallets[category].boxes.length === 0) {
                    document.getElementById('pallet-detail-modal')?.remove();
                    showNotification('Tarima vacÃ­a', 'info');
                } else {
                    renderDetailTable(category);
                    showNotification('Caja eliminada', 'info');
                }
            }
        }

        function clearAllPalletBoxes(category) {
            const pallet = STATE.pallets[category];
            const categoryNames = { ok: 'OK', blocked: 'Bloqueado', nowms: 'No WMS' };
            const boxCount = pallet.boxes.length;

            if (boxCount === 0) {
                showNotification('No hay cajas para eliminar', 'info');
                return;
            }

            // Primera confirmaciÃ³n
            const firstConfirm = confirm(
                `âš ï¸ ADVERTENCIA: ELIMINACIÃ“N MASIVA âš ï¸\n\n` +
                `EstÃ¡s a punto de ELIMINAR TODAS las cajas del pallet:\n\n` +
                `ðŸ“¦ Pallet: ${pallet.id}\n` +
                `ðŸ“Š CategorÃ­a: ${categoryNames[category]}\n` +
                `ðŸ”¢ Total de cajas: ${boxCount}\n\n` +
                `Esta acciÃ³n NO se puede deshacer.\n\n` +
                `Â¿EstÃ¡s SEGURO que deseas continuar?`
            );

            if (!firstConfirm) {
                return;
            }

            // Segunda confirmaciÃ³n (doble check)
            const secondConfirm = confirm(
                `â›” CONFIRMACIÃ“N FINAL â›”\n\n` +
                `Por favor confirma NUEVAMENTE que deseas ELIMINAR PERMANENTEMENTE:\n\n` +
                `${boxCount} cajas del pallet ${pallet.id}\n\n` +
                `Esta es tu Ãºltima oportunidad para cancelar.\n\n` +
                `Â¿CONFIRMAS la eliminaciÃ³n total?`
            );

            if (!secondConfirm) {
                showNotification('OperaciÃ³n cancelada', 'info');
                return;
            }

            // Realizar la limpieza
            console.log(`ðŸ—‘ï¸ Limpiando ${boxCount} cajas del pallet ${category} (${pallet.id})`);

            STATE.pallets[category].boxes = [];
            STATE.pallets[category].location = '';

            // Guardar estado
            saveToStorage();

            // CRÃTICO: Guardar estado en el tab si existe
            if (typeof GlobalTabs !== 'undefined' && GlobalTabs.saveCurrentTabState) {
                GlobalTabs.saveCurrentTabState();
            }

            // Actualizar tarjetas globales
            if (typeof GlobalTabs !== 'undefined' && GlobalTabs.updateGlobalSummary) {
                GlobalTabs.updateGlobalSummary();
            }

            // Actualizar UI
            updateUI();

            // Cerrar el modal
            document.getElementById('pallet-detail-modal')?.remove();

            // NotificaciÃ³n de Ã©xito
            showNotification(`âœ… ${boxCount} cajas eliminadas del pallet ${categoryNames[category]}`, 'success');
            playSound('success');

            console.log(`âœ… Limpieza completada. Pallet ${category} ahora tiene ${STATE.pallets[category].boxes.length} cajas`);
        }

        function updateVerificationBadges() {
            const pallet = STATE.pallets.ok;
            const v = pallet.boxes.filter(b => b.verified).length;
            const p = pallet.boxes.length - v;
            const vBadge = document.getElementById('ok-verified-badge');
            const pBadge = document.getElementById('ok-pending-badge');
            if (pallet.boxes.length > 0) {
                vBadge.style.display = v > 0 ? 'flex' : 'none';
                document.getElementById('ok-verified-count').textContent = v;
                pBadge.style.display = p > 0 ? 'flex' : 'none';
                document.getElementById('ok-pending-count').textContent = p;
            } else {
                vBadge.style.display = 'none';
                pBadge.style.display = 'none';
            }
        }

        function updateSidebar() {
            // These sidebar elements no longer exist - function kept for compatibility
            // The global summary is now updated by GlobalTabs.updateGlobalSummary()
            // If sidebar elements are added in the future, update them here with null checks
            const sidebarOkCount = document.getElementById('sidebar-ok-count');
            const sidebarBlockedCount = document.getElementById('sidebar-blocked-count');
            const sidebarNowmsCount = document.getElementById('sidebar-nowms-count');
            const sidebarOkPallet = document.getElementById('sidebar-ok-pallet');
            const sidebarBlockedPallet = document.getElementById('sidebar-blocked-pallet');
            const sidebarNowmsPallet = document.getElementById('sidebar-nowms-pallet');

            if (sidebarOkCount) sidebarOkCount.textContent = STATE.pallets.ok.boxes.length;
            if (sidebarBlockedCount) sidebarBlockedCount.textContent = STATE.pallets.blocked.boxes.length;
            if (sidebarNowmsCount) sidebarNowmsCount.textContent = STATE.pallets.nowms.boxes.length;
            if (sidebarOkPallet) sidebarOkPallet.textContent = STATE.pallets.ok.id;
            if (sidebarBlockedPallet) sidebarBlockedPallet.textContent = STATE.pallets.blocked.id;
            if (sidebarNowmsPallet) sidebarNowmsPallet.textContent = STATE.pallets.nowms.id;
        }

        function updateSendButtons() {
            try {
                const okBtn = document.getElementById('send-ok-btn');
                const blockedBtn = document.getElementById('send-blocked-btn');
                const nowmsBtn = document.getElementById('send-nowms-btn');

                // Validar que STATE.pallets existe y tiene estructura correcta
                if (!STATE || !STATE.pallets) {
                    console.warn('updateSendButtons: STATE.pallets no existe');
                    // Deshabilitar todos los botones si no hay datos
                    if (okBtn) okBtn.disabled = true;
                    if (blockedBtn) blockedBtn.disabled = true;
                    if (nowmsBtn) nowmsBtn.disabled = true;
                    return;
                }

                // Actualizar estado de cada botÃ³n
                const okBoxes = STATE.pallets.ok?.boxes?.length || 0;
                const blockedBoxes = STATE.pallets.blocked?.boxes?.length || 0;
                const nowmsBoxes = STATE.pallets.nowms?.boxes?.length || 0;

                // Obtener valores de ubicaciÃ³n
                const okLocation = (document.getElementById('location-ok')?.value || '').trim();
                const blockedLocation = (document.getElementById('location-blocked')?.value || '').trim();
                const nowmsLocation = (document.getElementById('location-nowms')?.value || '').trim();

                // BotÃ³n habilitado solo si hay cajas Y hay ubicaciÃ³n
                if (okBtn) okBtn.disabled = okBoxes === 0 || okLocation === '';
                if (blockedBtn) blockedBtn.disabled = blockedBoxes === 0 || blockedLocation === '';
                if (nowmsBtn) nowmsBtn.disabled = nowmsBoxes === 0 || nowmsLocation === '';

                console.log('updateSendButtons:', {
                    okBoxes, blockedBoxes, nowmsBoxes,
                    okLocation, blockedLocation, nowmsLocation
                });
            } catch (e) {
                console.error('Error en updateSendButtons:', e);
            }
        }

        // ==================== PALLET MANAGEMENT ====================
        function generatePalletId(prefix = 'PD') {
            const timestamp = Date.now().toString(36).toUpperCase();
            const random = Math.floor(Math.random() * 1000).toString().padStart(3, '0');
            return `${prefix}-${timestamp}-${random}`;
        }

        function newSession() {
            const total = STATE.pallets.ok.boxes.length +
                          STATE.pallets.blocked.boxes.length +
                          STATE.pallets.nowms.boxes.length;

            if (total > 0) {
                if (!confirm(`Hay ${total} cajas en las tarimas. Â¿Iniciar nueva sesiÃ³n sin enviar?`)) {
                    return;
                }
            }

            STATE.pallets = {
                ok: { id: generatePalletId('OK'), boxes: [], location: '' },
                blocked: { id: generatePalletId('BLK'), boxes: [], location: '' },
                nowms: { id: generatePalletId('NW'), boxes: [], location: '' }
            };
            STATE.pendingCode1 = null;

            document.getElementById('result-box').classList.remove('show');
            document.getElementById('code2-container').classList.remove('show');
            document.getElementById('location-ok').value = '';
            document.getElementById('location-blocked').value = '';
            document.getElementById('location-nowms').value = '';
            document.getElementById('origin-location').value = '';

            saveToStorage();
            updateUI();
            showNotification('âœ… Nueva sesiÃ³n iniciada', 'success');
            document.getElementById('origin-location').focus();
        }

        // ==================== RESUMEN MODULE ====================
        function showResumen() {
            updateResumen();
            document.getElementById('resumen-popup').classList.add('show');
        }

        function closeResumen() {
            document.getElementById('resumen-popup').classList.remove('show');
        }

        function updateResumen() {
            // Get counts from GlobalTabs for accurate totals across all tabs
            let totalOk = 0;
            let totalBlocked = 0;
            let totalNowms = 0;

            if (typeof GlobalTabs !== 'undefined' && GlobalTabs.tabs && GlobalTabs.tabs.length > 0) {
                GlobalTabs.tabs.forEach(tab => {
                    // Count from classic module
                    totalOk += tab.state.classic.pallets.ok.boxes.length;
                    totalBlocked += tab.state.classic.pallets.blocked.boxes.length;
                    totalNowms += tab.state.classic.pallets.nowms.boxes.length;

                    // Count from unified module
                    tab.state.unified.boxes.forEach(box => {
                        if (box.status === 'ok') totalOk++;
                        else if (box.status === 'blocked') totalBlocked++;
                        else if (box.status === 'nowms') totalNowms++;
                    });
                });
            } else {
                // Fallback: Contar desde STATE.pallets si GlobalTabs no estÃ¡ disponible
                totalOk = STATE.pallets.ok.boxes.length;
                totalBlocked = STATE.pallets.blocked.boxes.length;
                totalNowms = STATE.pallets.nowms.boxes.length;
            }

            document.getElementById('resumen-ok').textContent = totalOk;
            document.getElementById('resumen-blocked').textContent = totalBlocked;
            document.getElementById('resumen-nowms').textContent = totalNowms;
            document.getElementById('resumen-pending').textContent = PENDING_SYNC.length;

            // Update table
            const tbody = document.getElementById('resumen-table-body');
            const recentHistory = STATE.history.slice(0, 50);

            if (recentHistory.length === 0) {
                tbody.innerHTML = '<tr><td colspan="7" style="text-align: center; color: #999;">Sin registros recientes</td></tr>';
            } else {
                tbody.innerHTML = recentHistory.map(r => `
                    <tr>
                        <td>${r.date} ${r.time}</td>
                        <td><code>${r.scan1}</code></td>
                        <td><code>${r.scan2 || '-'}</code></td>
                        <td><span style="color: ${r.status === 'OK' ? 'var(--success)' : r.status === 'BLOQUEADO' ? 'var(--blocked)' : 'var(--error)'}">${r.status}</span></td>
                        <td>${r.location}</td>
                        <td>${r.originLocation || '-'}</td>
                        <td style="font-size: 0.8em;">${r.pallet}</td>
                    </tr>
                `).join('');
            }
        }

        // ==================== AJUSTE MODULE ====================
        function openAjusteModule() {
            closeResumen();
            document.getElementById('ajuste-popup').classList.add('show');
            document.getElementById('ajuste-location-search').focus();
        }

        function closeAjusteModule() {
            document.getElementById('ajuste-popup').classList.remove('show');
            document.getElementById('ajuste-results-container').innerHTML = `
                <div class="ajuste-empty-state">
                    ðŸ“¦ Ingresa una ubicaciÃ³n para buscar pallets
                </div>
            `;
        }

        async function searchPalletsByLocation() {
            const locationInput = document.getElementById('ajuste-location-search');
            const location = locationInput.value.trim().toUpperCase();

            if (!location) {
                showNotification('âš ï¸ Ingresa una ubicaciÃ³n', 'warning');
                return;
            }

            const resultsContainer = document.getElementById('ajuste-results-container');
            resultsContainer.innerHTML = '<div class="ajuste-empty-state">ðŸ”„ Buscando pallets...</div>';

            try {
                // Query the database for records matching the location
                const response = await gapi.client.sheets.spreadsheets.values.get({
                    spreadsheetId: CONFIG.SPREADSHEET_WRITE,
                    range: `${CONFIG.SHEET_NAME}!A:J`
                });

                const rows = response.result.values || [];
                
                // Filter rows by location (column F, index 5)
                const matchingRows = rows.filter((row, index) => {
                    if (index === 0) return false; // Skip header
                    return row[5] && row[5].toUpperCase() === location;
                });

                if (matchingRows.length === 0) {
                    resultsContainer.innerHTML = `
                        <div class="ajuste-empty-state">
                            âŒ No se encontraron pallets en la ubicaciÃ³n: <strong>${location}</strong>
                        </div>
                    `;
                    return;
                }

                // Group by pallet code (column I, index 8)
                const palletGroups = {};
                matchingRows.forEach(row => {
                    const palletCode = row[8] || 'SIN-PALLET';
                    if (!palletGroups[palletCode]) {
                        palletGroups[palletCode] = {
                            palletCode: palletCode,
                            boxes: [],
                            date: row[0],
                            time: row[1],
                            user: row[2],
                            location: row[5],
                            originLocation: row[9] || '-'
                        };
                    }
                    palletGroups[palletCode].boxes.push({
                        date: row[0],
                        time: row[1],
                        user: row[2],
                        scan1: row[3],
                        scan2: row[4],
                        location: row[5],
                        status: row[6],
                        note: row[7],
                        pallet: row[8],
                        originLocation: row[9] || ''
                    });
                });

                // Display pallet cards
                const palletCards = Object.values(palletGroups).map(group => `
                    <div class="ajuste-pallet-card" onclick="selectPalletForAdjustment('${group.palletCode}', '${location}')">
                        <div class="ajuste-pallet-header">
                            <div class="ajuste-pallet-code">${group.palletCode}</div>
                            <div class="ajuste-pallet-count">${group.boxes.length} cajas</div>
                        </div>
                        <div class="ajuste-pallet-info">
                            <div class="ajuste-pallet-info-row">
                                <span class="ajuste-pallet-label">ðŸ“… Fecha:</span>
                                <span>${group.date}</span>
                            </div>
                            <div class="ajuste-pallet-info-row">
                                <span class="ajuste-pallet-label">ðŸ• Hora:</span>
                                <span>${group.time}</span>
                            </div>
                            <div class="ajuste-pallet-info-row">
                                <span class="ajuste-pallet-label">ðŸ‘¤ Usuario:</span>
                                <span>${group.user}</span>
                            </div>
                            <div class="ajuste-pallet-info-row">
                                <span class="ajuste-pallet-label">ðŸ“ Origen:</span>
                                <span>${group.originLocation}</span>
                            </div>
                        </div>
                    </div>
                `).join('');

                resultsContainer.innerHTML = `
                    <h3 style="margin-bottom: 15px; font-size: 1em; color: #333;">
                        ðŸ“¦ Pallets encontrados en <strong>${location}</strong>: ${Object.keys(palletGroups).length}
                    </h3>
                    <div class="ajuste-pallets-grid">
                        ${palletCards}
                    </div>
                `;

            } catch (error) {
                console.error('Error searching pallets:', error);
                resultsContainer.innerHTML = `
                    <div class="ajuste-empty-state">
                        âŒ Error al buscar pallets: ${error.message}
                    </div>
                `;
                showNotification('âŒ Error al buscar pallets', 'error');
            }
        }

        // Modal de clave para acceso a ajustes
        function showAdjustmentPasswordModal() {
            return new Promise((resolve) => {
                const overlay = document.createElement('div');
                overlay.className = 'popup-overlay show';
                overlay.innerHTML = `
                    <div class="popup-content" style="max-width: 300px; padding: 0;">
                        <div style="padding: 12px 15px; background: #f5f5f5; border-bottom: 1px solid #ddd;">
                            <span style="font-weight: 600; font-size: 0.9em;">ðŸ” Acceso a Ajustes</span>
                        </div>
                        <div style="padding: 20px;">
                            <p style="font-size: 0.85em; color: #666; margin-bottom: 15px; text-align: center;">
                                Ingresa la clave de acceso para realizar ajustes
                            </p>
                            <input type="password" id="adjustment-password-input" 
                                   placeholder="â€¢â€¢â€¢â€¢â€¢â€¢" 
                                   style="width: 100%; padding: 12px; font-size: 1.1em; text-align: center; border: 2px solid #ddd; border-radius: 6px; letter-spacing: 4px;"
                                   autocomplete="off">
                            <div id="adjustment-password-error" style="color: #D32F2F; font-size: 0.8em; text-align: center; margin-top: 8px; display: none;">
                                âŒ Clave incorrecta
                            </div>
                            <div style="display: flex; gap: 8px; margin-top: 15px;">
                                <button class="btn btn-secondary" data-action="cancel" style="flex: 1; padding: 10px;">Cancelar</button>
                                <button class="btn btn-primary" data-action="confirm" style="flex: 1; padding: 10px;">Confirmar</button>
                            </div>
                        </div>
                    </div>
                `;
                document.body.appendChild(overlay);

                const passwordInput = overlay.querySelector('#adjustment-password-input');
                const errorDiv = overlay.querySelector('#adjustment-password-error');
                
                const closeModal = (result) => {
                    overlay.remove();
                    resolve(result);
                };

                const validatePassword = () => {
                    const password = passwordInput.value;
                    if (password === 'up2026') {
                        closeModal(true);
                    } else {
                        errorDiv.style.display = 'block';
                        passwordInput.value = '';
                        passwordInput.focus();
                        passwordInput.style.borderColor = '#D32F2F';
                        setTimeout(() => {
                            passwordInput.style.borderColor = '#ddd';
                        }, 1000);
                    }
                };

                passwordInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        validatePassword();
                    }
                    if (e.key === 'Escape') {
                        closeModal(false);
                    }
                });

                overlay.addEventListener('click', (e) => {
                    if (e.target === overlay) closeModal(false);
                    if (e.target.dataset.action === 'cancel') closeModal(false);
                    if (e.target.dataset.action === 'confirm') validatePassword();
                });

                setTimeout(() => passwordInput.focus(), 100);
            });
        }

        async function selectPalletForAdjustment(palletCode, location) {
            // Solicitar clave de acceso para ajustes
            const accessGranted = await showAdjustmentPasswordModal();
            if (!accessGranted) {
                showNotification('âŒ Acceso denegado', 'error');
                return;
            }

            const confirmed = confirm(`Â¿Deseas hacer ajustes al pallet ${palletCode}?`);
            if (!confirmed) return;

            try {
                // Get all boxes for this pallet
                const response = await gapi.client.sheets.spreadsheets.values.get({
                    spreadsheetId: CONFIG.SPREADSHEET_WRITE,
                    range: `${CONFIG.SHEET_NAME}!A:J`
                });

                const rows = response.result.values || [];
                const palletBoxes = rows.filter((row, index) => {
                    if (index === 0) return false;
                    return row[8] === palletCode && row[5] && row[5].toUpperCase() === location.toUpperCase();
                });

                if (palletBoxes.length === 0) {
                    showNotification('âŒ No se encontraron cajas para este pallet', 'error');
                    return;
                }

                // Load boxes into the appropriate pallet sections
                closeAjusteModule();
                loadPalletForEditing(palletBoxes, palletCode, location);
                showNotification(`âœ… Pallet ${palletCode} cargado para ediciÃ³n`, 'success');

            } catch (error) {
                console.error('Error loading pallet:', error);
                showNotification('âŒ Error al cargar pallet', 'error');
            }
        }

        // FASE 6: Helper para desactivar modo de ajuste y restaurar estado normal
        function deactivateAdjustmentMode() {
            if (!window.ADJUSTMENT_MODE || !window.ADJUSTMENT_MODE.active) return;
            
            console.log('ðŸ”§ [AJUSTE] Desactivando modo de ajuste...');
            
            // Restaurar placeholder del input
            const scanInput = document.getElementById('scan-input');
            if (scanInput) {
                scanInput.placeholder = 'Escanea cÃ³digo de barras';
            }
            
            // Cerrar sesiÃ³n de ajuste en IndexedDB si existe
            if (window.ADJUSTMENT_MODE.sessionId) {
                PersistenceManager.saveSession({
                    id: window.ADJUSTMENT_MODE.sessionId,
                    closed: true,
                    closedAt: generateTimestamp()
                }).catch(err => console.warn('âš ï¸ Error cerrando sesiÃ³n de ajuste:', err));
            }
            
            // Desactivar flag global
            window.ADJUSTMENT_MODE = { active: false };
            
            console.log('âœ… [AJUSTE] Modo de ajuste desactivado');
        }

        // FASE 6: MÃ³dulo de Ajustes Corregido - Aislamiento y Datos Limpios
        async function loadPalletForEditing(boxes, palletCode, location) {
            try {
                // 1. VERIFICAR SI HAY SESIÃ“N ACTIVA CON DATOS NO GUARDADOS
                const hasUnsavedData = STATE.pallets.ok.boxes.length > 0 ||
                                      STATE.pallets.blocked.boxes.length > 0 ||
                                      STATE.pallets.nowms.boxes.length > 0;
                
                if (hasUnsavedData) {
                    const confirm = window.confirm('âš ï¸ Hay datos sin guardar en la sesiÃ³n actual. Â¿Deseas descartarlos y abrir el modo de ajuste?');
                    if (!confirm) {
                        showNotification('âŒ Modo de ajuste cancelado', 'info');
                        return;
                    }
                }

                // 2. LIMPIAR COMPLETAMENTE LAS SECCIONES (DATOS EN LIMPIO)
                STATE.pallets.ok.boxes = [];
                STATE.pallets.blocked.boxes = [];
                STATE.pallets.nowms.boxes = [];

                // 3. CREAR NUEVA SESIÃ“N DE AJUSTE AISLADA
                const adjustmentSessionId = `ADJUSTMENT_${generateUUID()}`;
                window.CURRENT_SESSION_ID = adjustmentSessionId;
                
                // Guardar sesiÃ³n de ajuste en IndexedDB
                await PersistenceManager.saveSession({
                    id: adjustmentSessionId,
                    createdAt: generateTimestamp(),
                    closed: false,
                    type: 'adjustment',
                    originalPallet: palletCode,
                    originalLocation: location,
                    palletIds: {
                        ok: palletCode,
                        blocked: palletCode,
                        nowms: palletCode
                    }
                });

                // 4. CARGAR CAJAS DEL PALLET A EDITAR
                const firstBox = boxes[0];
                const originLocation = firstBox[9] || '';

                // Clasificar cajas por status
                for (const row of boxes) {
                    const status = String(row[6] || '');
                    const box = {
                        code: row[3],
                        scan1: row[3],
                        scan2: row[4] || '',
                        location: row[5],
                        status: status,
                        note: row[7] || '',
                        originLocation: row[9] || '',
                        source: 'ADJUSTMENT',
                        isPriority: false,
                        verified: false,
                        _id: generateUUID(),
                        _timestamp: generateTimestamp(),
                        _status: 'draft',
                        _sessionId: adjustmentSessionId,
                        _category: status && typeof status === 'string' && status.includes('OK') && !status.includes('BLOQUEADO') ? 'ok' :
                                  status && typeof status === 'string' && status.includes('BLOQUEADO') ? 'blocked' : 'nowms',
                        _palletId: palletCode
                    };

                    // Guardar en IndexedDB inmediatamente
                    await PersistenceManager.saveDraftBox(box);

                    // Clasificar en RAM
                    const safeStatus = (status || '').toString();
                    if (safeStatus.includes('OK') && !safeStatus.includes('BLOQUEADO')) {
                        STATE.pallets.ok.boxes.push(box);
                    } else if (safeStatus.includes('BLOQUEADO')) {
                        STATE.pallets.blocked.boxes.push(box);
                    } else if (safeStatus.includes('NO WMS')) {
                        STATE.pallets.nowms.boxes.push(box);
                    }
                }

                // 5. CONFIGURAR IDs Y UBICACIONES
                STATE.pallets.ok.id = palletCode;
                STATE.pallets.blocked.id = palletCode;
                STATE.pallets.nowms.id = palletCode;

                document.getElementById('location-ok').value = location;
                document.getElementById('location-blocked').value = location;
                document.getElementById('location-nowms').value = location;
                document.getElementById('origin-location').value = originLocation;

                // 6. ACTIVAR MODO DE AJUSTE CON BLOQUEO
                window.ADJUSTMENT_MODE = {
                    active: true,
                    sessionId: adjustmentSessionId,
                    originalPalletCode: palletCode,
                    originalLocation: location,
                    originalBoxes: boxes,
                    locked: true // BLOQUEAR CREACIÃ“N DE OTRAS SECCIONES
                };

                updateUI();
                
                // 7. BLOQUEAR INTERFAZ PARA OTRAS SECCIONES
                const scanInput = document.getElementById('scan-input');
                if (scanInput) {
                    scanInput.placeholder = 'ðŸ”’ Modo Ajuste Activo - Solo esta secciÃ³n';
                }

                showNotification('ðŸ“ Modo de ajuste activado. Solo puedes editar este pallet. Otras secciones bloqueadas.', 'warning');
                console.log(`ðŸ”§ [AJUSTE] SesiÃ³n de ajuste creada: ${adjustmentSessionId}`);
                console.log(`ðŸ”§ [AJUSTE] Pallet: ${palletCode} | UbicaciÃ³n: ${location} | Cajas: ${boxes.length}`);
                
            } catch (error) {
                console.error('âŒ [AJUSTE] Error al cargar pallet para ediciÃ³n:', error);
                showNotification('âŒ Error al activar modo de ajuste', 'error');
                window.ADJUSTMENT_MODE = { active: false };
            }
        }

        // ==================== CONNECTION ====================
        function setupConnectionMonitor() {
            window.addEventListener('online', () => {
                IS_ONLINE = true;
                showConnectionBanner('online');
                updateConnectionIndicator();
                showNotification('âœ… ConexiÃ³n restaurada', 'success');
                
                // SINCRONIZACIÃ“N AUTOMÃTICA AGRESIVA al recuperar conexiÃ³n
                if (PENDING_SYNC.length > 0) {
                    console.log(`ðŸ”„ [AUTO-SYNC] ConexiÃ³n recuperada - Sincronizando ${PENDING_SYNC.length} registros pendientes...`);
                    showNotification(`ðŸ”„ Sincronizando ${PENDING_SYNC.length} registros pendientes...`, 'info');
                    
                    // Intentar sincronizaciÃ³n inmediata (sin esperar)
                    SyncManager.sync(true).then(result => {
                        if (result.success) {
                            console.log('âœ… [AUTO-SYNC] SincronizaciÃ³n automÃ¡tica completada');
                        } else {
                            console.warn('âš ï¸ [AUTO-SYNC] SincronizaciÃ³n automÃ¡tica fallÃ³, se reintentarÃ¡ en 30s');
                        }
                    }).catch(err => {
                        console.error('âŒ [AUTO-SYNC] Error en sincronizaciÃ³n automÃ¡tica:', err);
                    });
                } else {
                    console.log('âœ… [AUTO-SYNC] No hay registros pendientes para sincronizar');
                }
            });

            window.addEventListener('offline', () => {
                IS_ONLINE = false;
                showConnectionBanner('offline');
                updateConnectionIndicator();
                
                if (PENDING_SYNC.length > 0) {
                    showNotification(`âš ï¸ Sin conexiÃ³n - ${PENDING_SYNC.length} registros en cola`, 'warning');
                } else {
                    showNotification('âš ï¸ Sin conexiÃ³n - Modo offline', 'warning');
                }
            });

            updateConnectionIndicator();
        }

        function showConnectionBanner(status) {
            const banner = document.getElementById('connection-banner');
            banner.className = `connection-banner ${status}`;
            banner.textContent = status === 'online' ? 'âœ… ConexiÃ³n restaurada' :
                                 status === 'offline' ? 'âš ï¸ Sin conexiÃ³n a internet' :
                                 'ðŸ”„ Sincronizando...';
            if (status === 'online') {
                setTimeout(() => banner.style.display = 'none', 3000);
            }
        }

        // Actualizar Sync Status (UI Unificada) - Delegado a SyncQueue
        async function updateConnectionIndicator(syncing = false) {
            // Delegar actualizaciÃ³n al nuevo sistema SyncQueue
            if (typeof SyncQueue !== 'undefined' && SyncQueue.updateCounter) {
                await SyncQueue.updateCounter();
            }
        }

        function toggleConnection() {
            if (gapi?.client?.getToken()) {
                if (confirm('Â¿Desconectar de Google?')) {
                    google.accounts.oauth2.revoke(gapi.client.getToken().access_token);
                    gapi.client.setToken(null);
                    showNotification('Desconectado de Google', 'info');
                    updateConnectionIndicator();
                }
            } else {
                handleLogin();
            }
        }

        // ==================== STORAGE ====================
        async function loadFromStorage() {
            try {
                const saved = localStorage.getItem('pd_system_state');
                if (saved) {
                    const data = JSON.parse(saved);
                    // NO cargar inventory desde storage (se carga desde CSV)
                    STATE.inventoryLastUpdate = data.inventoryLastUpdate;
                    if (data.pallets) STATE.pallets = data.pallets;
                    STATE.history = data.history || [];
                    console.log('ðŸ“¦ Datos cargados desde localStorage:', {
                        pallets: STATE.pallets,
                        historyItems: STATE.history.length
                    });
                } else {
                    // Si localStorage estÃ¡ vacÃ­o, intentar recuperar de IndexedDB
                    console.log('âš ï¸ localStorage vacÃ­o, intentando recuperar de IndexedDB...');
                    const idbPallets = await loadPalletsFromIndexedDB();
                    if (idbPallets && (idbPallets.ok || idbPallets.blocked || idbPallets.nowms)) {
                        STATE.pallets = {
                            ok: idbPallets.ok || STATE.pallets.ok,
                            blocked: idbPallets.blocked || STATE.pallets.blocked,
                            nowms: idbPallets.nowms || STATE.pallets.nowms
                        };
                        console.log('âœ… Pallets recuperados de IndexedDB:', STATE.pallets);
                        // Guardar en localStorage para prÃ³xima vez
                        localStorage.setItem('pd_system_state', JSON.stringify({
                            pallets: STATE.pallets,
                            history: []
                        }));
                    }
                }
                updateBdInfo();
                // Actualizar botones de envÃ­o con delay para asegurar DOM listo
                setTimeout(() => {
                    updateSendButtons();
                    // IMPORTANTE: Actualizar tarjetas globales despuÃ©s de cargar desde storage
                    if (typeof GlobalTabs !== 'undefined' && GlobalTabs.updateGlobalSummary) {
                        GlobalTabs.updateGlobalSummary();
                    }
                }, 50);
            } catch (e) {
                console.error('Error loading from storage:', e);
                // Intentar recuperar de IndexedDB como Ãºltimo recurso
                try {
                    const idbPallets = await loadPalletsFromIndexedDB();
                    if (idbPallets) {
                        STATE.pallets = {
                            ok: idbPallets.ok || STATE.pallets.ok,
                            blocked: idbPallets.blocked || STATE.pallets.blocked,
                            nowms: idbPallets.nowms || STATE.pallets.nowms
                        };
                        console.log('âœ… Pallets recuperados de IndexedDB (fallback):', STATE.pallets);
                    }
                } catch (e2) {
                    console.error('âŒ Error recuperando de IndexedDB:', e2);
                }
            }
        }

        async function saveToStorage() {
            try {
                // NO guardar inventory completo (demasiado grande - 61k cÃ³digos)
                // El inventory se recarga desde CSV al iniciar sesiÃ³n
                const data = {
                    inventoryLastUpdate: STATE.inventoryLastUpdate,
                    pallets: STATE.pallets,
                    history: STATE.history.slice(0, 500)  // Reducido de 1000 a 500
                };
                localStorage.setItem('pd_system_state', JSON.stringify(data));
                
                // RESPALDO: Guardar pallets en IndexedDB para mayor seguridad
                savePalletsToIndexedDB(STATE.pallets);
            } catch (e) {
                console.error('Error saving to storage:', e);
                // Si falla, intentar guardar solo lo esencial
                try {
                    const minimalData = {
                        pallets: STATE.pallets
                    };
                    localStorage.setItem('pd_system_state', JSON.stringify(minimalData));
                    console.warn('âš ï¸ Guardado solo pallets (storage lleno)');
                    // Intentar respaldo en IndexedDB
                    savePalletsToIndexedDB(STATE.pallets);
                } catch (e2) {
                    console.error('âŒ Error crÃ­tico guardando estado mÃ­nimo:', e2);
                }
            }
        }

        // Guardar pallets en IndexedDB como respaldo
        function savePalletsToIndexedDB(pallets) {
            try {
                const request = indexedDB.open('PalletsBackupDB', 1);
                
                request.onupgradeneeded = (e) => {
                    const db = e.target.result;
                    if (!db.objectStoreNames.contains('pallets')) {
                        db.createObjectStore('pallets', { keyPath: 'key' });
                    }
                };
                
                request.onsuccess = (e) => {
                    const db = e.target.result;
                    const tx = db.transaction('pallets', 'readwrite');
                    const store = tx.objectStore('pallets');
                    
                    // Guardar cada categorÃ­a de pallet
                    store.put({ key: 'ok', data: pallets.ok });
                    store.put({ key: 'blocked', data: pallets.blocked });
                    store.put({ key: 'nowms', data: pallets.nowms });
                    store.put({ key: 'timestamp', data: new Date().toISOString() });
                    
                    tx.oncomplete = () => db.close();
                    tx.onerror = () => db.close();
                };
            } catch (e) {
                console.warn('âš ï¸ Error guardando respaldo en IndexedDB:', e);
            }
        }

        // Cargar pallets desde IndexedDB (respaldo)
        async function loadPalletsFromIndexedDB() {
            return new Promise((resolve) => {
                try {
                    const request = indexedDB.open('PalletsBackupDB', 1);
                    
                    request.onupgradeneeded = (e) => {
                        const db = e.target.result;
                        if (!db.objectStoreNames.contains('pallets')) {
                            db.createObjectStore('pallets', { keyPath: 'key' });
                        }
                    };
                    
                    request.onsuccess = (e) => {
                        const db = e.target.result;
                        const tx = db.transaction('pallets', 'readonly');
                        const store = tx.objectStore('pallets');
                        const getAll = store.getAll();
                        
                        getAll.onsuccess = () => {
                            db.close();
                            const results = getAll.result || [];
                            const pallets = {};
                            results.forEach(item => {
                                if (item.key !== 'timestamp') {
                                    pallets[item.key] = item.data;
                                }
                            });
                            resolve(pallets);
                        };
                        getAll.onerror = () => {
                            db.close();
                            resolve(null);
                        };
                    };
                    
                    request.onerror = () => resolve(null);
                } catch (e) {
                    resolve(null);
                }
            });
        }

        // ==================== EXPORT ====================
        function exportData() {
            if (STATE.history.length === 0) {
                showNotification('No hay datos para exportar', 'warning');
                return;
            }

            const headers = ['FECHA', 'HORA', 'RESPONSABLE', 'SCAN 1', 'SCAN 2', 'UBICACION DESTINO', 'ESTATUS', 'NOTA', 'PALLET', 'UBICACION FISICA ORIGEN'];
            const rows = STATE.history.map(r => [
                r.date, r.time, r.user, r.scan1, r.scan2, r.location, r.status, r.note, r.pallet, r.originLocation || ''
            ]);

            const csv = '\ufeff' + [
                headers.join(','),
                ...rows.map(r => r.map(c => `"${(c || '').toString().replace(/"/g, '""')}"`).join(','))
            ].join('\n');

            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = `inventario_${new Date().toISOString().slice(0, 10)}.csv`;
            link.click();

            showNotification('âœ… Datos exportados', 'success');
        }

        // ==================== UTILITIES ====================
        function showNotification(message, type = 'info') {
            const container = document.getElementById('notifications');
            const icons = { success: 'âœ…', error: 'âŒ', warning: 'âš ï¸', info: 'â„¹ï¸' };

            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.innerHTML = `<span style="margin-right: 8px;">${icons[type]}</span>${message}`;

            container.appendChild(notification);
            setTimeout(() => notification.remove(), 4000);
        }

        function playSound(type) {
            if (!audioCtx) return;

            try {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                gain.gain.setValueAtTime(0.3, audioCtx.currentTime);

                if (type === 'success') {
                    osc.frequency.setValueAtTime(880, audioCtx.currentTime);
                    osc.start();
                    osc.stop(audioCtx.currentTime + 0.15);
                } else if (type === 'error') {
                    osc.frequency.setValueAtTime(300, audioCtx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(150, audioCtx.currentTime + 0.3);
                    osc.start();
                    osc.stop(audioCtx.currentTime + 0.35);
                } else if (type === 'warning') {
                    osc.frequency.setValueAtTime(600, audioCtx.currentTime);
                    osc.start();
                    osc.stop(audioCtx.currentTime + 0.1);
                }
            } catch (e) {}
        }

        // ==================== GLOBAL TABS SYSTEM ====================
        const GlobalTabs = {
            MAX_TABS: 4,
            tabs: [],
            activeTabId: null,

            init() {
                // Load and validate tabs from storage
                this.loadFromStorage();

                // Ensure activeTabId is valid
                if (this.activeTabId && !this.tabs.find(t => t.id === this.activeTabId)) {
                    this.activeTabId = this.tabs.length > 0 ? this.tabs[0].id : null;
                }

                // Render tabs UI
                this.renderTabs();
                this.updateGlobalSummary();

                if (this.tabs.length === 0 || !this.activeTabId) {
                    // No tabs or no active tab - show welcome state
                    this.activeTabId = null;
                    this.showWelcomeScreen();
                } else {
                    // Has valid tabs - load active tab state and switch to its module
                    const activeTab = this.getActiveTab();
                    if (activeTab && activeTab.workType) {
                        this.loadTabState();
                        this.showModuleForTab(activeTab);
                    } else {
                        // Active tab is invalid - show welcome screen
                        this.showWelcomeScreen();
                    }
                }
            },

            showWelcomeScreen() {
                const classicModule = document.getElementById('classic-module');
                const unifiedModule = document.getElementById('unified-module');
                const welcomeState = document.getElementById('welcome-state');

                // Hide both modules
                if (classicModule) {
                    classicModule.classList.remove('module-visible');
                    classicModule.classList.add('module-hidden');
                }
                if (unifiedModule) {
                    unifiedModule.classList.remove('module-visible');
                    unifiedModule.classList.add('module-hidden');
                }
                // Show welcome state
                if (welcomeState) {
                    welcomeState.classList.remove('module-hidden');
                    welcomeState.classList.add('module-visible');
                }
            },

            showModuleForTab(tab) {
                // Validate tab and workType
                if (!tab) {
                    console.error('showModuleForTab: No tab provided');
                    this.showWelcomeScreen();
                    return;
                }

                const workType = tab.workType;
                if (workType !== 'unified' && workType !== 'classic') {
                    console.error('showModuleForTab: Invalid workType:', workType);
                    // Default to classic if invalid
                    tab.workType = 'classic';
                }

                const classicModule = document.getElementById('classic-module');
                const unifiedModule = document.getElementById('unified-module');
                const welcomeState = document.getElementById('welcome-state');

                // Always hide welcome state when showing a module
                if (welcomeState) {
                    welcomeState.classList.remove('module-visible');
                    welcomeState.classList.add('module-hidden');
                }

                // Force hide both modules first to ensure clean state
                if (classicModule) {
                    classicModule.classList.remove('module-visible');
                    classicModule.classList.add('module-hidden');
                }
                if (unifiedModule) {
                    unifiedModule.classList.remove('module-visible');
                    unifiedModule.classList.add('module-hidden');
                }

                // Now show the correct module
                if (tab.workType === 'unified') {
                    // Show unified module
                    if (unifiedModule) {
                        unifiedModule.classList.remove('module-hidden');
                        unifiedModule.classList.add('module-visible');
                    }
                    CURRENT_MODULE = 'unified';
                    // Initialize unified module after a small delay to ensure DOM is ready
                    setTimeout(() => {
                        UnifiedModule.init();
                        UnifiedModule.updateUI();
                    }, 10);
                } else {
                    // Show classic module
                    if (classicModule) {
                        classicModule.classList.remove('module-hidden');
                        classicModule.classList.add('module-visible');
                    }
                    CURRENT_MODULE = 'classic';
                    // Update classic UI after a small delay
                    setTimeout(() => {
                        updateUI();
                    }, 10);
                }

                localStorage.setItem('pd_current_module', CURRENT_MODULE);
            },

            generateTabId() {
                return 'TAB-' + Date.now().toString(36).toUpperCase() + '-' + Math.floor(Math.random() * 1000).toString().padStart(3, '0');
            },

            generatePalletId(prefix = 'PAL') {
                const timestamp = Date.now().toString(36).toUpperCase();
                const random = Math.floor(Math.random() * 1000).toString().padStart(3, '0');
                return `${prefix}-${timestamp}-${random}`;
            },

            createEmptyTabState() {
                return {
                    // Estado para mÃ³dulo Clasificar
                    classic: {
                        pallets: {
                            ok: { id: this.generatePalletId('OK'), boxes: [] },
                            blocked: { id: this.generatePalletId('BLK'), boxes: [] },
                            nowms: { id: this.generatePalletId('NWS'), boxes: [] }
                        },
                        originLocation: ''
                    },
                    // Estado para mÃ³dulo Unificado
                    unified: {
                        palletId: this.generatePalletId('UNI'),
                        boxes: [],
                        location: '',
                        originLocation: '',
                        canceladosMode: false
                    }
                };
            },

            createTab(workType = 'classic') {
                // Validate workType
                if (workType !== 'classic' && workType !== 'unified') {
                    console.error('createTab: Invalid workType:', workType, '- defaulting to classic');
                    workType = 'classic';
                }

                if (this.tabs.length >= this.MAX_TABS) {
                    showNotification(`âš ï¸ MÃ¡ximo ${this.MAX_TABS} pestaÃ±as permitidas`, 'warning');
                    return;
                }

                this.saveCurrentTabState();

                const tabId = this.generateTabId();
                const newTab = {
                    id: tabId,
                    name: `SesiÃ³n ${this.tabs.length + 1}`,
                    workType: workType,  // Store the work type (locked after creation)
                    state: this.createEmptyTabState(),
                    createdAt: new Date().toISOString()
                };

                // Add tab to array and set as active
                this.tabs.push(newTab);
                this.activeTabId = tabId;

                // IMPORTANTE: NO llamar a saveToStorage() aquÃ­ porque llamarÃ­a a saveCurrentTabState()
                // y sobrescribirÃ­a el estado vacÃ­o del nuevo tab con datos del STATE.pallets viejo
                // En su lugar, guardar directamente sin llamar a saveCurrentTabState()
                try {
                    localStorage.setItem('pd_global_tabs', JSON.stringify({
                        tabs: this.tabs,
                        activeTabId: this.activeTabId
                    }));
                } catch (e) {
                    console.error('Error saving tabs after creation:', e);
                }

                // Render tabs
                this.renderTabs();

                // Load the tab state (esto cargarÃ¡ el estado vacÃ­o del nuevo tab)
                this.loadTabState();

                // CRITICAL: Show the correct module for this tab
                // This must happen after everything else is set up
                this.showModuleForTab(newTab);

                // Focus the appropriate input
                if (workType === 'unified') {
                    setTimeout(() => document.getElementById('unified-scan-input')?.focus(), 100);
                } else {
                    setTimeout(() => document.getElementById('scan-input')?.focus(), 100);
                }

                const workTypeLabel = workType === 'classic' ? 'Clasificar' : 'Unificado';
                showNotification(`âœ… Nueva sesiÃ³n (${workTypeLabel}) creada`, 'success');
                this.updateGlobalSummary();
            },

            switchTab(tabId) {
                if (this.activeTabId === tabId) return;

                // Guardar estado actual antes de cambiar
                this.saveCurrentTabState();

                this.activeTabId = tabId;
                this.saveToStorage();
                this.renderTabs();
                this.loadTabState();

                // Show the correct module for the new active tab
                const tab = this.getActiveTab();
                if (tab) {
                    this.showModuleForTab(tab);
                    // Focus the appropriate input
                    if (tab.workType === 'unified') {
                        setTimeout(() => document.getElementById('unified-scan-input')?.focus(), 100);
                    } else {
                        setTimeout(() => document.getElementById('scan-input')?.focus(), 100);
                    }
                }
            },

            closeTab(tabId, event) {
                if (event) event.stopPropagation();

                const tab = this.tabs.find(t => t.id === tabId);
                if (!tab) return;

                // Deshabilitar modo ajuste al cerrar sesiÃ³n
                if (window.ADJUSTMENT_MODE && window.ADJUSTMENT_MODE.active) {
                    deactivateAdjustmentMode();
                    console.log('ðŸ”§ [AJUSTE] Modo ajuste deshabilitado por cierre de sesiÃ³n');
                }

                // Verificar si hay cajas sin enviar
                const classicBoxes = Object.values(tab.state.classic.pallets).reduce((sum, p) => sum + p.boxes.length, 0);
                const unifiedBoxes = tab.state.unified.boxes.length;
                const totalBoxes = classicBoxes + unifiedBoxes;

                if (totalBoxes > 0) {
                    if (!confirm(`âš ï¸ Esta sesiÃ³n tiene ${totalBoxes} cajas sin enviar. Â¿Cerrar de todos modos?`)) {
                        return;
                    }
                }

                this.tabs = this.tabs.filter(t => t.id !== tabId);

                if (this.activeTabId === tabId) {
                    this.activeTabId = this.tabs.length > 0 ? this.tabs[0].id : null;
                }

                this.saveToStorage();
                this.renderTabs();
                this.updateGlobalSummary();

                if (this.tabs.length === 0) {
                    // No more tabs - show welcome screen
                    this.showWelcomeScreen();
                } else if (this.activeTabId) {
                    // Switch to remaining tab
                    this.loadTabState();
                    const activeTab = this.getActiveTab();
                    if (activeTab) {
                        this.showModuleForTab(activeTab);
                    }
                }

                showNotification('SesiÃ³n cerrada', 'info');
            },

            getActiveTab() {
                return this.tabs.find(t => t.id === this.activeTabId);
            },

            saveCurrentTabState() {
                const tab = this.getActiveTab();
                if (!tab) return;

                // Guardar estado del mÃ³dulo Clasificar
                tab.state.classic.pallets = JSON.parse(JSON.stringify(STATE.pallets));
                tab.state.classic.originLocation = document.getElementById('origin-location')?.value || '';

                // Guardar ubicaciones de destino para cada columna
                tab.state.classic.pallets.ok.location = document.getElementById('location-ok')?.value || '';
                tab.state.classic.pallets.blocked.location = document.getElementById('location-blocked')?.value || '';
                tab.state.classic.pallets.nowms.location = document.getElementById('location-nowms')?.value || '';

                // Guardar estado del mÃ³dulo Unificado
                tab.state.unified.originLocation = document.getElementById('unified-origin-location')?.value || '';
                tab.state.unified.location = document.getElementById('unified-location')?.value || '';
            },

            loadTabState() {
                const tab = this.getActiveTab();
                if (!tab) {
                    console.warn('loadTabState: No active tab found');
                    return;
                }

                // Validate tab has proper state
                if (!tab.state || !tab.state.classic || !tab.state.unified) {
                    console.error('loadTabState: Tab has invalid state structure', tab.id);
                    return;
                }

                // Cargar estado del mÃ³dulo Clasificar
                STATE.pallets = JSON.parse(JSON.stringify(tab.state.classic.pallets));
                console.log('loadTabState: Loaded pallets:', {
                    ok: STATE.pallets.ok.boxes.length,
                    blocked: STATE.pallets.blocked.boxes.length,
                    nowms: STATE.pallets.nowms.boxes.length
                });

                const originInput = document.getElementById('origin-location');
                if (originInput) originInput.value = tab.state.classic.originLocation || '';

                // Cargar ubicaciones de destino para cada columna
                const locationOkInput = document.getElementById('location-ok');
                const locationBlockedInput = document.getElementById('location-blocked');
                const locationNowmsInput = document.getElementById('location-nowms');

                if (locationOkInput) locationOkInput.value = tab.state.classic.pallets.ok?.location || '';
                if (locationBlockedInput) locationBlockedInput.value = tab.state.classic.pallets.blocked?.location || '';
                if (locationNowmsInput) locationNowmsInput.value = tab.state.classic.pallets.nowms?.location || '';

                // Cargar estado del mÃ³dulo Unificado
                const unifiedOriginInput = document.getElementById('unified-origin-location');
                if (unifiedOriginInput) unifiedOriginInput.value = tab.state.unified.originLocation || '';
                const unifiedLocationInput = document.getElementById('unified-location');
                if (unifiedLocationInput) unifiedLocationInput.value = tab.state.unified.location || '';

                // Actualizar botones de envÃ­o despuÃ©s de cargar estado
                // No usar setTimeout aquÃ­ porque showModuleForTab() lo harÃ¡
                // pero agregamos esto como respaldo
                updateSendButtons();

                // IMPORTANTE: Actualizar tarjetas globales despuÃ©s de cargar el estado del tab
                this.updateGlobalSummary();
            },

            renderTabs() {
                const container = document.getElementById('global-tabs-container');
                if (!container) return;

                container.innerHTML = '';

                // Renderizar pestaÃ±as existentes
                this.tabs.forEach((tab, index) => {
                    const classicBoxes = Object.values(tab.state.classic.pallets).reduce((sum, p) => sum + p.boxes.length, 0);
                    const unifiedBoxes = tab.state.unified.boxes.length;
                    const totalBoxes = classicBoxes + unifiedBoxes;
                    const workTypeIcon = tab.workType === 'unified' ? 'ðŸ“¦' : 'ðŸ“‹';
                    const workTypeLabel = tab.workType === 'unified' ? 'Uni' : 'Clas';

                    const tabEl = document.createElement('div');
                    tabEl.className = `unified-tab ${tab.id === this.activeTabId ? 'active' : ''}`;
                    tabEl.onclick = () => this.switchTab(tab.id);
                    tabEl.innerHTML = `
                        <span>${workTypeIcon} S${index + 1}</span>
                        <span class="tab-count">${totalBoxes}</span>
                        <button class="tab-close" onclick="GlobalTabs.closeTab('${tab.id}', event)">Ã—</button>
                    `;
                    container.appendChild(tabEl);
                });

                // BotÃ³n nuevo - shows work type popup
                const newBtnEl = document.createElement('button');
                newBtnEl.className = 'unified-tab-new';
                newBtnEl.onclick = () => showWorkTypePopup();
                newBtnEl.disabled = this.tabs.length >= this.MAX_TABS;
                newBtnEl.innerHTML = 'âž• Nuevo';
                container.appendChild(newBtnEl);
            },

            saveToStorage() {
                this.saveCurrentTabState();
                try {
                    localStorage.setItem('pd_global_tabs', JSON.stringify({
                        tabs: this.tabs,
                        activeTabId: this.activeTabId
                    }));
                } catch (e) {
                    console.error('Error saving global tabs:', e);
                }
            },

            loadFromStorage() {
                try {
                    const saved = localStorage.getItem('pd_global_tabs');
                    if (saved) {
                        const data = JSON.parse(saved);
                        const originalCount = (data.tabs || []).length;

                        // Validate tabs - only keep tabs with valid structure
                        this.tabs = (data.tabs || []).filter(tab => {
                            // Basic validation
                            if (!tab || !tab.id || !tab.workType || !tab.state) {
                                console.warn('Tab rejected - missing basic properties:', tab?.id);
                                return false;
                            }

                            // Validate workType
                            if (tab.workType !== 'classic' && tab.workType !== 'unified') {
                                console.warn('Tab rejected - invalid workType:', tab.id, tab.workType);
                                return false;
                            }

                            // Validate state structure
                            if (!tab.state.classic || !tab.state.unified) {
                                console.warn('Tab rejected - invalid state structure:', tab.id);
                                return false;
                            }

                            // Validate classic state
                            if (!tab.state.classic.pallets) {
                                console.warn('Tab rejected - missing classic pallets:', tab.id);
                                return false;
                            }

                            // Validate unified state
                            if (!Array.isArray(tab.state.unified.boxes)) {
                                console.warn('Tab rejected - invalid unified boxes:', tab.id);
                                return false;
                            }

                            return true;
                        });

                        // Set active tab ID
                        this.activeTabId = this.tabs.length > 0 ?
                            (this.tabs.find(t => t.id === data.activeTabId) ? data.activeTabId : this.tabs[0].id) :
                            null;

                        // Save cleaned data back if any tabs were removed
                        if (this.tabs.length !== originalCount) {
                            console.log(`Cleaned ${originalCount - this.tabs.length} invalid tabs`);
                            this.saveToStorage();
                        }
                    }
                } catch (e) {
                    console.error('Error loading global tabs:', e);
                    this.tabs = [];
                    this.activeTabId = null;
                    localStorage.removeItem('pd_global_tabs');
                }
            },

            getTotalBoxCount() {
                const tab = this.getActiveTab();
                if (!tab) return 0;
                const classicBoxes = Object.values(tab.state.classic.pallets).reduce((sum, p) => sum + p.boxes.length, 0);
                const unifiedBoxes = tab.state.unified.boxes.length;
                return classicBoxes + unifiedBoxes;
            },

            // Update global summary across all tabs
            updateGlobalSummary() {
                let totalOk = 0;
                let totalBlocked = 0;
                let totalNowms = 0;

                console.log('ðŸ”„ Actualizando resumen global. Tabs:', this.tabs.length);

                this.tabs.forEach((tab, idx) => {
                    // Count from classic module
                    const classicOk = tab.state.classic.pallets.ok.boxes.length;
                    const classicBlocked = tab.state.classic.pallets.blocked.boxes.length;
                    const classicNowms = tab.state.classic.pallets.nowms.boxes.length;

                    totalOk += classicOk;
                    totalBlocked += classicBlocked;
                    totalNowms += classicNowms;

                    // Count from unified module
                    let unifiedOk = 0;
                    let unifiedBlocked = 0;
                    let unifiedNowms = 0;

                    tab.state.unified.boxes.forEach(box => {
                        if (box.status === 'ok') unifiedOk++;
                        else if (box.status === 'blocked') unifiedBlocked++;
                        else if (box.status === 'nowms') unifiedNowms++;
                    });

                    totalOk += unifiedOk;
                    totalBlocked += unifiedBlocked;
                    totalNowms += unifiedNowms;

                    console.log(`  Tab ${idx} (${tab.name}):`, {
                        classic: { ok: classicOk, blocked: classicBlocked, nowms: classicNowms },
                        unified: { ok: unifiedOk, blocked: unifiedBlocked, nowms: unifiedNowms }
                    });
                });

                const total = totalOk + totalBlocked + totalNowms;

                console.log('ðŸ“Š Totales calculados:', { ok: totalOk, blocked: totalBlocked, nowms: totalNowms, total });

                // Update sidebar summary
                const okEl = document.getElementById('global-summary-ok');
                const blockedEl = document.getElementById('global-summary-blocked');
                const nowmsEl = document.getElementById('global-summary-nowms');
                const totalEl = document.getElementById('global-summary-total');

                console.log('ðŸŽ¯ Elementos DOM encontrados:', {
                    okEl: !!okEl,
                    blockedEl: !!blockedEl,
                    nowmsEl: !!nowmsEl,
                    totalEl: !!totalEl
                });

                if (okEl) okEl.textContent = totalOk;
                if (blockedEl) blockedEl.textContent = totalBlocked;
                if (nowmsEl) nowmsEl.textContent = totalNowms;
                if (totalEl) totalEl.textContent = total;

                // Also update the global box count in the main interface
                const globalBoxCountEl = document.getElementById('global-box-count');
                if (globalBoxCountEl) globalBoxCountEl.textContent = total;

                console.log('âœ… Resumen global actualizado');
            }
        };

        // ==================== WORK TYPE POPUP ====================
        // Global variable to store selected work type (more reliable than DOM property)
        let PENDING_WORK_TYPE = null;

        function showWorkTypePopup() {
            if (GlobalTabs.tabs.length >= GlobalTabs.MAX_TABS) {
                showNotification(`âš ï¸ MÃ¡ximo ${GlobalTabs.MAX_TABS} pestaÃ±as permitidas`, 'warning');
                return;
            }

            // Reset pending work type
            PENDING_WORK_TYPE = null;

            const overlay = document.createElement('div');
            overlay.className = 'popup-overlay show';
            overlay.id = 'work-type-popup';
            overlay.innerHTML = `
                <div class="popup-content work-type-popup">
                    <div class="popup-header">
                        <span>ðŸ†• Nueva SesiÃ³n</span>
                        <button class="popup-close" onclick="closeWorkTypePopup()">Ã—</button>
                    </div>

                    <!-- Professional Toggle Button -->
                    <div class="work-type-toggle-container">
                        <button class="work-type-toggle-btn" id="toggle-classic" onclick="selectWorkType('classic')">
                            <span class="toggle-icon">ðŸ“‹</span>
                            Clasificar
                        </button>
                        <button class="work-type-toggle-btn" id="toggle-unified" disabled style="opacity: 0.6; cursor: not-allowed;" title="OpciÃ³n deshabilitada">
                            <span class="toggle-icon">ðŸ“¦</span>
                            Unificado (Deshabilitado)
                        </button>
                    </div>

                    <!-- Dynamic Description -->
                    <div class="work-type-description" id="work-type-description">
                        <div class="work-type-description-title" id="work-type-desc-title">
                            ðŸ‘† Selecciona un modo
                        </div>
                        <div class="work-type-description-text" id="work-type-desc-text">
                            Elige el tipo de trabajo que realizarÃ¡s en esta sesiÃ³n.
                        </div>
                    </div>

                    <div class="work-type-locked">
                        ðŸ”’ El modo se bloquea al crear la sesiÃ³n
                    </div>

                    <button class="work-type-confirm-btn" id="confirm-work-type-btn" disabled onclick="confirmWorkType()">
                        âœ… Crear SesiÃ³n
                    </button>
                </div>
            `;
            document.body.appendChild(overlay);

            // Close on backdrop click
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) closeWorkTypePopup();
            });
        }

        function closeWorkTypePopup() {
            PENDING_WORK_TYPE = null;
            const popup = document.getElementById('work-type-popup');
            if (popup) popup.remove();
        }

        const workTypeDescriptions = {
            classic: {
                title: 'ðŸ“‹ Modo Clasificar',
                text: 'Separa automÃ¡ticamente las cajas en 3 tarimas segÃºn su estado: OK, Bloqueado y No WMS. Ideal para reorganizar inventario por condiciÃ³n.'
            },
            unified: {
                title: 'ðŸ“¦ Modo Unificado',
                text: 'Agrupa todas las cajas en una sola tarima con estados mixtos. Registra el estado pero las mantiene juntas. Ideal para inventarios rÃ¡pidos.'
            }
        };

        function selectWorkType(type) {
            // Prevent selecting unified type
            if (type === 'unified') {
                showNotification('La opciÃ³n de escaneo unificado estÃ¡ deshabilitada actualmente', 'warning');
                return;
            }
            
            const popup = document.getElementById('work-type-popup');
            if (!popup) return;

            // Validate type
            if (type !== 'classic' && type !== 'unified') {
                console.error('Invalid work type:', type);
                return;
            }

            // Update toggle buttons
            const classicBtn = document.getElementById('toggle-classic');
            const unifiedBtn = document.getElementById('toggle-unified');
            if (classicBtn) classicBtn.classList.toggle('active', type === 'classic');
            if (unifiedBtn) unifiedBtn.classList.toggle('active', type === 'unified');

            // Update description
            const desc = workTypeDescriptions[type];
            const titleEl = document.getElementById('work-type-desc-title');
            const textEl = document.getElementById('work-type-desc-text');
            if (titleEl) titleEl.textContent = desc.title;
            if (textEl) textEl.textContent = desc.text;

            // Store selection in global variable
            PENDING_WORK_TYPE = type;

            // Enable confirm button
            const confirmBtn = document.getElementById('confirm-work-type-btn');
            if (confirmBtn) confirmBtn.disabled = false;
        }

        function confirmWorkType() {
            // Use the global variable
            if (!PENDING_WORK_TYPE) {
                showNotification('Por favor selecciona un modo de trabajo', 'warning');
                return;
            }

            // Only allow 'classic' work type
            if (PENDING_WORK_TYPE !== 'classic') {
                showNotification('Solo el modo de trabajo "Clasificar" estÃ¡ disponible actualmente', 'warning');
                return;
            }

            const workType = PENDING_WORK_TYPE;

            // Close popup first
            const popup = document.getElementById('work-type-popup');
            if (popup) popup.remove();

            // Reset global variable
            PENDING_WORK_TYPE = null;

            // Create tab with the selected work type
            GlobalTabs.createTab(workType);
        }

        // ==================== MODULE SWITCHING ====================
        let CURRENT_MODULE = 'classic';

        function switchModule(module, fromTabSwitch = false) {
            // Check if the current tab has a locked work type
            const activeTab = GlobalTabs.getActiveTab();
            if (activeTab && activeTab.workType && !fromTabSwitch) {
                // If user tries to switch modules manually but tab is locked
                if (activeTab.workType !== module) {
                    const lockedType = activeTab.workType === 'classic' ? 'Clasificar' : 'Unificado';
                    showNotification(`ðŸ”’ Esta sesiÃ³n estÃ¡ bloqueada como "${lockedType}"`, 'warning');
                    return;
                }
            }

            CURRENT_MODULE = module;

            const classicModule = document.getElementById('classic-module');
            const unifiedModule = document.getElementById('unified-module');
            const welcomeState = document.getElementById('welcome-state');

            // Hide welcome state using CSS classes
            if (welcomeState) {
                welcomeState.classList.remove('module-visible');
                welcomeState.classList.add('module-hidden');
            }

            // Guardar estado de la pestaÃ±a actual antes de cambiar
            GlobalTabs.saveCurrentTabState();

            if (module === 'classic') {
                // Mostrar clÃ¡sico, ocultar unificado
                if (classicModule) {
                    classicModule.classList.remove('module-hidden');
                    classicModule.classList.add('module-visible');
                }
                if (unifiedModule) {
                    unifiedModule.classList.remove('module-visible');
                    unifiedModule.classList.add('module-hidden');
                }
                setTimeout(() => document.getElementById('scan-input')?.focus(), 100);
            } else {
                // Mostrar unificado, ocultar clÃ¡sico
                if (classicModule) {
                    classicModule.classList.remove('module-visible');
                    classicModule.classList.add('module-hidden');
                }
                if (unifiedModule) {
                    unifiedModule.classList.remove('module-hidden');
                    unifiedModule.classList.add('module-visible');
                }
                UnifiedModule.init();
                setTimeout(() => document.getElementById('unified-scan-input')?.focus(), 100);
            }

            localStorage.setItem('pd_current_module', module);
            GlobalTabs.renderTabs();
        }


        // ==================== UNIFIED CAPTURE MODULE ====================
        const UnifiedModule = {
            pendingCode1: null,

            init() {
                this.setupEventListeners();
                this.syncCanceladosUI();
                this.updateUI();
            },

            // Sync checkbox state with tab state
            syncCanceladosUI() {
                const tab = this.getActiveTab();
                const checkbox = document.getElementById('unified-cancelados-check');
                const toggleLabel = document.getElementById('cancelados-toggle-label');

                if (checkbox && tab) {
                    const isCancelados = tab.canceladosMode || false;
                    checkbox.checked = isCancelados;
                    if (toggleLabel) {
                        toggleLabel.classList.toggle('active', isCancelados);
                    }
                }
            },

            // Toggle Cancelados mode
            toggleCancelados(isChecked) {
                const tab = this.getActiveTab();
                if (!tab) return;

                // Save to tab state
                tab.canceladosMode = isChecked;
                GlobalTabs.saveToStorage();

                // Update toggle label style
                const toggleLabel = document.getElementById('cancelados-toggle-label');
                if (toggleLabel) {
                    toggleLabel.classList.toggle('active', isChecked);
                }

                // Update the list to show/hide badges
                this.renderBoxList();

                // Show notification
                if (isChecked) {
                    showNotification('ðŸš« Modo CANCELADOS activado - Los cÃ³digos se registrarÃ¡n como cancelados', 'warning');
                } else {
                    showNotification('âœ… Modo normal activado', 'success');
                }
            },

            // Check if cancelados mode is active
            isCanceladosMode() {
                const tab = this.getActiveTab();
                return tab ? (tab.canceladosMode || false) : false;
            },

            setupEventListeners() {
                const scanInput = document.getElementById('unified-scan-input');
                const code2Input = document.getElementById('unified-code2-input');

                if (!scanInput || !code2Input) return;

                scanInput.onkeydown = (e) => {
                    if (e.key === 'Enter' && scanInput.value.trim()) {
                        e.preventDefault();
                        this.processScan(scanInput.value.trim());
                        scanInput.value = '';
                    }
                };

                code2Input.onkeydown = (e) => {
                    if (e.key === 'Enter' && code2Input.value.trim()) {
                        e.preventDefault();
                        this.processCode2(code2Input.value.trim());
                        code2Input.value = '';
                    }
                };
            },

            generatePalletId() {
                const timestamp = Date.now().toString(36).toUpperCase();
                const random = Math.floor(Math.random() * 1000).toString().padStart(3, '0');
                return `UNI-${timestamp}-${random}`;
            },

            getActiveTab() {
                const tab = GlobalTabs.getActiveTab();
                return tab ? tab.state.unified : null;
            },

            async processScan(rawCode) {
                const tab = this.getActiveTab();
                if (!tab) {
                    showNotification('âš ï¸ No hay sesiÃ³n activa', 'warning');
                    return;
                }

                // BÃºsqueda de dos niveles: WMS + FILE2
                const result = await findCodeInInventoryTwoLevel(rawCode);
                const code = result.code;
                const item = result.item;
                const source = result.source;

                // VALIDACIÃ“N DE PRIORIDAD (en paralelo)
                const priorityCheck = await checkIfPriority(rawCode);
                const isPriority = priorityCheck.isPriority;

                // Check duplicates across ALL tabs (global detection)
                const duplicateInfo = this.findDuplicateGlobal(code);
                if (duplicateInfo) {
                    this.showDuplicatePopupGlobal(code, rawCode, duplicateInfo);
                    this.flashInput('warning');
                    playSound('warning');
                    return;
                }

                if (!item) {
                    // Not found in both levels - show Code2 input
                    // PROTECCIÃ“N: Si ya hay un pendingCode1, advertir al usuario
                    if (this.pendingCode1 && this.pendingCode1.code !== code) {
                        const userConfirm = confirm(
                            `âš ï¸ Ya tienes un cÃ³digo pendiente: ${this.pendingCode1.code}\n\n` +
                            `Â¿Deseas cancelar el cÃ³digo anterior y usar el nuevo cÃ³digo: ${code}?`
                        );
                        if (!userConfirm) {
                            this.flashInput('warning');
                            playSound('warning');
                            // Mantener el foco en code2-input para continuar con el cÃ³digo anterior
                            setTimeout(() => document.getElementById('unified-code2-input').focus(), 100);
                            return;
                        }
                    }

                    this.pendingCode1 = { raw: rawCode, code, isPriority };
                    this.showResultBox('error', code, 'NO ENCONTRADO',
                        'CÃ³digo no encontrado en WMS ni Archivo 2. Ingresa CÃ³digo 2 o usa INSERTADO.', null);
                    document.getElementById('unified-code2-container').classList.add('show');
                    this.flashInput('error');
                    playSound('error');
                    setTimeout(() => document.getElementById('unified-code2-input').focus(), 100);
                    return;
                }

                // Hide code2 container
                document.getElementById('unified-code2-container').classList.remove('show');
                this.pendingCode1 = null;

                // MOSTRAR ALERTA SI ES PRIORIDAD
                if (isPriority) {
                    showPriorityAlert(code);
                }

                // Determine status and add to pallet
                let status;
                if (item.isBlocked) {
                    status = 'blocked';
                    this.showResultBox('blocked', code, 'BLOQUEADO', 'Inventario bloqueado', item);
                    playSound('warning');
                } else if (item.isAvailable) {
                    status = 'ok';
                    const statusMsg = source === 'FILE2' ? 'Validado en Archivo 2 (OK - No WMS)' : 'Validado correctamente';
                    this.showResultBox('success', code, 'OK', statusMsg, item);
                    playSound('success');
                } else {
                    status = 'blocked';
                    this.showResultBox('blocked', code, 'SIN STOCK', 'Sin stock disponible', item);
                    playSound('warning');
                }

                this.addBox(status, this.createBoxData(rawCode, code, '', item, source, isPriority));
                this.flashInput('success');
            },

            async processCode2(rawCode2) {
                if (!this.pendingCode1) return;

                // BÃºsqueda de dos niveles para Code2 tambiÃ©n
                const result = await findCodeInInventoryTwoLevel(rawCode2);
                const code2 = result.code;
                const item = result.item;
                const source = result.source;

                // Validar prioridad del cÃ³digo 2
                const priorityCheck2 = await checkIfPriority(rawCode2);
                const isPriorityCode2 = priorityCheck2.isPriority;
                const isPriority = this.pendingCode1.isPriority || isPriorityCode2;

                if (isPriority) {
                    showPriorityAlert(item ? code2 : this.pendingCode1.code);
                }

                document.getElementById('unified-code2-container').classList.remove('show');

                let status;
                if (!item) {
                    // ESCENARIO 2: Ambos cÃ³digos fallaron - add to No WMS con AMBOS cÃ³digos
                    status = 'nowms';
                    this.addBox('nowms', this.createBoxData(this.pendingCode1.raw, this.pendingCode1.code, rawCode2, null, 'UNKNOWN', isPriority));
                    this.showResultBox('error', this.pendingCode1.code, 'NO WMS',
                        `Ambos cÃ³digos no encontrados. Guardados: ${this.pendingCode1.code} y ${code2}`, null);
                    playSound('error');
                } else {
                    // ESCENARIO 3: CÃ³digo 2 SÃ coincide - HACER SWAP
                    // El cÃ³digo 2 que coincidiÃ³ se convierte en el principal (scan1)
                    // El cÃ³digo 1 que fallÃ³ se guarda como secundario (scan2)
                    if (item.isBlocked) {
                        status = 'blocked';
                        // SWAP: code2 va a scan1, pendingCode1.raw va a scan2
                        this.addBox('blocked', this.createBoxData(rawCode2, code2, this.pendingCode1.raw, item, source, isPriority));
                        this.showResultBox('blocked', code2, 'BLOQUEADO (CÃ³digo 2 Validado)',
                            'CÃ³digo 2 validado correctamente - Inventario bloqueado', item);
                        playSound('warning');
                    } else {
                        status = 'ok';
                        // SWAP: code2 va a scan1, pendingCode1.raw va a scan2
                        this.addBox('ok', this.createBoxData(rawCode2, code2, this.pendingCode1.raw, item, source, isPriority));
                        const statusMsg = source === 'FILE2' ? 'CÃ³digo 2 validado en Archivo 2 (SWAP realizado)' : 'CÃ³digo 2 validado correctamente (SWAP realizado)';
                        this.showResultBox('success', code2, 'OK (CÃ³digo 2 Validado)', statusMsg, item);
                        playSound('success');
                    }
                }

                this.pendingCode1 = null;
                this.flashInput('success');
                document.getElementById('unified-scan-input').focus();
            },

            createBoxData(raw, code, scan2, item, source = 'WMS', isPriority = false) {
                const cleanScan2 = scan2 ? normalizeCode(scan2) : '';
                return {
                    raw,
                    code,
                    scan1: raw,
                    scan2: cleanScan2,
                    rawScan2: scan2 || '',
                    location: item?.cellNo || '-',
                    sku: item?.sku || '-',
                    product: item?.productName || '-',
                    timestamp: getFullDateTime(),
                    source: source,  // 'WMS' | 'FILE2' | 'UNKNOWN'
                    isPriority: isPriority,  // true si es cÃ³digo prioritario
                    status: item?.isBlocked ? 'blocked' : item?.isAvailable ? 'ok' : 'nowms'
                };
            },

            addBox(status, boxData) {
                const tab = this.getActiveTab();
                if (!tab) return;

                boxData.status = status;
                tab.boxes.push(boxData);

                GlobalTabs.saveToStorage();
                this.updateUI();
                // Asegurar actualizaciÃ³n de tarjetas globales
                GlobalTabs.updateGlobalSummary();
            },

            deleteBox(index) {
                const tab = this.getActiveTab();
                if (!tab) return;

                if (confirm('Â¿Eliminar esta caja?')) {
                    tab.boxes.splice(index, 1);
                    GlobalTabs.saveToStorage();
                    this.updateUI();
                    // Asegurar actualizaciÃ³n de tarjetas globales
                    GlobalTabs.updateGlobalSummary();
                    showNotification('Caja eliminada', 'info');
                }
            },

            // Buscar duplicado globalmente en TODOS los tabs + PENDING_SYNC + servidor (VALIDACIÃ“N DUAL)
            findDuplicateGlobal(code) {
                // BYPASS: Si estamos en modo ajuste, saltar toda la validaciÃ³n de duplicados
                if (window.ADJUSTMENT_MODE && window.ADJUSTMENT_MODE.active) {
                    console.log('ðŸ”§ [AJUSTE-UNIFICADO] Modo ajuste activo - Saltando validaciÃ³n de duplicados');
                    return null;
                }

                // Usar limpieza profunda para evitar falsos positivos
                const normalizedCode = ProcessedBoxesManager.cleanCode(code);
                if (!normalizedCode || normalizedCode.length === 0) {
                    console.log('âš ï¸ [DUPLICATE-GLOBAL] CÃ³digo vacÃ­o despuÃ©s de limpieza, saltando validaciÃ³n');
                    return null;
                }

                const statusNames = { ok: 'OK', blocked: 'Bloqueado', nowms: 'No WMS' };

                // PASO 1: Buscar en todos los tabs (sesiones actuales)
                for (const tab of GlobalTabs.tabs) {
                    const index = tab.state.unified.boxes.findIndex(b => {
                        const boxCode = ProcessedBoxesManager.cleanCode(b.code);
                        const boxScan2 = ProcessedBoxesManager.cleanCode(b.scan2);
                        return (boxCode && boxCode === normalizedCode) || (boxScan2 && boxScan2 === normalizedCode);
                    });
                    if (index !== -1) {
                        const box = tab.state.unified.boxes[index];
                        return {
                            source: 'current_session',
                            tabId: tab.id,
                            tabName: tab.name,
                            index,
                            box,
                            status: box.status,
                            statusName: statusNames[box.status] || box.status,
                            timestamp: box.timestamp,
                            isCurrentTab: tab.id === GlobalTabs.activeTabId,
                            pallet: tab.state.unified.palletId,
                            user: CURRENT_USER,
                            location: tab.state.unified.location || 'Sin ubicaciÃ³n'
                        };
                    }
                }

                // PASO 2: Buscar en PENDING_SYNC (registros locales pendientes de sincronizar)
                const pendingResult = ProcessedBoxesManager.findInPendingSync(normalizedCode);
                if (pendingResult) {
                    return {
                        source: 'pending_sync',
                        tabId: null,
                        tabName: 'Pendiente de sincronizar',
                        index: -1,
                        box: null,
                        status: null,
                        statusName: 'Pendiente de sincronizar',
                        timestamp: `${pendingResult.date} ${pendingResult.time}`,
                        isCurrentTab: false,
                        pallet: pendingResult.pallet,
                        user: pendingResult.user,
                        location: pendingResult.location,
                        scan1: pendingResult.scan1,
                        scan2: pendingResult.scan2
                    };
                }

                // PASO 3: Buscar en cajas procesadas del servidor (Lazy Load)
                const serverResult = ProcessedBoxesManager.findInProcessed(normalizedCode);
                if (serverResult) {
                    return {
                        source: 'server',
                        tabId: null,
                        tabName: 'Base de datos central',
                        index: -1,
                        box: null,
                        status: null,
                        statusName: 'Base de datos',
                        timestamp: `${serverResult.date} ${serverResult.time}`,
                        isCurrentTab: false,
                        pallet: serverResult.pallet,
                        user: serverResult.user,
                        location: serverResult.location,
                        scan1: serverResult.scan1,
                        scan2: serverResult.scan2
                    };
                }

                return null;
            },

            // Mostrar popup de duplicado con informaciÃ³n de tab - ALERTA DETALLADA
            showDuplicatePopupGlobal(code, rawCode, duplicateInfo) {
                // Determinar el origen del duplicado para mostrar mensaje apropiado
                const sourceLabels = {
                    'current_session': 'ðŸ“‹ SesiÃ³n Actual',
                    'pending_sync': 'â³ Pendiente de Sincronizar',
                    'server': 'ðŸ—„ï¸ Base de Datos Central'
                };
                const sourceLabel = sourceLabels[duplicateInfo.source] || 'Registro Previo';
                
                // Determinar si permitir ingreso forzado (solo para sesiÃ³n actual)
                const allowForceInsert = duplicateInfo.source === 'current_session';
                
                const tabInfo = duplicateInfo.isCurrentTab
                    ? 'esta misma sesiÃ³n'
                    : duplicateInfo.tabName || 'registro previo';

                const overlay = document.createElement('div');
                overlay.className = 'popup-overlay show';
                overlay.innerHTML = `
                    <div class="popup-content duplicate-popup" style="border: 2px solid #F44336; max-width: 320px; padding: 0;">
                        <div style="display: flex; justify-content: space-between; align-items: center; padding: 8px 12px; background: #FFEBEE; border-bottom: 1px solid #FFCDD2;">
                            <span style="font-weight: 600; color: #D32F2F; font-size: 0.85em;">â›” Caja Duplicada</span>
                            <button class="popup-close" data-action="close" style="color: #D32F2F; font-size: 1.2em; background: none; border: none; cursor: pointer;">Ã—</button>
                        </div>
                        <div style="padding: 12px;">
                            <div style="background: #fff; padding: 8px; border-radius: 4px; margin-bottom: 10px; border: 1px solid #eee;">
                                <div style="font-size: 0.75em; color: #999;">CÃ³digo:</div>
                                <div style="font-size: 1em; font-weight: 700; color: #333; font-family: monospace; word-break: break-all;">${code}</div>
                            </div>
                            <div style="font-size: 0.75em; color: #E65100; font-weight: 600; margin-bottom: 6px;">${sourceLabel}</div>
                            <div style="font-size: 0.8em; line-height: 1.6;">
                                <div><span style="color: #888;">ðŸ“¦</span> ${duplicateInfo.pallet || 'N/A'}</div>
                                <div><span style="color: #888;">ðŸ‘¤</span> ${duplicateInfo.user || '-'}</div>
                                <div><span style="color: #888;">ðŸ•</span> ${duplicateInfo.timestamp || '-'}</div>
                                <div><span style="color: #888;">ðŸ“</span> ${duplicateInfo.location || '-'}</div>
                            </div>
                            ${!allowForceInsert ? `<div style="background: #FFCDD2; padding: 6px; border-radius: 4px; margin-top: 10px; text-align: center; font-size: 0.75em; color: #C62828;">âš ï¸ Sin ingreso forzado</div>` : ''}
                            <div style="margin-top: 10px;">
                                ${allowForceInsert ? `<button class="btn btn-warning btn-full" data-action="force" style="padding: 8px; font-size: 0.85em; margin-bottom: 6px;">âš¡ Forzar</button>` : ''}
                                <button class="btn btn-secondary btn-full" data-action="close" style="padding: 8px; font-size: 0.85em;">${allowForceInsert ? 'Cancelar' : 'OK'}</button>
                            </div>
                        </div>
                    </div>
                `;
                document.body.appendChild(overlay);

                const closePopup = () => overlay.remove();

                overlay.addEventListener('click', (e) => {
                    if (e.target === overlay) closePopup();
                    if (e.target.dataset.action === 'close') closePopup();
                    if (e.target.dataset.action === 'force') {
                        UnifiedModule.forceInsertDuplicate(code, rawCode);
                        closePopup();
                    }
                });
            },

            showDuplicatePopup(code, rawCode, existingIndex) {
                const tab = this.getActiveTab();
                const existingBox = tab.boxes[existingIndex];

                const overlay = document.createElement('div');
                overlay.className = 'popup-overlay show';
                overlay.innerHTML = `
                    <div class="popup-content duplicate-popup">
                        <div class="popup-header">
                            <span>âš ï¸ CÃ³digo Duplicado</span>
                            <button class="popup-close" data-action="close">Ã—</button>
                        </div>
                        <div class="duplicate-info">
                            <div class="duplicate-info-row">
                                <span class="duplicate-info-label">CÃ³digo:</span>
                                <span class="duplicate-info-value"><code>${code}</code></span>
                            </div>
                            <div class="duplicate-info-row">
                                <span class="duplicate-info-label">Estado actual:</span>
                                <span class="duplicate-info-value">${existingBox.status === 'ok' ? 'OK' : existingBox.status === 'blocked' ? 'Bloqueado' : 'No WMS'}</span>
                            </div>
                            <div class="duplicate-info-row">
                                <span class="duplicate-info-label">Hora de registro:</span>
                                <span class="duplicate-info-value">${existingBox.timestamp}</span>
                            </div>
                        </div>
                        <p style="font-size: 0.9em; color: #666; margin-bottom: 15px;">
                            Este cÃ³digo ya fue escaneado. Â¿Deseas forzar un nuevo registro?
                        </p>
                        <div class="popup-buttons">
                            <button class="btn btn-warning btn-full" data-action="force">
                                âš¡ Ingreso Forzado
                            </button>
                            <button class="btn btn-secondary btn-full" data-action="close">
                                Cancelar
                            </button>
                        </div>
                    </div>
                `;
                document.body.appendChild(overlay);
                
                const closePopup = () => overlay.remove();
                
                overlay.addEventListener('click', (e) => {
                    if (e.target === overlay) closePopup();
                    if (e.target.dataset.action === 'close') closePopup();
                    if (e.target.dataset.action === 'force') {
                        UnifiedModule.forceInsertDuplicate(code, rawCode);
                        closePopup();
                    }
                });
            },

            async forceInsertDuplicate(code, rawCode) {
                // Usar bÃºsqueda de dos niveles para el duplicado tambiÃ©n
                const result = await findCodeInInventoryTwoLevel(rawCode);
                const finalCode = result.code;
                const item = result.item;
                const source = result.source;

                // Validar prioridad
                const priorityCheck = await checkIfPriority(rawCode);
                const isPriority = priorityCheck.isPriority;

                if (isPriority) {
                    showPriorityAlert(finalCode);
                }

                let status;
                if (!item) {
                    status = 'nowms';
                    showNotification('âš¡ Duplicado insertado en No WMS', 'warning');
                } else if (item.isBlocked) {
                    status = 'blocked';
                    showNotification('âš¡ Duplicado insertado en Bloqueado', 'warning');
                } else {
                    status = 'ok';
                    showNotification('âš¡ Duplicado insertado en OK', 'warning');
                }

                this.addBox(status, this.createBoxData(rawCode, finalCode, '', item, source, isPriority));
                playSound('warning');
                document.getElementById('unified-scan-input').focus();
            },

            showResultBox(type, code, title, message, item) {
                const box = document.getElementById('unified-result-box');
                const icons = { success: 'âœ…', warning: 'âš ï¸', blocked: 'âš ï¸', error: 'âŒ' };

                box.className = `result-box show ${type}`;
                document.getElementById('unified-result-icon').textContent = icons[type] || 'ðŸ“¦';
                document.getElementById('unified-result-title').textContent = `${title}: ${code}`;

                const detailsEl = document.getElementById('unified-result-details');
                if (item) {
                    detailsEl.innerHTML = `
                        <div class="result-info-item"><span class="result-info-label">Ubic:</span><span class="result-info-value">${item.cellNo || '-'}</span></div>
                        <div class="result-info-item"><span class="result-info-label">SKU:</span><span class="result-info-value">${item.sku || '-'}</span></div>
                        <div class="result-info-item"><span class="result-info-label">Stock:</span><span class="result-info-value">${item.availableStock || 0}</span></div>
                    `;
                } else {
                    detailsEl.innerHTML = `<div class="result-info-item" style="color: #666;">${message}</div>`;
                }
            },

            flashInput(type) {
                const input = document.getElementById('unified-scan-input');
                if (!input) return;
                input.classList.remove('success', 'error');
                if (type === 'success') {
                    input.classList.add('success');
                } else if (type === 'error') {
                    input.classList.add('error');
                }
                setTimeout(() => input.classList.remove('success', 'error'), 500);
            },

            async sendPallet() {
                const tab = this.getActiveTab();
                if (!tab) return;

                const location = document.getElementById('unified-location').value.trim();
                const originLocation = document.getElementById('unified-origin-location').value.trim().toUpperCase();

                if (tab.boxes.length === 0) {
                    showNotification('âš ï¸ No hay cajas en esta tarima', 'warning');
                    return;
                }

                if (!location) {
                    showNotification('âš ï¸ Ingresa la ubicaciÃ³n destino', 'warning');
                    document.getElementById('unified-location').focus();
                    return;
                }

                // OPTIMIZADO: ValidaciÃ³n LOCAL rÃ¡pida (sin consulta remota)
                const localDuplicate = DeduplicationManager.isPalletSynced(tab.palletId, location);
                if (localDuplicate) {
                    tab.palletId = this.generatePalletId();
                    document.getElementById('unified-pallet-id').textContent = tab.palletId;
                    GlobalTabs.saveToStorage();
                    console.log(`ðŸ”„ [DEDUP] Pallet duplicado local detectado, nuevo ID: ${tab.palletId}`);
                }

                // Show validation popup (inmediato)
                this.showSendValidationPopup(tab, location, originLocation);
            },

            showSendValidationPopup(tab, location, originLocation) {
                const boxCount = tab.boxes.length;

                // Enable blind mode - blur all counters
                document.body.classList.add('blind-mode');

                const overlay = document.createElement('div');
                overlay.className = 'popup-overlay show';
                overlay.id = 'unified-send-validation-popup';
                overlay.innerHTML = `
                    <div class="popup-content send-validation-popup">
                        <div class="popup-header">
                            <span>ðŸ“¦ Validar EnvÃ­o Unificado</span>
                            <button class="popup-close" id="unified-validation-close-btn">Ã—</button>
                        </div>
                        <p style="margin-bottom: 15px; font-size: 0.9em;">
                            <strong>Pallet:</strong> ${tab.palletId}<br>
                            <strong>Destino:</strong> ${location}<br>
                            <span style="color: #888; font-size: 0.85em;">ðŸ”’ Conteo oculto - Verifica fÃ­sicamente</span>
                        </p>
                        <div class="validation-input-group">
                            <label>Â¿CuÃ¡ntas cajas fÃ­sicas hay en la tarima?</label>
                            <input type="number" id="unified-physical-count-input" min="0" placeholder="" autofocus>
                        </div>
                        <div id="unified-validation-status"></div>
                        <div class="popup-buttons">
                            <button class="btn btn-success btn-full" id="unified-confirm-send-btn" disabled>
                                ðŸ“¤ Confirmar EnvÃ­o
                            </button>
                            <button class="btn btn-secondary btn-full" id="unified-validation-cancel-btn">
                                Cancelar
                            </button>
                        </div>
                    </div>
                `;
                document.body.appendChild(overlay);

                // Attach event listeners
                const closeBtn = document.getElementById('unified-validation-close-btn');
                const cancelBtn = document.getElementById('unified-validation-cancel-btn');
                const confirmBtn = document.getElementById('unified-confirm-send-btn');
                const input = document.getElementById('unified-physical-count-input');

                if (closeBtn) closeBtn.addEventListener('click', () => this.closeBlindValidationPopup());
                if (cancelBtn) cancelBtn.addEventListener('click', () => this.closeBlindValidationPopup());
                if (confirmBtn) {
                    confirmBtn.addEventListener('click', () => {
                        // HARD BLOCK: Verificar si ya estÃ¡ procesando
                        if (isSubmitting) {
                            console.warn('âš ï¸ [SEND-UNIFIED] Ya hay un envÃ­o en progreso');
                            return;
                        }
                        
                        // PRIMERA LÃNEA: Establecer isSubmitting = true
                        isSubmitting = true;
                        
                        // BLOQUEO INMEDIATO: Deshabilitar botÃ³n fÃ­sicamente
                        confirmBtn.disabled = true;
                        confirmBtn.innerHTML = '<span style="display: inline-block; animation: spin 1s linear infinite;">â³</span> Procesando envÃ­o...';
                        confirmBtn.style.opacity = '0.6';
                        confirmBtn.style.cursor = 'not-allowed';
                        
                        // Cerrar popup inmediatamente
                        this.closeBlindValidationPopup();
                        
                        // Ejecutar envÃ­o
                        this.confirmSendPallet(location, originLocation);
                    });
                }
                if (input) {
                    input.addEventListener('input', () => this.validateBoxCount(boxCount));
                    input.focus();
                }

                overlay.addEventListener('click', (e) => {
                    if (e.target === overlay) this.closeBlindValidationPopup();
                });
            },

            closeBlindValidationPopup() {
                document.body.classList.remove('blind-mode');
                const popup = document.getElementById('unified-send-validation-popup');
                if (popup) popup.remove();
            },

            validateBoxCount(expectedCount) {
                const input = document.getElementById('unified-physical-count-input');
                const statusDiv = document.getElementById('unified-validation-status');
                const confirmBtn = document.getElementById('unified-confirm-send-btn');
                const physicalCount = parseInt(input.value) || 0;

                // Validar que expectedCount sea un nÃºmero vÃ¡lido
                const validExpectedCount = parseInt(expectedCount) || 0;
                if (validExpectedCount <= 0) {
                    statusDiv.innerHTML = '';
                    confirmBtn.disabled = true;
                    return;
                }

                if (physicalCount === validExpectedCount) {
                    statusDiv.innerHTML = `<div class="validation-match">âœ… Â¡Correcto! Cantidad coincide (${validExpectedCount} cajas)</div>`;
                    confirmBtn.disabled = false;
                } else if (physicalCount > 0) {
                    const diff = physicalCount - validExpectedCount;
                    const diffText = diff > 0 ? `+${diff} de mÃ¡s` : `${Math.abs(diff)} faltan`;
                    statusDiv.innerHTML = `<div class="validation-mismatch">âŒ No coincide: Escaneadas ${validExpectedCount}, FÃ­sicas ${physicalCount} (${diffText})</div>`;
                    confirmBtn.disabled = true;
                } else {
                    statusDiv.innerHTML = '';
                    confirmBtn.disabled = true;
                }
            },

            async confirmSendPallet(location, originLocation) {
                // Obtener botÃ³n de confirmaciÃ³n
                const confirmBtn = document.getElementById('unified-confirm-send-btn');
                
                try {
                    console.log('ðŸš€ [SEND-UNIFIED] ========== INICIANDO ENVÃO DE PALLET ==========');
                    
                    // PROTECCIÃ“N: Prevenir doble click / duplicaciÃ³n
                    if (window.SENDING_IN_PROGRESS) {
                        console.warn('âš ï¸ [SEND-UNIFIED] EnvÃ­o ya en progreso, ignorando solicitud duplicada');
                        return;
                    }
                    
                    window.SENDING_IN_PROGRESS = true;
                    console.log('ðŸ”’ [SEND-UNIFIED] Flag SENDING_IN_PROGRESS activado');
                    
                    // DESHABILITAR BOTÃ“N INMEDIATAMENTE (Anti-spam)
                    if (confirmBtn) {
                        confirmBtn.disabled = true;
                        confirmBtn.textContent = 'â³ Procesando...';
                        confirmBtn.style.opacity = '0.6';
                        confirmBtn.style.cursor = 'not-allowed';
                    }
                    
                    // Disable blind mode and close popup
                    document.body.classList.remove('blind-mode');
                    document.getElementById('unified-send-validation-popup')?.remove();

                    const tab = this.getActiveTab();
                    if (!tab) {
                        window.SENDING_IN_PROGRESS = false;
                        isSubmitting = false;
                        return;
                    }

                    console.log('ðŸ” [SEND-UNIFIED] Validando ubicaciÃ³n:', location);
                    
                    // Validate location format and daily usage
                    const locationCheck = await confirmInvalidLocation(location);
                    console.log('ðŸ” [SEND-UNIFIED] Resultado de validaciÃ³n:', JSON.stringify(locationCheck, null, 2));
                    
                    if (!locationCheck || !locationCheck.confirmed) {
                        console.error('âŒ [SEND-UNIFIED] Location validation failed');
                        showNotification('âŒ EnvÃ­o cancelado - Verifica la ubicaciÃ³n', 'warning');
                        document.getElementById('unified-location').focus();
                        window.SENDING_IN_PROGRESS = false;
                        isSubmitting = false;
                        return;
                    }
                    
                    console.log('âœ… [SEND-UNIFIED] UbicaciÃ³n validada correctamente');

                    const finalLocation = locationCheck.formatted;
                    document.getElementById('unified-location').value = finalLocation;

                    // BYPASS: Si estamos en modo AJUSTE, saltar validaciÃ³n de ubicaciÃ³n duplicada
                    const isAdjustmentMode = window.ADJUSTMENT_MODE && window.ADJUSTMENT_MODE.active;
                    
                    if (!isAdjustmentMode) {
                        console.log('ðŸ” [VALIDATION-UNIFIED] ========== VALIDACIÃ“N DE UBICACIÃ“N DUPLICADA ==========');
                        // VALIDACIÃ“N CRÃTICA: Verificar si la ubicaciÃ³n ya fue usada HOY
                        const today = new Date().toISOString().split('T')[0]; // YYYY-MM-DD
                        console.log('ðŸ” [VALIDATION-UNIFIED] Fecha hoy:', today);
                        console.log('ðŸ” [VALIDATION-UNIFIED] UbicaciÃ³n a validar:', finalLocation);
                        
                        // IMPORTANTE: Sincronizar PENDING_SYNC desde IndexedDB antes de validar
                        try {
                            const pendingFromDB = await PersistenceManager.getPendingSync();
                            PENDING_SYNC = pendingFromDB;
                            console.log(`ðŸ” [VALIDATION-UNIFIED] PENDING_SYNC actualizado: ${PENDING_SYNC.length} registros`);
                        } catch (error) {
                            console.warn('âš ï¸ [VALIDATION-UNIFIED] Error sincronizando PENDING_SYNC:', error);
                        }
                        
                        // CAPA 1: Verificar en PENDING_SYNC (registros locales pendientes)
                        console.log('ðŸ” [VALIDATION-UNIFIED] Capa 1: Verificando en PENDING_SYNC...');
                        const usedInPending = PENDING_SYNC.some(record => {
                            const recordDate = record.date; // YYYY-MM-DD
                            const match = recordDate === today && record.location === finalLocation;
                            if (match) {
                                console.log('âŒ [VALIDATION-UNIFIED] Match encontrado en PENDING_SYNC:', record);
                            }
                            return match;
                        });

                        if (usedInPending) {
                            console.error(`âŒ [VALIDATION-UNIFIED] BLOQUEADO - UbicaciÃ³n ${finalLocation} ya fue usada hoy en registros pendientes`);
                            showNotification(`âŒ La ubicaciÃ³n ${finalLocation} ya fue usada hoy. Elige otra ubicaciÃ³n.`, 'error');
                            document.getElementById('unified-location').focus();
                            window.SENDING_IN_PROGRESS = false;
                            isSubmitting = false;
                            return;
                        }
                        console.log('âœ… [VALIDATION-UNIFIED] Capa 1: No encontrado en PENDING_SYNC');

                        // CAPA 2: Verificar en STATE.history (registros locales del historial)
                        console.log('ðŸ” [VALIDATION-UNIFIED] Capa 2: Verificando en STATE.history...');
                        console.log('ðŸ” [VALIDATION-UNIFIED] STATE.history.length:', STATE.history.length);
                        const usedInHistory = STATE.history.some(record => {
                            const recordDate = record.date; // YYYY-MM-DD
                            const match = recordDate === today && record.location === finalLocation;
                            if (match) {
                                console.log('âŒ [VALIDATION-UNIFIED] Match encontrado en STATE.history:', record);
                            }
                            return match;
                        });

                        if (usedInHistory) {
                            console.error(`âŒ [VALIDATION-UNIFIED] BLOQUEADO - UbicaciÃ³n ${finalLocation} ya fue usada hoy en historial local`);
                            showNotification(`âŒ La ubicaciÃ³n ${finalLocation} ya fue usada hoy. Elige otra ubicaciÃ³n.`, 'error');
                            document.getElementById('unified-location').focus();
                            window.SENDING_IN_PROGRESS = false;
                            isSubmitting = false;
                            return;
                        }
                        console.log('âœ… [VALIDATION-UNIFIED] Capa 2: No encontrado en STATE.history');

                        // CAPA 3: Verificar en cachÃ© de datos del servidor (PROCESSED_BOXES_MAP)
                        console.log('ðŸ” [VALIDATION-UNIFIED] Capa 3: Verificando en cachÃ© del servidor...');
                        console.log(`ðŸ” [VALIDATION-UNIFIED] PROCESSED_BOXES_MAP.size: ${PROCESSED_BOXES_MAP.size}`);
                        
                        let usedInServerCache = false;
                        for (const [code, boxData] of PROCESSED_BOXES_MAP) {
                            const dbDate = boxData.date; // Formato: YYYY-MM-DD
                            const dbLocation = boxData.location;
                            const match = dbDate === today && dbLocation === finalLocation;
                            if (match) {
                                console.log('âŒ [VALIDATION-UNIFIED] Match encontrado en cachÃ© del servidor:', boxData);
                                usedInServerCache = true;
                                break;
                            }
                        }

                        if (usedInServerCache) {
                            console.error(`âŒ [VALIDATION-UNIFIED] BLOQUEADO - UbicaciÃ³n ${finalLocation} ya fue usada hoy por otro usuario`);
                            showNotification(`âŒ La ubicaciÃ³n ${finalLocation} ya fue usada hoy por otro usuario. Elige otra ubicaciÃ³n.`, 'error');
                            document.getElementById('unified-location').focus();
                            window.SENDING_IN_PROGRESS = false;
                            isSubmitting = false;
                            return;
                        }
                        console.log('âœ… [VALIDATION-UNIFIED] Capa 3: No encontrado en cachÃ© del servidor');

                        console.log('âœ… [VALIDATION-UNIFIED] ========== UBICACIÃ“N VALIDADA - NO DUPLICADA ==========');
                    } else {
                        console.log('ðŸ”§ [AJUSTE-UNIFIED] ========== BYPASS DE VALIDACIÃ“N ACTIVADO (MODO AJUSTE) ==========');
                    }

                const statusMap = { ok: 'OK', blocked: 'BLOQUEADO', nowms: 'NO WMS' };
                const statusMapDisplay = { ok: 'OK', blocked: 'Bloqueada', nowms: 'No WMS' };
                const { dateStr, timeStr } = getLocalDateTime();

                // Check if cancelados mode is active
                const isCancelados = this.isCanceladosMode();

                // Create records for ALL boxes in the unified pallet
                const records = tab.boxes.map(box => {
                    let finalStatus, finalNote;

                    if (isCancelados) {
                        // Modo cancelados
                        finalStatus = 'CANCELADO';
                        finalNote = `Estatus: ${statusMapDisplay[box.status]}`;
                    } else {
                        // Modo normal - verificar si es FILE2
                        finalStatus = statusMap[box.status];
                        finalNote = '';

                        // Si es FILE2 y estÃ¡ OK, cambiar estatus a "OK - NO WMS"
                        if (box.source === 'FILE2' && box.status === 'ok') {
                            finalStatus = 'OK - NO WMS';
                            finalNote = 'Estatus: NO WMS';
                        } else if (box.source === 'FILE2' && box.status === 'blocked') {
                            // Si es FILE2 y bloqueado, agregar nota
                            finalNote = 'Estatus: NO WMS';
                        }
                    }

                    // Si es PRIORIDAD, concatenar al estatus
                    if (box.isPriority) {
                        finalStatus = finalStatus + ' - PRIORIDAD';
                        finalNote = finalNote ? finalNote + ' | PRIORIDAD' : 'PRIORIDAD';
                    }

                    // Si estamos en modo ajuste, agregar nota de ediciÃ³n
                    if (window.ADJUSTMENT_MODE && window.ADJUSTMENT_MODE.active) {
                        finalNote = finalNote ? finalNote + ' | Informacion Editada' : 'Informacion Editada';
                    }

                    return {
                        _id: generateUUID(), // ID Ãºnico para el registro
                        _timestamp: generateTimestamp(), // Timestamp de creaciÃ³n
                        _status: 'pending', // Estado de sincronizaciÃ³n
                        date: dateStr,
                        time: timeStr,
                        user: CURRENT_USER || 'Usuario',
                        scan1: box.scan1 || box.raw || box.code,  // Usar scan1 (raw), con fallbacks
                        scan2: box.scan2 || '',
                        location: finalLocation,
                        status: finalStatus,
                        note: finalNote,
                        pallet: tab.palletId,  // Same pallet ID for all
                        originLocation: originLocation
                    };
                });

                // PROTECCIÃ“N: Marcar inicio de envÃ­o para evitar falsos positivos
                DeduplicationManager.startSending(tab.palletId);

                try {
                    // DEDUPLICACIÃ“N: Verificar si el pallet ya fue sincronizado
                    if (DeduplicationManager.isPalletSynced(tab.palletId, finalLocation)) {
                        console.warn(`âš ï¸ [DEDUP-UNIFICADO] Pallet ${tab.palletId} ya fue sincronizado a ${finalLocation}. Generando nuevo ID.`);
                        const newPalletId = this.generatePalletId();
                        records.forEach(r => r.pallet = newPalletId);
                        tab.palletId = newPalletId;
                        showNotification(`âš ï¸ Pallet duplicado detectado. Nuevo ID: ${newPalletId}`, 'warning');
                    }

                    // Limpiar registros previos del mismo pallet en PENDING_SYNC
                    PENDING_SYNC = PENDING_SYNC.filter(r => r.pallet !== tab.palletId);

                    // DEDUPLICACIÃ“N: Filtrar registros duplicados
                    const uniqueRecords = DeduplicationManager.filterDuplicateRecords(records, tab.palletId);
                    
                    if (uniqueRecords.length === 0) {
                        console.warn('âš ï¸ [DEDUP-UNIFICADO] Todos los registros ya existen en PENDING_SYNC');
                        showNotification('âš ï¸ Registros duplicados - ya estÃ¡n pendientes de sincronizar', 'warning');
                        return;
                    }

                    // VALIDACIÃ“N DE CONECTIVIDAD ANTES DE ENVÃO
                    if (!IS_ONLINE) {
                        // Modo offline - guardar localmente
                        console.log('ðŸ“´ [OFFLINE-UNIFICADO] Guardando datos localmente...');
                        PENDING_SYNC = [...PENDING_SYNC, ...uniqueRecords];
                        SyncManager.save();
                        
                        // Agregar a historial local SOLO en modo offline
                        STATE.history = [...records, ...STATE.history].slice(0, 1000);
                        
                        // Reset tab
                        tab.palletId = this.generatePalletId();
                        tab.boxes = [];
                        tab.location = '';
                        document.getElementById('unified-location').value = '';
                        
                        GlobalTabs.saveToStorage();
                        this.updateUI();
                        GlobalTabs.updateGlobalSummary();
                        playSound('success');
                        document.getElementById('unified-origin-location').focus();
                        
                        const modeText = isCancelados ? ' como CANCELADOS' : '';
                        showNotification(`ðŸ’¾ Pallet guardado localmente: ${uniqueRecords.length} registros${modeText} (se sincronizarÃ¡ cuando haya conexiÃ³n)`, 'info');
                        return;
                    }

                    // Verificar token de Google antes de intentar envÃ­o
                    if (!gapi?.client?.getToken()) {
                        console.error('âŒ [AUTH-UNIFICADO] Token de Google no disponible');
                        showNotification(`âŒ ConexiÃ³n perdida. Por favor, desconecta manualmente y vuelve a conectarte a Google para continuar.`, 'error');
                        return;
                    }

                    // TRANSACCIÃ“N ATÃ“MICA: Guardar estado ANTES de modificar UI
                    const backupTab = JSON.parse(JSON.stringify(tab));
                    const backupPendingSync = [...PENDING_SYNC];
                    const backupHistory = [...STATE.history];
                    
                    // Add to pending sync temporalmente
                    PENDING_SYNC = [...PENDING_SYNC, ...uniqueRecords];
                    SyncManager.save();

                    // SINCRONIZACIÃ“N CON TIMEOUT DE 15 SEGUNDOS Y RETRY AUTOMÃTICO
                    let syncResult = { success: false, confirmed: false };
                    const maxRetries = 2;
                    let lastError = null;
                    
                    for (let attempt = 1; attempt <= maxRetries; attempt++) {
                        try {
                            console.log(`ðŸ”„ [ATOMIC-UNIFICADO] Intento ${attempt}/${maxRetries} - Sincronizando con timeout de 15s...`);
                            
                            if (attempt > 1) {
                                showNotification(`ðŸ”„ Reintentando conexiÃ³n con Google (intento ${attempt}/${maxRetries})...`, 'info');
                            }
                            
                            // Crear promesa con timeout de 15 segundos
                            const syncPromise = SyncManager.sync(false);
                            const timeoutPromise = new Promise((_, reject) => 
                                setTimeout(() => reject(new Error('Timeout: El servidor no respondiÃ³ en 15 segundos')), 15000)
                            );
                            
                            syncResult = await Promise.race([syncPromise, timeoutPromise]);
                            
                            // Si llegamos aquÃ­, la sincronizaciÃ³n fue exitosa
                            console.log(`âœ… [ATOMIC-UNIFICADO] SincronizaciÃ³n exitosa en intento ${attempt}`);
                            break; // Salir del loop de reintentos
                            
                        } catch (err) {
                            lastError = err;
                            console.error(`âŒ [ATOMIC-UNIFICADO] Error en intento ${attempt}:`, err);
                            
                            // Si es el Ãºltimo intento, procesar el error
                            if (attempt === maxRetries) {
                                // Determinar tipo de error con mensajes especÃ­ficos
                                let errorMessage = 'âŒ Error al enviar pallet: ';
                                
                                if (err.message?.includes('Timeout')) {
                                    errorMessage += 'El servidor no respondiÃ³ a tiempo. Verifica tu conexiÃ³n e intenta nuevamente.';
                                } else if (err.message?.includes('Invalid Credentials') || err.status === 401) {
                                    errorMessage = 'âŒ ConexiÃ³n perdida. Por favor, desconecta manualmente y vuelve a conectarte a Google para continuar.';
                                } else if (err.message?.includes('Network') || err.message?.includes('ERR_NETWORK_IO_SUSPENDED') || err.message?.includes('ERR_TIMED_OUT') || !navigator.onLine) {
                                    errorMessage = 'âŒ Problema de conexiÃ³n con Google. Verifica tu red e intenta nuevamente.';
                                } else {
                                    errorMessage += 'No se pudo confirmar con el servidor. Intenta nuevamente.';
                                }
                                
                                // CAPTURA CRÃTICA: Garantizar que datos NO se pierdan
                                console.error('âŒ [CRITICAL-CAPTURE-UNIFICADO] Guardando datos en cola de pendientes despuÃ©s de fallo...');
                                
                                // Los datos YA estÃ¡n en PENDING_SYNC (se agregaron antes del intento)
                                // Solo necesitamos asegurar que se persistan
                                await SyncManager.save();
                                
                                // Actualizar UI para mostrar contador de pendientes
                                SyncManager.updateUI(false);
                                
                                // Cerrar cualquier modal o popup para desbloquear UI
                                document.body.classList.remove('blind-mode');
                                const popup = document.getElementById('unified-send-validation-popup');
                                if (popup) popup.remove();
                                
                                const pendingMsg = `${errorMessage}\n\nâœ… Tus datos estÃ¡n seguros en la cola de sincronizaciÃ³n (${PENDING_SYNC.length} registros pendientes).`;
                                showNotification(pendingMsg, 'error');
                                
                                console.log(`ðŸ’¾ [CRITICAL-CAPTURE-UNIFICADO] ${uniqueRecords.length} registros guardados en PENDING_SYNC`);
                                console.log(`ðŸ“Š [CRITICAL-CAPTURE-UNIFICADO] Total pendientes: ${PENDING_SYNC.length}`);
                                
                                return; // MANTENER DATOS EN PANTALLA
                            }
                            
                            // Esperar 2 segundos antes del siguiente reintento
                            if (attempt < maxRetries) {
                                await new Promise(resolve => setTimeout(resolve, 2000));
                            }
                        }
                    }

                    // VALIDACIÃ“N ATÃ“MICA: Solo limpiar pantalla si HTTP 200 confirmado
                    if (syncResult.confirmed) {
                        // âœ… Ã‰XITO: Agregar a historial local SOLO si confirmado en servidor
                        STATE.history = [...records, ...STATE.history].slice(0, 1000);
                        
                        // Reset tab (transacciÃ³n exitosa)
                        tab.palletId = this.generatePalletId();
                        tab.boxes = [];
                        tab.location = '';
                        document.getElementById('unified-location').value = '';

                        GlobalTabs.saveToStorage();
                        this.updateUI();
                        GlobalTabs.updateGlobalSummary();
                        playSound('success');

                        document.getElementById('unified-origin-location').focus();

                        const modeText = isCancelados ? ' como CANCELADOS' : '';
                        showNotification(`âœ… Pallet enviado exitosamente: ${uniqueRecords.length} registros${modeText} procesados y confirmados`, 'success');
                    } else {
                        // âŒ FALLO: ROLLBACK COMPLETO - mantener datos en pantalla
                        console.error('âŒ [ROLLBACK-UNIFICADO] SincronizaciÃ³n fallÃ³, restaurando estado...');
                        PENDING_SYNC = backupPendingSync;
                        STATE.history = backupHistory;
                        SyncManager.save();
                        showNotification(`âŒ Error al enviar pallet: No se pudo confirmar con el servidor. Los datos permanecen en pantalla. Intenta nuevamente.`, 'error');
                        return; // MANTENER DATOS EN PANTALLA
                    }

                    // If in adjustment mode, delete old records in background
                    if (window.ADJUSTMENT_MODE && window.ADJUSTMENT_MODE.active) {
                        const origPallet = window.ADJUSTMENT_MODE.originalPalletCode;
                        const origLocation = window.ADJUSTMENT_MODE.originalLocation;
                        
                        // Desactivar modo de ajuste y restaurar estado normal
                        deactivateAdjustmentMode();
                        
                        deleteOldPalletRecords(origPallet, origLocation).then(() => {
                            showNotification('âœ… Ajuste completado', 'success');
                        }).catch(err => {
                            console.warn('âš ï¸ Error eliminando registros antiguos:', err);
                        });
                    }
                } catch (innerError) {
                    console.error('âŒ [SEND-UNIFIED] Error en bloque de envÃ­o:', innerError);
                    showNotification('âŒ Error al procesar el pallet. Intenta nuevamente.', 'error');
                    window.SENDING_IN_PROGRESS = false;
                    isSubmitting = false;
                    if (confirmBtn) {
                        confirmBtn.disabled = false;
                        confirmBtn.textContent = 'ðŸ“¤ Confirmar EnvÃ­o';
                        confirmBtn.style.opacity = '1';
                        confirmBtn.style.cursor = 'pointer';
                    }
                }
                } catch (error) {
                    console.error('âŒ [SEND-UNIFIED] Error in confirmSendPallet:', error);
                    console.error('âŒ [SEND-UNIFIED] Stack:', error.stack);
                    window.SENDING_IN_PROGRESS = false;
                    isSubmitting = false;
                    
                    // REHABILITAR BOTÃ“N en caso de error
                    if (confirmBtn) {
                        confirmBtn.disabled = false;
                        confirmBtn.textContent = 'ðŸ“¤ Confirmar EnvÃ­o';
                        confirmBtn.style.opacity = '1';
                        confirmBtn.style.cursor = 'pointer';
                    }
                    
                    showNotification('âŒ Error al enviar la tarima. Por favor, intente nuevamente.', 'error');
                } finally {
                    DeduplicationManager.endSending();
                    window.SENDING_IN_PROGRESS = false;
                    isSubmitting = false;
                    console.log('ðŸ”“ [SEND-UNIFIED] Flags liberados (SENDING_IN_PROGRESS + isSubmitting)');
                    
                    // REHABILITAR BOTÃ“N (si aÃºn existe)
                    if (confirmBtn && !confirmBtn.disabled) {
                        confirmBtn.disabled = false;
                        confirmBtn.textContent = 'ðŸ“¤ Confirmar EnvÃ­o';
                        confirmBtn.style.opacity = '1';
                        confirmBtn.style.cursor = 'pointer';
                    }
                }
            },

            updateUI() {
                const tab = this.getActiveTab();

                const palletIdEl = document.getElementById('unified-pallet-id');
                const locationEl = document.getElementById('unified-location');
                const originLocationEl = document.getElementById('unified-origin-location');
                const okCountEl = document.getElementById('unified-ok-count');
                const blockedCountEl = document.getElementById('unified-blocked-count');
                const nowmsCountEl = document.getElementById('unified-nowms-count');
                const globalCountEl = document.getElementById('unified-global-box-count');
                const sendBtn = document.getElementById('unified-send-btn');

                if (!tab) {
                    if (globalCountEl) globalCountEl.textContent = '0';
                    if (okCountEl) okCountEl.textContent = '0';
                    if (blockedCountEl) blockedCountEl.textContent = '0';
                    if (nowmsCountEl) nowmsCountEl.textContent = '0';
                    if (sendBtn) sendBtn.disabled = true;
                    return;
                }

                // Update pallet ID
                if (palletIdEl) palletIdEl.textContent = tab.palletId;

                // Update location inputs
                if (locationEl) locationEl.value = tab.location || '';
                if (originLocationEl) originLocationEl.value = tab.originLocation || '';

                // Update counts
                const okCount = tab.boxes.filter(b => b.status === 'ok').length;
                const blockedCount = tab.boxes.filter(b => b.status === 'blocked').length;
                const nowmsCount = tab.boxes.filter(b => b.status === 'nowms').length;

                if (okCountEl) okCountEl.textContent = okCount;
                if (blockedCountEl) blockedCountEl.textContent = blockedCount;
                if (nowmsCountEl) nowmsCountEl.textContent = nowmsCount;
                if (globalCountEl) globalCountEl.textContent = tab.boxes.length;

                // Update send button
                if (sendBtn) sendBtn.disabled = tab.boxes.length === 0;

                // Update box list
                this.renderBoxList();

                // Update global tabs (for counts)
                GlobalTabs.renderTabs();
                GlobalTabs.updateGlobalSummary();
            },

            renderBoxList() {
                const tab = this.getActiveTab();
                const listEl = document.getElementById('unified-box-list');

                if (!tab || tab.boxes.length === 0) {
                    listEl.innerHTML = `
                        <div class="empty-state">
                            <div class="empty-icon">ðŸ“­</div>
                            <div>Sin cajas escaneadas</div>
                        </div>
                    `;
                    return;
                }

                const statusIcons = { ok: 'âœ…', blocked: 'âš ï¸', nowms: 'âŒ' };
                const statusNames = { ok: 'OK', blocked: 'Bloqueado', nowms: 'No WMS' };
                const isCancelados = this.isCanceladosMode();

                listEl.innerHTML = tab.boxes.map((box, index) => {
                    const canceladoBadge = isCancelados
                        ? `<span class="cancelado-badge">ðŸš« CANCELADO</span>`
                        : '';
                    const canceladoClass = isCancelados ? 'cancelado-mode' : '';

                    // Source badge (dos niveles de bÃºsqueda)
                    const source = box.source || 'WMS';
                    const badgeText = source === 'WMS' ? 'OK' :
                                     source === 'FILE2' ? 'OK - NO WMS' : 'NO WMS';
                    const sourceBadge = box.status === 'ok' || box.status === 'blocked'
                        ? `<span class="inventory-badge badge-${source}">${badgeText}</span>`
                        : '';

                    // Priority badge (si es prioritario)
                    const priorityBadge = box.isPriority ?
                        `<span class="priority-badge">ðŸ”´ PRIORIDAD</span>` : '';

                    return `
                        <div class="unified-box-item ${box.status} ${canceladoClass}">
                            <span class="unified-box-num">${index + 1}.</span>
                            <span class="unified-box-status-icon">${statusIcons[box.status]}</span>
                            <div class="unified-box-info">
                                <div class="unified-box-code">
                                    ${box.code}${box.scan2 ? ` / ${box.scan2}` : ''}
                                    ${sourceBadge}
                                    ${priorityBadge}
                                    ${canceladoBadge}
                                </div>
                                <div class="unified-box-meta">${box.location} â€¢ ${box.timestamp}</div>
                            </div>
                            <div class="unified-box-actions">
                                <button class="box-action-btn copy" onclick="copyToClipboard('${box.code}')" title="Copiar cÃ³digo">â§‰</button>
                                <button class="box-action-btn copy" onclick="copyToClipboard('${box.location}')" title="Copiar ubicaciÃ³n">â—Ž</button>
                                <button class="box-action-btn delete" onclick="UnifiedModule.deleteBox(${index})" title="Eliminar">âœ•</button>
                            </div>
                        </div>
                    `;
                }).join('');
            }
        };

        // Force insert for unified module
        function unifiedForceInsert() {
            if (!UnifiedModule.pendingCode1) {
                showNotification('âš ï¸ Primero escanea un cÃ³digo', 'warning');
                return;
            }

            const code2Value = document.getElementById('unified-code2-input').value.trim();

            UnifiedModule.addBox('nowms', UnifiedModule.createBoxData(
                UnifiedModule.pendingCode1.raw,
                UnifiedModule.pendingCode1.code,
                code2Value,
                null,
                'UNKNOWN'
            ));

            const msg = code2Value
                ? `Insertado con cÃ³digos: ${UnifiedModule.pendingCode1.code} y ${code2Value}`
                : `Insertado con cÃ³digo: ${UnifiedModule.pendingCode1.code}`;

            UnifiedModule.showResultBox('error', UnifiedModule.pendingCode1.code, 'INSERTADO (No WMS)', msg, null);

            document.getElementById('unified-code2-container').classList.remove('show');
            document.getElementById('unified-code2-input').value = '';
            UnifiedModule.pendingCode1 = null;

            playSound('warning');
            UnifiedModule.flashInput('warning');
            document.getElementById('unified-scan-input').focus();
            showNotification('âš¡ Registro insertado forzosamente', 'warning');
        }

        // Load saved module preference on startup
        document.addEventListener('DOMContentLoaded', () => {
            const savedModule = localStorage.getItem('pd_current_module');
            if (savedModule === 'unified') {
                // Defer to after app is shown
                setTimeout(() => {
                    if (document.getElementById('main-app') && !document.getElementById('main-app').classList.contains('hidden')) {
                        switchModule('unified');
                    }
                }, 500);
            }
        });
    </script>
</body>
</html>
